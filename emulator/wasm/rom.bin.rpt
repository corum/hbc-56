
; ******** Source: basic_tms.asm
     1                          ; Troy's HBC-56 - BASIC
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          

; ******** Source: basic_hbc56_core.asm
     1                          ; Troy's HBC-56 - BASIC
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          

; ******** Source: ../kernel\hbc56kernel.inc
     1                          ; 6502 - HBC-56 Kernel Include file for user code
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !cpu w65c02
    12                          !initmem $FF
    13                          cputype = $65c02
    14                          

; ******** Source: ../kernel\kernel.o.lmap
     1                          	HBC56_RST_VECTOR	= $f0e4	; ?
     2                          	AY_ENV_SHAPE_SAW1	= $8	; unused
     3                          	tmsConsoleBackspace	= $e9ca	; ?
     4                          	NES_RAM_SIZE	= $1
     5                          	UART_ZP_START	= $28
     6                          	TMS_LT_RED	= $9	; unused
     7                          	UART_STATUS_RCVR_OVERRUN	= $20	; unused
     8                          	HBC56_TMP	= $7ca2
     9                          	KB_SCANCODE_ESC	= $76	; unused
    10                          	AY_ENV_SHAPE_SAW2	= $c	; unused
    11                          	TMS_GFX_TILE_WIDTH	= $8
    12                          	LCD_RAM_END	= $7b58
    13                          	TMS_SPRITE_SIZE	= $8
    14                          	KB_SCANCODE_ARROW_RIGHT	= $f4	; unused
    15                          	KB_CAPS_LOCK	= $8
    16                          	KB_EXT_KEY	= $e0
    17                          	VIA_RAM_SIZE	= $1
    18                          	HBC56_VSYNC_CALLBACK	= $7cb9
    19                          	isLower	= $e000
    20                          	TMS_R1_SPRITE_MAG2	= $1	; unused
    21                          	KB_BUFFER_MASK	= $f
    22                          	KB_SCANCODE_SLASH_FORWARD	= $4a	; unused
    23                          	AY_PORTB	= $f	; unused
    24                          	TMS_R1_RAM_16K	= $80
    25                          	AY_PORTA	= $e	; unused
    26                          	TMS_R1_SPRITE_MAG1	= $0	; unused
    27                          	TMS_FPS	= $3c
    28                          	kbInit	= $eaa2
    29                          	VIA_TMP	= $7c58	; unused
    30                          	tmsSetAddressNextRow	= $e586	; unused
    31                          	UART_IRQ_BIT	= $4
    32                          	tmsModeText	= $e644	; unused
    33                          	VIA_REG_IFR	= $d
    34                          	_tmsSendKb	= $e6a7	; unused
    35                          	UART_STATUS_RX_REG_FULL	= $1
    36                          	tmsReg1SetFields	= $e5e5
    37                          	BITMAP_ZP_START	= $1e
    38                          	JMP_OPCODE	= $4c
    39                          	hbc56IntHandler	= $f05d
    40                          	TILEMAP_RAM_START	= $7a00
    41                          	KB_SCANCODE_SCROLL_LOCK	= $7e	; unused
    42                          	KB_RAM_END	= $7c9c
    43                          	AY_ENV_SHAPE_HOLD	= $1
    44                          	TMS_R0_MODE_GRAPHICS_II	= $2
    45                          	KB_SHIFT_LEFT_MAP_BYTE	= $2
    46                          	VIA_IO_ADDR_IFR	= $7ffd	; unused
    47                          	VIA_IO_ADDR_T1C_H	= $7ff5	; unused
    48                          	MEMORY_ZP_END	= $32
    49                          	TMS_R1_SPRITE_8	= $0	; unused
    50                          	VIA_REG_T1L_H	= $7
    51                          	KB_SCANCODE_PRTSCR	= $92	; unused
    52                          	KB_SCANCODE_SLASH_BACK	= $5d	; unused
    53                          	VIA_IO_ADDR_T1C_L	= $7ff4	; unused
    54                          	AY_WRITE	= $1
    55                          	UART_STATUS_CARRIER_DETECT	= $4	; unused
    56                          	VIA_REG_T1L_L	= $6
    57                          	KB_PRESSED_MAP	= $7c76
    58                          	TMS9918_ZP_START	= $24
    59                          	tmsDecPosConsole	= $e8c4
    60                          	UART_CTL_WORD_8BIT_1SB	= $14	; unused
    61                          	HBC56_CONSOLE_FLAG_LCD	= $20	; unused
    62                          	TMS_CYAN	= $7
    63                          	HBC56_TITLE	= $ed77
    64                          	memcpyMultiPage	= $e0bf	; unused
    65                          	KB_SCANCODE_NUM_LOCK	= $77	; unused
    66                          	TILEMAP_RAM_END	= $7b16
    67                          	VIA_DIR_OUTPUT	= $ff	; unused
    68                          	KB_BUFFER_TAIL	= $7c65
    69                          	tmsSetRegister	= $e5bc
    70                          	hbc56Tms9918Int	= $f08e	; ?
    71                          	KB_SCANCODE_NUMPAD_ENTER	= $da	; unused
    72                          	UART_STATUS_TX_REG_EMPTY	= $2
    73                          	UART_RX_BUFFER_XOFF_SIZE	= $c0
    74                          	KB_FLAGS	= $7c5c
    75                          	HBC56_NMI_VECTOR	= $7e04
    76                          	KB_SCANCODE_SQUARE_LEFT	= $54	; unused
    77                          	BITMAP_ZP_END	= $24
    78                          	UART_CTL_CLOCK_DIV_64	= $2
    79                          	toUpper	= $e06b	; unused
    80                          	VIA_IO_ADDR	= $7ff0
    81                          	tableBitsFromLeft	= $e150	; unused
    82                          	NES_TMP	= $7c9c	; unused
    83                          	HBC56_META_TITLE_END	= $7cb7
    84                          	uartFlowCtrlXoff	= $ea2b	; ?
    85                          	SFXMAN_RAM_START	= $7c59
    86                          	uartInWait	= $ea34
    87                          	uartOutString	= $ea78	; unused
    88                          	RTI_OPCODE	= $40
    89                          	KB_SCANCODE_PAGE_UP	= $fd	; unused
    90                          	AY_ENV_SHAPE_FADE_OUT	= $9	; unused
    91                          	TMS_VRAM_SPRITE_ATTR_ADDRESS	= $3b00
    92                          	NOTE_FREQ_AS8	= 7458.619999999999890860635787248611	; unused
    93                          	HBC56_TMP_Y	= $7ca5
    94                          	KB_SCANCODE_TILDE	= $e	; unused
    95                          	HBC56_TITLE_LEN	= $1a
    96                          	UART_IO_PORT	= $20
    97                          	TMS9918_RAM_END	= $7b58
    98                          	AY_S0_ADDR	= $7f40	; unused
    99                          	TMS9918_ZP_SIZE	= $2
   100                          	HBC56_TMP_X	= $7ca4
   101                          	NOTE_FREQ_AS5	= 932.330000000000040927261579781771	; unused
   102                          	TMS_MED_GREEN	= $2	; unused
   103                          	TMS_WHITE	= $f
   104                          	KB_SCANCODE_WINDOWS_RIGHT	= $a7	; unused
   105                          	HBC56_KERNEL_ZP_END	= $36
   106                          	AY_S1_WRITE	= $7f45	; unused
   107                          	NOTE_FREQ_AS4	= 466.160000000000025011104298755527	; unused
   108                          	VIA_REG_DDR_B	= $2
   109                          	NOTE_FREQ_AS7	= 3729.309999999999945430317893624306	; unused
   110                          	TMS_TMP_ADDRESS	= $24
   111                          	KB_SCANCODE_PERIOD	= $49	; unused
   112                          	VIA_REG_DDR_A	= $3
   113                          	tableBitFromLeft	= $e130
   114                          	NOTE_FREQ_AS6	= 1864.660000000000081854523159563541	; unused
   115                          	AY_NOISE_GEN	= $6	; unused
   116                          	NOTE_FREQ_AS1	= 58.270000000000003126388037344441	; unused
   117                          	AY_S0_WRITE	= $7f41	; unused
   118                          	NOTE_FREQ_AS0	= 29.140000000000000568434188608080	; unused
   119                          	tmsSetAddressRead	= $e5a8
   120                          	VIA_RAM_START	= $7c58
   121                          	NOTE_FREQ_AS3	= 233.080000000000012505552149377763	; unused
   122                          	UART_RX_BUFFER_TAIL	= $29
   123                          	tmsSetPatternRead	= $e941	; unused
   124                          	AY_S1_ADDR	= $7f44	; unused
   125                          	NOTE_FREQ_AS2	= 116.540000000000006252776074688882	; unused
   126                          	UART_RX_BUFFER	= $7b58
   127                          	TMS_R1_SPRITE_16	= $2	; unused
   128                          	TMS_GFX_PIXELS_Y	= $c0	; unused
   129                          	TMS_GFX_PIXELS_X	= $100	; unused
   130                          	KB_SCANCODE_NUMPAD_MULTIPLY	= $7c	; unused
   131                          	HBC56_DISABLE_SFXMAN	= $1
   132                          	tmsSetAddressWrite	= $e592
   133                          	TMS_MAGENTA	= $d	; unused
   134                          	LCD_IO_PORT	= $2	; unused
   135                          	tmsConsoleScrollLine	= $e82f
   136                          	KB_SCANCODE_CTRL_RIGHT	= $94	; unused
   137                          	_tmsSendEmptyPage	= $e6e6
   138                          	KB_BUFFER_SIZE	= $10
   139                          	KB_SCANCODE_COMMA	= $41	; unused
   140                          	HBC56_TITLE_TEXT	= $ed77
   141                          	AY_R10	= $a
   142                          	AY_IO_PORT	= $40
   143                          	AY_R11	= $b
   144                          	NES_LEFT	= $2	; unused
   145                          	AY_R12	= $c
   146                          	TMS_R1_DISP_BLANK	= $0	; unused
   147                          	KB_NUM_LOCK	= $10	; unused
   148                          	hbc56LogoPatt	= $edf9
   149                          	kernelMain	= $f0e4	; ?
   150                          	AY_R13	= $d
   151                          	hbc56LogoPattEnd	= $ef71	; unused
   152                          	ASCII_CR	= $d	; unused
   153                          	AY_R14	= $e
   154                          	KB_SCANCODE_PAGE_DOWN	= $fa	; unused
   155                          	kbIntHandler	= $eadd
   156                          	IO_PORT_BASE_ADDRESS	= $7f00
   157                          	AY_R15	= $f
   158                          	isDigit	= $e01e
   159                          	AY_R16	= $10	; unused
   160                          	HAVE_TMS9918	= $1
   161                          	UART_CTL_MASTER_RESET	= $3
   162                          	AY_R17	= $11	; unused
   163                          	KB_SCANCODE_TAB	= $d	; unused
   164                          	HBC56_KERNEL_ZP_START	= $18
   165                          	TMS9918_IRQ_BIT	= $1
   166                          	HBC56_BORDER	= $4
   167                          	TMS_R1_MODE_MULTICOLOR	= $8
   168                          	TMS_R0_MODE_MULTICOLOR	= $0
   169                          	TMS_DK_BLUE	= $4
   170                          	TMS_VRAM_SPRITE_PATT_ADDRESS	= $1800
   171                          	HBC56_CONSOLE_FLAG_NOWAIT	= $10
   172                          	KB_SCANCODE_ENTER	= $5a	; unused
   173                          	KB_IO_PORT	= $80
   174                          	AY_ENV_SHAPE_ATTACK	= $4
   175                          	UART_STATUS_IRQ	= $80	; unused
   176                          	NES_DOWN	= $4	; unused
   177                          	tmsReg1ClearFields	= $e5ef
   178                          	NES_SELECT	= $20	; unused
   179                          	hbc56Stop	= $f24f
   180                          	UART_RX_BUFFER_SIZE	= $100
   181                          	KB_BUFFER	= $7c66
   182                          	DEFAULT_HBC56_NMI_VECTOR	= $ffe0	; unused
   183                          	NES1_IO_ADDR	= $7f82
   184                          	UART_CTL_WORD_7BIT_OPB_1SB	= $c	; unused
   185                          	KB_SCANCODE_NUMPAD_PLUS	= $79	; unused
   186                          	NES2_IO_ADDR	= $7f83
   187                          	BITMAP_RAM_END	= $7b26
   188                          	KB_SCANCODE_F2	= $6	; unused
   189                          	HBC56_TITLE_TEXT_LEN	= $1a
   190                          	NES_UP	= $8	; unused
   191                          	KB_SCANCODE_F3	= $4	; unused
   192                          	VIA_DIR_INPUT	= $0	; unused
   193                          	DELAY_L	= $34
   194                          	TMS_TXT_TILES_X	= $28
   195                          	ASCII_BACKSPACE	= $8	; unused
   196                          	TMS_TXT_TILES_Y	= $18
   197                          	KB_SCANCODE_F1	= $5	; unused
   198                          	KB_SCANCODE_SEMICOLON	= $4c	; unused
   199                          	KB_SCANCODE_F6	= $b	; unused
   200                          	TMS_R1_DISP_ACTIVE	= $40
   201                          	tmsInitColorTable	= $e756
   202                          	KB_SCANCODE_F7	= $83	; unused
   203                          	KB_SCANCODE_HOME	= $ec	; unused
   204                          	DELAY_H	= $35
   205                          	KB_SCANCODE_F4	= $c	; unused
   206                          	tmsSetPosTmpAddress	= $e7ed
   207                          	uartInNoWait	= $ea3e	; unused
   208                          	hbc56Reset	= $f24c	; unused
   209                          	KB_SCANCODE_F5	= $3	; unused
   210                          	hbc56CustomDelayMs	= $f252	; unused
   211                          	_tmsWaitReg	= $e582
   212                          	uartOut	= $ea61	; ?
   213                          	KB_TMP_X	= $7c5d
   214                          	KB_SCANCODE_F8	= $a	; unused
   215                          	HBC56_KERNEL_RAM_START	= $7a00
   216                          	KB_TMP_Y	= $7c5e	; unused
   217                          	KB_SCANCODE_F9	= $1	; unused
   218                          	tmsConsolePrint	= $e993	; unused
   219                          	uartIrq	= $e9fc
   220                          	TMS_BLACK	= $1
   221                          	HBC56_META_TITLE	= $7ca6
   222                          	KB_SCANCODE_SQUARE_RIGHT	= $5b	; unused
   223                          	tmsConsoleNewline	= $e9a3	; ?
   224                          	AY_S1	= $7f44
   225                          	NOTE_FREQ_C8	= 4186.010000000000218278728425502777	; unused
   226                          	KB_IRQ_BIT	= $2
   227                          	tmsModeGraphicsII	= $e623	; unused
   228                          	AY_S0	= $7f40
   229                          	NOTE_FREQ_A8	= $1b80	; unused
   230                          	HBC56_TICKS	= $7c9f
   231                          	HBC56_SECONDS_H	= $7ca1
   232                          	memcpySinglePage	= $e0a3	; unused
   233                          	tmsModeGraphicsI	= $e610
   234                          	NOTE_FREQ_G8	= 6271.930000000000291038304567337036	; unused
   235                          	AY_ADDR	= $0
   236                          	NOTE_FREQ_E8	= 5274.039999999999963620211929082870	; unused
   237                          	TMS_R1_RAM_4K	= $0	; unused
   238                          	AY_ENV_SHAPE_ALTERNATE	= $2
   239                          	NOTE_FREQ_DS8	= 4978.029999999999745341483503580093	; unused
   240                          	tmsInitEntireColorTable	= $e754	; ?
   241                          	TMS_GREY	= $e
   242                          	NES_B	= $40	; unused
   243                          	HBC56_SECONDS_L	= $7ca0
   244                          	AY_PSG1	= $4
   245                          	UART_CTL_WORD_7BIT_EPB_1SB	= $8	; unused
   246                          	NES_A	= $80	; unused
   247                          	TMS9918_IO_PORT	= $10
   248                          	UART_RAM_END	= $7c58
   249                          	AY_PSG0	= $0
   250                          	UART_FLOWCTRL_XON	= $11
   251                          	DEFAULT_HBC56_RST_VECTOR	= $8000
   252                          	NOTE_FREQ_C0	= 16.350000000000001421085471520200	; unused
   253                          	NOTE_FREQ_A1	= $37	; unused
   254                          	NOTE_FREQ_G2	= $62	; unused
   255                          	NOTE_FREQ_E3	= 164.810000000000002273736754432321
   256                          	NOTE_FREQ_DS4	= 311.129999999999995452526491135359	; unused
   257                          	KB_SCANCODE_CTRL_LEFT	= $14	; unused
   258                          	NOTE_FREQ_A0	= 27.500000000000000000000000000000	; unused
   259                          	NOTE_FREQ_E2	= 82.409999999999996589394868351519	; unused
   260                          	NOTE_FREQ_DS5	= 622.250000000000000000000000000000	; unused
   261                          	tmsReg0ClearFields	= $e5dd
   262                          	UART_STATUS_CLEAR_TO_SEND	= $8	; unused
   263                          	NOTE_FREQ_G3	= $c4	; unused
   264                          	NOTE_FREQ_C1	= 32.700000000000002842170943040401	; unused
   265                          	NOTE_FREQ_G0	= 24.500000000000000000000000000000	; unused
   266                          	NOTE_FREQ_E1	= 41.200000000000002842170943040401	; unused
   267                          	NOTE_FREQ_DS6	= 1244.509999999999990905052982270718	; unused
   268                          	UART_DATA	= $7f21
   269                          	VIA_IO_ADDR_T2C_H	= $7ff9	; unused
   270                          	NOTE_FREQ_C2	= 65.409999999999996589394868351519	; unused
   271                          	NOTE_FREQ_A3	= $dc	; unused
   272                          	NOTE_FREQ_E0	= 20.600000000000001421085471520200	; unused
   273                          	NOTE_FREQ_DS7	= 2489.019999999999981810105964541435	; unused
   274                          	TMS9918_TMP_BUFFER	= $7b30
   275                          	NOTE_FREQ_G1	= $31	; unused
   276                          	NOTE_FREQ_A2	= $6e	; unused
   277                          	NOTE_FREQ_C3	= 130.810000000000002273736754432321	; unused
   278                          	UART_ZP_END	= $2c
   279                          	NOTE_FREQ_DS0	= 19.449999999999999289457264239900	; unused
   280                          	NOTE_FREQ_C4	= 261.629999999999995452526491135359	; unused
   281                          	NOTE_FREQ_A5	= $370	; unused
   282                          	NOTE_FREQ_G6	= 1567.980000000000018189894035458565	; unused
   283                          	NOTE_FREQ_E7	= 2637.019999999999981810105964541435	; unused
   284                          	NOTE_FREQ_DS1	= 38.890000000000000568434188608080	; unused
   285                          	HAVE_KEYBOARD	= $1
   286                          	NOTE_FREQ_A4	= $1b8	; unused
   287                          	NOTE_FREQ_E6	= 1318.509999999999990905052982270718	; unused
   288                          	hbc56HighBell	= $f1cd	; ?
   289                          	NOTE_FREQ_G7	= 3135.960000000000036379788070917130	; unused
   290                          	NOTE_FREQ_C5	= 523.250000000000000000000000000000	; unused
   291                          	tmsConsoleHome	= $e8e1	; unused
   292                          	NOTE_FREQ_DS2	= 77.780000000000001136868377216160	; unused
   293                          	NOTE_FREQ_G4	= $188	; unused
   294                          	NOTE_FREQ_E5	= 659.250000000000000000000000000000	; unused
   295                          	VIA_IO_ADDR_T2C_L	= $7ff8	; unused
   296                          	NOTE_FREQ_C6	= 1046.500000000000000000000000000000	; unused
   297                          	NOTE_FREQ_A7	= $dc0	; unused
   298                          	BCD_RAM_START	= $7c59
   299                          	HBC56_META_TITLE_MAX_LEN	= $10
   300                          	isDigitX	= $e030	; unused
   301                          	NOTE_FREQ_DS3	= 155.560000000000002273736754432321	; unused
   302                          	NOTE_FREQ_E4	= 329.629999999999995452526491135359	; unused
   303                          	NOTE_FREQ_G5	= 783.990000000000009094947017729282	; unused
   304                          	NOTE_FREQ_A6	= $6e0	; unused
   305                          	NOTE_FREQ_C7	= $82d	; unused
   306                          	VIA_RAM_END	= $7c59
   307                          	AY_INACTIVE	= $3	; unused
   308                          	TMS_SPRITE_SIZE2X	= $10	; unused
   309                          	tmsSetPosWriteText	= $e8fa	; ?
   310                          	KB_SCANCODE_F11	= $78	; unused
   311                          	AY_S0_READ	= $7f42	; unused
   312                          	tmsInitTextTable	= $e739	; ?
   313                          	KB_SCANCODE_F10	= $9	; unused
   314                          	VIA_REG_PORT_A	= $1
   315                          	KB_SCANCODE_NUMPAD_PERIOD	= $71	; unused
   316                          	VIA_REG_PORT_B	= $0
   317                          	KB_SCANCODE_F12	= $7	; unused
   318                          	kbNextScancode	= $ebfb
   319                          	KB_SCANCODE_WINDOWS_LEFT	= $9f	; unused
   320                          	BCD_RAM_END	= $7c5c
   321                          	ASCII_RETURN	= $a	; unused
   322                          	TMS_R1_INT_ENABLE	= $20
   323                          	UART_CTL_WORD_8BIT_OPAR_1SB	= $1c	; unused
   324                          	isSpace	= $e049	; unused
   325                          	hbc56BootScreen	= $ef71
   326                          	AY_S1_READ	= $7f46	; unused
   327                          	KB_SCANCODE_END	= $e9	; unused
   328                          	TMS_GFX_TILE_HEIGHT	= $8
   329                          	KB_SCANCODE_SHIFT_RIGHT	= $59
   330                          	TMS_LT_BLUE	= $5	; unused
   331                          	TMS_R0_EXT_VDP_ENABLE	= $1	; unused
   332                          	uartOutNoBsCheck	= $ea67	; ?
   333                          	KB_SCANCODE_ALT_LEFT	= $11	; unused
   334                          	HBC56_INT_VECTOR	= $7e00
   335                          	VIA_REG_IER	= $e
   336                          	tmsIncPosConsole	= $e8a3
   337                          	INT_IO_PORT	= $df
   338                          	KB_PRESSED_MAP_BYTES	= $20
   339                          	VIA_REG_ACR	= $b
   340                          	STR_ADDR_H	= $33
   341                          	NES_RAM_END	= $7c9f
   342                          	memsetSinglePage	= $e101
   343                          	TMS_FONT_DATA	= $e271
   344                          	kbWaitForScancode	= $ebe6
   345                          	tmsReg0SetFields	= $e5d3
   346                          	tmsPrint	= $e947
   347                          	KB_SCANCODE_APOS	= $52	; unused
   348                          	STR_ADDR_L	= $32
   349                          	tmsSetPosConsole	= $e8e7
   350                          	KB_SHIFT_RIGHT_MAP_BYTE	= $b
   351                          	AY_CLOCK_FREQ	= $1e8480
   352                          	tmsSetBackground	= $e5cf
   353                          	TMS_R1_MODE_GRAPHICS_II	= $0
   354                          	UART_RX_BUFFER_XON_SIZE	= $4
   355                          	VIA_IO_ADDR_ACR	= $7ffb	; unused
   356                          	uartFlowCtrlXon	= $ea20	; ?
   357                          	VIA_IO_ADDR_IER	= $7ffe	; unused
   358                          	ASCII_BELL	= $7	; unused
   359                          	BCD_TMP3	= $7c5b
   360                          	TMS_MED_RED	= $8	; unused
   361                          	UART_CTL_WORD_8BIT_EPAR_1SB	= $18	; unused
   362                          	BCD_TMP2	= $7c5a
   363                          	LCD_ZP_END	= $28
   364                          	toLower	= $e073	; unused
   365                          	BCD_TMP1	= $7c59
   366                          	MEM_SRC	= $2e
   367                          	AY_ENABLES	= $7
   368                          	UART_CTL_WORD_7BIT_OPB_2SB	= $4	; unused
   369                          	LCD_RAM_START	= $7b58
   370                          	TMS_LT_GREEN	= $3	; unused
   371                          	_tmsWaitData	= $e579
   372                          	HAVE_MATH_INC	= $1
   373                          	KB_SCANCODE_B	= $32	; unused
   374                          	hbc56Bell	= $f1ff	; unused
   375                          	KB_SCANCODE_C	= $21	; unused
   376                          	TMS_TXT_PIXELS_X	= $f0	; unused
   377                          	HBC56_KERNEL_RAM_SIZE	= $2bd	; unused
   378                          	TMS_TXT_PIXELS_Y	= $c0	; unused
   379                          	KB_SCANCODE_A	= $1c	; unused
   380                          	TMS_GFX_TILES_Y	= $18
   381                          	KB_PRESSED_MAP_SIZE	= $fe	; unused
   382                          	KB_SCANCODE_F	= $2b	; unused
   383                          	kbIsPressed	= $ebc9	; unused
   384                          	TMS_R0_MODE_TEXT	= $0
   385                          	TMS_GFX_TILES_X	= $20
   386                          	KB_SCANCODE_G	= $34	; unused
   387                          	HBC56_DISABLE_LCD	= $1
   388                          	TMS_R0_MODE_GRAPHICS_I	= $0
   389                          	tmsSetSpriteTmpAddress	= $e7e4	; unused
   390                          	KB_CB_RELEASED	= $7c61
   391                          	KB_SCANCODE_D	= $23	; unused
   392                          	TMS_R1_MODE_GRAPHICS_I	= $0
   393                          	KB_SCANCODE_E	= $24	; unused
   394                          	TILEMAP_ZP_START	= $18
   395                          	KB_SHIFT_DOWN	= $1	; unused
   396                          	KB_SCANCODE_J	= $3b	; unused
   397                          	KB_CB_PRESSED	= $7c5f
   398                          	KB_SCANCODE_K	= $42	; unused
   399                          	KB_SHIFT_RIGHT_MAP_BIT	= $40
   400                          	HBC56_CONSOLE_FLAGS	= $7ca3
   401                          	AY_ENV_SHAPE	= $d
   402                          	KB_SCANCODE_H	= $33	; unused
   403                          	kbReadAscii	= $ec63	; unused
   404                          	KB_BUFFER_HEAD	= $7c64
   405                          	KB_SCANCODE_I	= $43	; unused
   406                          	viaIntHandler	= $ed74
   407                          	KB_SCANCODE_N	= $31	; unused
   408                          	tmsTileXyAtPixelXy	= $e7aa	; unused
   409                          	UART_CTL_CLOCK_DIV_16	= $1	; unused
   410                          	nesWaitForPress	= $ea85
   411                          	hbc56LogoInd	= $edb7
   412                          	KB_SCANCODE_O	= $44	; unused
   413                          	memcpyMultiPagePort	= $e0e1	; unused
   414                          	KB_SCANCODE_L	= $4b	; unused
   415                          	bin2bcd8	= $e07b	; unused
   416                          	KB_SCANCODE_M	= $3a	; unused
   417                          	KB_SCANCODE_ARROW_UP	= $f5	; unused
   418                          	UART_RX_BUFFER_HEAD	= $28
   419                          	KB_SCANCODE_R	= $2d	; unused
   420                          	_tmsSendPage	= $e6b0	; ?
   421                          	tmsSetPosWrite	= $e8ed	; unused
   422                          	KB_SCANCODE_S	= $1b	; unused
   423                          	KB_SCANCODE_P	= $4d	; unused
   424                          	TMS_DK_RED	= $6	; unused
   425                          	KB_SCANCODE_Q	= $15	; unused
   426                          	NOTE_FREQ_GS8	= 6644.880000000000109139364212751389	; unused
   427                          	KB_CURRENT_STATE	= $7c63
   428                          	KB_SCANCODE_V	= $2a	; unused
   429                          	NOTE_FREQ_CS8	= 4434.920000000000072759576141834259	; unused
   430                          	KB_SCANCODE_W	= $1d	; unused
   431                          	HBC56_CONSOLE_FLAG_NES	= $40
   432                          	UART_CTL_WORD_7BIT_EPB_2SB	= $0	; unused
   433                          	kbScancodeToAscii	= $ec10
   434                          	KB_SCANCODE_T	= $2c	; unused
   435                          	KB_SHIFT_LEFT_MAP_BIT	= $20
   436                          	TMS_TRANSPARENT	= $0	; unused
   437                          	KB_SCANCODE_U	= $3c	; unused
   438                          	SFXMAN_RAM_END	= $7c59
   439                          	NOTE_FREQ_GS4	= 415.300000000000011368683772161603	; unused
   440                          	tmsSendBytes	= $e6ea
   441                          	NOTE_FREQ_CS5	= 554.370000000000004547473508864641	; unused
   442                          	VIA_REG_T2C_H	= $9
   443                          	KB_SCANCODE_Z	= $1a	; unused
   444                          	LCD_ZP_START	= $28
   445                          	NOTE_FREQ_CS4	= 277.180000000000006821210263296962	; unused
   446                          	NOTE_FREQ_GS5	= 830.610000000000013642420526593924	; unused
   447                          	KB_SCANCODE_MINUS	= $4e	; unused
   448                          	isUpper	= $e00c
   449                          	TMS_VRAM_NAME_ADDRESS	= $3800
   450                          	UART_IRQ	= $3
   451                          	NES_RAM_START	= $7c9c
   452                          	NOTE_FREQ_GS6	= 1661.220000000000027284841053187847	; unused
   453                          	NOTE_FREQ_CS7	= 2217.460000000000036379788070917130	; unused
   454                          	KB_SCANCODE_X	= $22	; unused
   455                          	KB_SCANCODE_PAUSE	= $e1
   456                          	KB_IO_ADDR	= $7f80
   457                          	memcpySinglePagePort	= $e0b1	; unused
   458                          	NOTE_FREQ_CS6	= 1108.730000000000018189894035458565	; unused
   459                          	NOTE_FREQ_GS7	= 3322.440000000000054569682106375694	; unused
   460                          	TMS_REGISTER_DATA	= $e571
   461                          	TMS_MODEL	= $26be
   462                          	KB_SCANCODE_Y	= $35	; unused
   463                          	NOTE_FREQ_GS0	= 25.960000000000000852651282912120	; unused
   464                          	NOTE_FREQ_CS1	= 34.649999999999998578914528479800	; unused
   465                          	VIA_REG_T2C_L	= $8
   466                          	ROM_BANK_REG	= $8	; unused
   467                          	HBC56_USER_ZP_START	= $36	; unused
   468                          	NOTE_FREQ_CS0	= 17.320000000000000284217094304040	; unused
   469                          	NOTE_FREQ_GS1	= 51.909999999999996589394868351519	; unused
   470                          	UART_CTL_RX_INT_ENABLE	= $80
   471                          	KB_SCANCODE_CAPS_LOCK	= $58
   472                          	tableInvBitFromRight	= $e148	; unused
   473                          	tmsInitPattTable	= $e6f9	; ?
   474                          	TMS9918_IRQ	= $1
   475                          	HBC56_CONSOLE_FLAG_CURSOR	= $80	; unused
   476                          	NOTE_FREQ_GS2	= 103.829999999999998294697434175760	; unused
   477                          	NOTE_FREQ_CS3	= 138.590000000000003410605131648481	; unused
   478                          	tmsModeMulticolor	= $e657	; unused
   479                          	NOTE_FREQ_CS2	= 69.299999999999997157829056959599	; unused
   480                          	NOTE_FREQ_GS3	= 207.650000000000005684341886080801	; unused
   481                          	KB_IRQ	= $2
   482                          	VIA_IO_PORT	= $f0
   483                          	HBC56_VIA_CALLBACK	= $7cbb
   484                          	_tmsSendX8	= $e6b2
   485                          	KB_SCANCODE_NUMPAD_5	= $73	; unused
   486                          	AY_CHA	= $0
   487                          	KB_SCANCODE_ALT_RIGHT_	= $91	; unused
   488                          	KB_SCANCODE_NUMPAD_4	= $6b	; unused
   489                          	AY_CHB	= $1
   490                          	KB_RAM_SIZE	= $3a
   491                          	tmsSetPatternWrite	= $e93b	; unused
   492                          	KB_SCANCODE_NUMPAD_7	= $6c	; unused
   493                          	UART_RAM_START	= $7b58
   494                          	AY_CHC	= $2
   495                          	KB_SCANCODE_NUMPAD_6	= $74	; unused
   496                          	MEMORY_ZP_SIZE	= $6
   497                          	KB_SCANCODE_NUMPAD_1	= $69	; unused
   498                          	KEY_MAP_SHIFTED	= $ecf4	; ?
   499                          	AY_READ	= $2
   500                          	KB_SCANCODE_NUMPAD_0	= $70	; unused
   501                          	KB_SCANCODE_NUMPAD_3	= $7a	; unused
   502                          	HBC56_LOGO	= $4
   503                          	VIA_IRQ	= $5
   504                          	tableBitFromRight	= $e140	; unused
   505                          	KB_SCANCODE_NUMPAD_2	= $72	; unused
   506                          	TMS9918_CONSOLE_LINE_LEN	= $7b2b
   507                          	KB_SCANCODE_NUMPAD_MINUS	= $7b	; unused
   508                          	BITMAP_RAM_START	= $7b16
   509                          	uartInit	= $e9e0	; unused
   510                          	hbc56CustomDelay	= $ffe3
   511                          	UART_STATUS_FRAMING_ERROR	= $10	; unused
   512                          	HBC56_BACKGROUND	= $f
   513                          	AY_ENV_SHAPE_FADE_IN_STOP	= $4	; unused
   514                          	HAVE_UART	= $1
   515                          	MEM_DST	= $2c
   516                          	TMS_DK_YELLOW	= $a	; unused
   517                          	UART_STATUS_PARITY_ERROR	= $40	; unused
   518                          	KB_SCANCODE_NUMPAD_9	= $7d	; unused
   519                          	KB_SCANCODE_NUMPAD_8	= $75	; unused
   520                          	AY_CHN	= $3	; unused
   521                          	AY_ENV_SHAPE_TRIANGLE	= $e	; unused
   522                          	hbc56Delay	= $ffe1
   523                          	tableInvBitFromLeft	= $e138
   524                          	KB_SCANCODE_2	= $1e	; unused
   525                          	AY_CHB_TONE_H	= $3	; unused
   526                          	KB_SCANCODE_3	= $26	; unused
   527                          	kbResetCallbacks	= $eacc	; unused
   528                          	NES_IO_PORT	= $82
   529                          	TMS9918_RAM_SIZE	= $32
   530                          	KB_SCANCODE_0	= $45	; unused
   531                          	TMS9918_RAM_START	= $7b26
   532                          	AY_CHA_TONE_L	= $0
   533                          	AY_CHC_TONE_H	= $5	; unused
   534                          	AY_ENV_SHAPE_CONTINUE	= $8
   535                          	KB_SCANCODE_1	= $16	; unused
   536                          	HBC56_TEXT	= $4
   537                          	HBC56_META_VECTOR	= $dffc
   538                          	cputype	= $65c02	; unused
   539                          	KB_SCANCODE_6	= $36	; unused
   540                          	HBC56_KERNEL_RAM_END	= $7cbd
   541                          	AY_CHB_TONE_L	= $2	; unused
   542                          	KB_SCANCODE_7	= $3d	; unused
   543                          	AY_ENV_SHAPE_FADE_IN	= $d	; unused
   544                          	tmsModeReset	= $e5f7
   545                          	KB_SCANCODE_DELETE	= $f1	; unused
   546                          	KB_SCANCODE_4	= $25	; unused
   547                          	KB_SCANCODE_MENU	= $af	; unused
   548                          	KB_SCANCODE_SPACEBAR	= $29	; unused
   549                          	AY_CHA_TONE_H	= $1
   550                          	AY_CHC_TONE_L	= $4	; unused
   551                          	KB_SCANCODE_5	= $2e	; unused
   552                          	MEMORY_ZP_START	= $2c
   553                          	tmsSetPosRead	= $e900	; unused
   554                          	nes1Pressed	= $ea92	; unused
   555                          	VIA_REG_T1C_H	= $5
   556                          	INT_CTRL_ADDRESS	= $7fdf
   557                          	STR_ADDR	= $32
   558                          	AY_ENV_PERIOD_H	= $c
   559                          	tmsHex8	= $e7b7	; unused
   560                          	VIA_IO_ADDR_T1L_H	= $7ff7	; unused
   561                          	TILEMAP_ZP_END	= $1e
   562                          	KEY_MAP	= $ec74	; ?
   563                          	KB_SCANCODE_8	= $3e	; unused
   564                          	KB_RAM_START	= $7c5c
   565                          	KB_SCANCODE_9	= $46	; unused
   566                          	VIA_REG_T1C_L	= $4
   567                          	AY_ENV_PERIOD_L	= $b
   568                          	KB_CTRL_DOWN	= $2	; unused
   569                          	KB_PAUSE_KEY	= $e1
   570                          	VIA_IO_ADDR_T1L_L	= $7ff6	; unused
   571                          	NES_RIGHT	= $1	; unused
   572                          	nes2Pressed	= $ea9a	; unused
   573                          	MEM_LEN	= $30
   574                          	VIA_IO_ADDR_PORT_A	= $7ff1	; unused
   575                          	UART_CTL_WORD_8BIT_2SB	= $10
   576                          	NES_START	= $10	; unused
   577                          	HBC56_META_TITLE_LEN	= $7cb8
   578                          	memsetMultiPage	= $e10d	; unused
   579                          	UART_REG	= $7f20
   580                          	LCD_MODEL	= $3240	; unused
   581                          	KB_SCANCODE_SHIFT_LEFT	= $12
   582                          	VIA_IO_ADDR_PORT_B	= $7ff0	; unused
   583                          	isAlNum	= $e02a	; unused
   584                          	AY_CHA_AMPL	= $8
   585                          	LAST_MODULE_RAM_END	= $7c9f
   586                          	TMS_R1_MODE_TEXT	= $10
   587                          	tmsConsoleOut	= $e95a
   588                          	TMS9918_REG	= $7f11
   589                          	KB_SCANCODE_NUMPAD_DIVIDE	= $ca	; unused
   590                          	DEFAULT_HBC56_INT_VECTOR	= $ffe0
   591                          	VIA_IRQ_BIT	= $10
   592                          	TMS_VRAM_PATT_ADDRESS	= $2000
   593                          	KB_SCANCODE_EQUAL	= $55	; unused
   594                          	KB_RELEASE	= $f0
   595                          	tmsInitSpriteTable	= $e775	; ?
   596                          	KB_SCANCODE_ARROW_DOWN	= $f2	; unused
   597                          	UART_RX_BUFFER_BYTES	= $2a
   598                          	isAlpha	= $e018
   599                          	ayInit	= $e158
   600                          	TMS9918_RAM	= $7f10
   601                          	UART_RX_FLAGS	= $2b
   602                          	AY_R1	= $1
   603                          	NOTE_FREQ_B8	= 7902.130000000000109139364212751389	; unused
   604                          	KB_STATUS_ADDR	= $7f81
   605                          	AY_R0	= $0
   606                          	AY_R3	= $3
   607                          	NOTE_FREQ_F8	= 5587.649999999999636202119290828705	; unused
   608                          	AY_R2	= $2
   609                          	NOTE_FREQ_D8	= 4698.630000000000109139364212751389	; unused
   610                          	TMS_DK_GREEN	= $c	; unused
   611                          	AY_R5	= $5
   612                          	AY_CHC_AMPL	= $a	; unused
   613                          	NOTE_FREQ_FS8	= 5919.909999999999854480847716331482	; unused
   614                          	AY_R4	= $4
   615                          	AY_R7	= $7
   616                          	KB_ALT_DOWN	= $4	; unused
   617                          	AY_R6	= $6
   618                          	TMS_TXT_TILE_HEIGHT	= $8
   619                          	AY_R9	= $9
   620                          	NOTE_FREQ_B0	= 30.870000000000000994759830064140	; unused
   621                          	NOTE_FREQ_F2	= 87.310000000000002273736754432321	; unused
   622                          	NOTE_FREQ_D3	= 146.830000000000012505552149377763	; unused
   623                          	NOTE_FREQ_FS4	= 369.990000000000009094947017729282	; unused
   624                          	TMS_VRAM_COLOR_ADDRESS+2	= $0
   625                          	tmsSetPatternTmpAddressBank1	= $e925	; unused
   626                          	VIA_IO_ADDR_DDR_A	= $7ff3	; unused
   627                          	AY_R8	= $8
   628                          	NOTE_FREQ_B1	= 61.740000000000001989519660128281	; unused
   629                          	NOTE_FREQ_D2	= 73.420000000000001705302565824240	; unused
   630                          	NOTE_FREQ_FS5	= 739.990000000000009094947017729282	; unused
   631                          	UART_FLOWCTRL_XOFF	= $13
   632                          	TMS_R0_EXT_VDP_DISABLE	= $0
   633                          	tmsSetPatternTmpAddressBank0	= $e906	; unused
   634                          	NOTE_FREQ_F3	= 174.610000000000013642420526593924	; unused
   635                          	NOTE_FREQ_F0	= 21.829999999999998294697434175760	; unused
   636                          	NOTE_FREQ_D1	= 36.710000000000000852651282912120	; unused
   637                          	NOTE_FREQ_FS6	= 1479.980000000000018189894035458565	; unused
   638                          	TMS9918_CONSOLE_Y	= $7b29
   639                          	TMS_LT_YELLOW	= $b	; unused
   640                          	KB_SCANCODE_ARROW_LEFT	= $eb	; unused
   641                          	NOTE_FREQ_B2	= 123.469999999999998863131622783840	; unused
   642                          	NOTE_FREQ_D0	= 18.350000000000001421085471520200	; unused
   643                          	NOTE_FREQ_FS7	= 2959.960000000000036379788070917130	; unused
   644                          	TMS9918_CONSOLE_X	= $7b28
   645                          	tmsSetPatternTmpAddressBank2	= $e930	; unused
   646                          	VIA_IO_ADDR_DDR_B	= $7ff2	; unused
   647                          	NOTE_FREQ_F1	= 43.649999999999998578914528479800	; unused
   648                          	NOTE_FREQ_B3	= 246.939999999999997726263245567679	; unused
   649                          	HBC56_KERNEL_START	= $e000
   650                          	TMS9918_ZP_END	= $28
   651                          	HAVE_AY3891X	= $1
   652                          	NOTE_FREQ_FS0	= 23.120000000000000994759830064140	; unused
   653                          	TMS_R1_INT_DISABLE	= $0	; unused
   654                          	AY_CHB_AMPL	= $9	; unused
   655                          	NOTE_FREQ_B4	= 493.879999999999995452526491135359	; unused
   656                          	NOTE_FREQ_F6	= 1396.910000000000081854523159563541	; unused
   657                          	NOTE_FREQ_D7	= 2349.320000000000163709046319127083	; unused
   658                          	NOTE_FREQ_FS1	= 46.250000000000000000000000000000	; unused
   659                          	NOTE_FREQ_B5	= 987.769999999999981810105964541435	; unused
   660                          	NOTE_FREQ_D6	= 1174.660000000000081854523159563541	; unused
   661                          	TMS_TXT_TILE_WIDTH	= $6
   662                          	tmsSetPosTmpAddressText	= $e80a
   663                          	tmsSetPatternTmpAddress	= $e906
   664                          	NOTE_FREQ_F7	= 2793.829999999999927240423858165741	; unused
   665                          	NOTE_FREQ_FS2	= 92.500000000000000000000000000000	; unused
   666                          	NOTE_FREQ_F4	= 349.230000000000018189894035458565	; unused
   667                          	NOTE_FREQ_D5	= 587.330000000000040927261579781771	; unused
   668                          	LOGO_BUFFER	= $3000	; unused
   669                          	NOTE_FREQ_B6	= 1975.529999999999972715158946812153	; unused
   670                          	TMS9918_CONSOLE_SIZE_X	= $7b2a
   671                          	KB_SCANCODE_BACKSPACE	= $66	; unused
   672                          	NOTE_FREQ_FS3	= $b9	; unused
   673                          	NOTE_FREQ_D4	= 293.660000000000025011104298755527	; unused
   674                          	tmsInit	= $e665
   675                          	NOTE_FREQ_F5	= 698.460000000000036379788070917130
   676                          	NOTE_FREQ_B7	= 3951.070000000000163709046319127083	; unused
   677                          	KB_SCANCODE_INSERT	= $f0	; unused

; ******** Source: ../kernel\hbc56kernel.inc
    15                          
    16                          

; ******** Source: ../lib\ut\math.inc
     1                          ; 6502
     2                          ;
     3                          ; Math macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          HAVE_MATH_INC = 1
    14                          
    15                          !macro lsr2 {
    16                                  lsr
    17                                  lsr
    18                          }
    19                          
    20                          !macro lsr3 {
    21                                  +lsr2
    22                                  lsr
    23                          }
    24                          
    25                          !macro lsr4 {
    26                                  +lsr3
    27                                  lsr
    28                          }
    29                          
    30                          !macro lsr5 {
    31                                  +lsr4
    32                                  lsr
    33                          }
    34                          
    35                          !macro lsr6 {
    36                                  +lsr5
    37                                  lsr
    38                          }
    39                          
    40                          !macro lsr7 {
    41                                  +lsr6
    42                                  lsr
    43                          }
    44                          
    45                          !macro div2   { lsr }
    46                          !macro div4   { +lsr2 }
    47                          !macro div8   { +lsr3 }
    48                          !macro div16  { +lsr4 }
    49                          !macro div32  { +lsr5 }
    50                          !macro div64  { +lsr6 }
    51                          !macro div128 { +lsr7 }
    52                          
    53                          !macro asl2 {
    54                                  asl
    55                                  asl
    56                          }
    57                          
    58                          !macro asl3 {
    59                                  +asl2
    60                                  asl
    61                          }
    62                          
    63                          !macro asl4 {
    64                                  +asl3
    65                                  asl
    66                          }
    67                          
    68                          !macro asl5 {
    69                                  +asl4
    70                                  asl
    71                          }
    72                          
    73                          !macro asl6 {
    74                                  +asl5
    75                                  asl
    76                          }
    77                          
    78                          !macro asl7 {
    79                                  +asl6
    80                                  asl
    81                          }
    82                          
    83                          !macro mul2   { asl }
    84                          !macro mul4   { +asl2 }
    85                          !macro mul8   { +asl3 }
    86                          !macro mul16  { +asl4 }
    87                          !macro mul32  { +asl5 }
    88                          !macro mul64  { +asl6 }
    89                          !macro mul128 { +asl7 }
    90                          
    91                          
    92                          
    93                          ; -----------------------------------------------------------------------------
    94                          ; +dec16: decement a 16-bit value
    95                          ; -----------------------------------------------------------------------------
    96                          ; Inputs:
    97                          ;  addr: address containing LSB of value to decrement
    98                          ; -----------------------------------------------------------------------------
    99                          !macro dec16 .addr {
   100                            lda .addr
   101                            bne +
   102                            dec .addr + 1
   103                          +
   104                            dec .addr
   105                          }
   106                          
   107                          ; -----------------------------------------------------------------------------
   108                          ; +inc16: increment a 16-bit value
   109                          ; -----------------------------------------------------------------------------
   110                          ; Inputs:
   111                          ;  addr: address containing LSB of value to increment
   112                          ; -----------------------------------------------------------------------------
   113                          !macro inc16 .addr {
   114                            inc .addr
   115                            bne +
   116                            inc .addr + 1
   117                          +
   118                          }
   119                          
   120                          ; -----------------------------------------------------------------------------
   121                          ; +cmp16: compare two 16-bit values in memory
   122                          ; -----------------------------------------------------------------------------
   123                          ; Inputs:
   124                          ;  left:  address containing LSB of left value to comapre
   125                          ;  right: address containing LSB of right value to comapre
   126                          ; Outputs:
   127                          ;  C set if right < left
   128                          ;  Z set if right == left
   129                          ; -----------------------------------------------------------------------------
   130                          !macro cmp16 .left, .right {
   131                            lda .left + 1
   132                            cmp .right + 1
   133                          	bne +
   134                          	lda .left
   135                          	cmp .right
   136                          +
   137                          }
   138                          
   139                          ; -----------------------------------------------------------------------------
   140                          ; +cmp16: compare two 16-bit values in memory
   141                          ; -----------------------------------------------------------------------------
   142                          ; Inputs:
   143                          ;  value: immediate value to compare
   144                          ;  x:     msb
   145                          ;  a:     lsb
   146                          ; -----------------------------------------------------------------------------
   147                          !macro cmp16xa .value {
   148                            cpx #>.value
   149                          	bne .doneCmpXa
   150                          	cmp #<.value
   151                          .doneCmpXa
   152                          }
   153                          
   154                          ; -----------------------------------------------------------------------------
   155                          ; +sub16: subtract 16 bit numbers
   156                          ; -----------------------------------------------------------------------------
   157                          ; Inputs:
   158                          ;  left:  address containing LSB of left value
   159                          ;  right: address containing LSB of right value
   160                          ; Outputs:
   161                          ;  res:   address containing LSB of result
   162                          ; -----------------------------------------------------------------------------
   163                          !macro sub16 .left, .right, .res {
   164                            sec
   165                            lda .left
   166                            sbc .right
   167                            sta .res
   168                            lda .left + 1
   169                            sbc .right + 1
   170                            sta .res + 1
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; +sub16: subtract 16 bit numbers - result in ax registers
   175                          ; -----------------------------------------------------------------------------
   176                          ; Inputs:
   177                          ;  left:  address containing LSB of left value
   178                          ;  right: address containing LSB of right value
   179                          ; Outputs:
   180                          ;  a:     result msb
   181                          ;  x:     result lsb
   182                          ; -----------------------------------------------------------------------------
   183                          !macro sub16 .left, .right {
   184                            sec
   185                            lda .left
   186                            sbc .right
   187                            tax
   188                            lda .left + 1
   189                            sbc .right + 1
   190                          }
   191                          
   192                          
   193                          ; -----------------------------------------------------------------------------
   194                          ; +add16: add 16 bit numbers - result in ax registers
   195                          ; -----------------------------------------------------------------------------
   196                          ; Inputs:
   197                          ;  left:  address containing LSB of left value
   198                          ;  right: address containing LSB of right value
   199                          ; Outputs:
   200                          ;  a:     result msb
   201                          ;  x:     result lsb
   202                          ; -----------------------------------------------------------------------------
   203                          !macro add16 .left, .right {
   204                            clc
   205                            lda .left
   206                            adc .right
   207                            tax
   208                            lda .left + 1
   209                            adc .right + 1
   210                          }
   211                          
   212                          
   213                          ; -----------------------------------------------------------------------------
   214                          ; +add16Imm: add 16 bit numbers - result stored to res
   215                          ; -----------------------------------------------------------------------------
   216                          ; Inputs:
   217                          ;  left:  address containing LSB of left value
   218                          ;  imm:   immediate value to add
   219                          ; Outputs:
   220                          ;  res: address to store result
   221                          ; -----------------------------------------------------------------------------
   222                          !macro add16Imm .left, .imm, .res {
   223                            clc
   224                            lda .left
   225                            adc #<.imm
   226                            sta .res
   227                            lda .left + 1
   228                            adc #>.imm
   229                            sta .res + 1
   230                          }
   231                          
   232                          
   233                          ; -----------------------------------------------------------------------------
   234                          ; +subImm8From16: subtract an 8 bit number from a 16 bit number
   235                          ; -----------------------------------------------------------------------------
   236                          ; Inputs:
   237                          ;  left:  address containing LSB of left value
   238                          ;  right: immediate 8-bit value
   239                          ; Outputs:
   240                          ;  res:   address containing LSB of result
   241                          ; -----------------------------------------------------------------------------
   242                          !macro subImm8From16 .left, .right, .res {
   243                            sec
   244                            lda .left
   245                            sbc #.right
   246                            sta .res
   247                            lda .left + 1
   248                            sbc #0
   249                            sta .res + 1
   250                          }
   251                          
   252                          ; -----------------------------------------------------------------------------
   253                          ; +incBcd: increment a BCD byte (inc instruction doesn't work in bcd mode)
   254                          ; -----------------------------------------------------------------------------
   255                          ; Inputs:
   256                          ;  addr:  address containing BCD value
   257                          ; -----------------------------------------------------------------------------
   258                          !macro incBcd .addr {
   259                            lda .addr
   260                            sed
   261                            clc
   262                            adc #1
   263                            cld
   264                            sta .addr
   265                          }
   266                          
   267                          ; -----------------------------------------------------------------------------
   268                          ; +decBcd: decrement a BCD byte (inc instruction doesn't work in bcd mode)
   269                          ; -----------------------------------------------------------------------------
   270                          ; Inputs:
   271                          ;  addr:  address containing BCD value
   272                          ; -----------------------------------------------------------------------------
   273                          !macro decBcd .addr {
   274                            lda .addr
   275                            sed
   276                            sec
   277                            sbc #1
   278                            cld
   279                            sta .addr

; ******** Source: ../kernel\hbc56kernel.inc
    17                          

; ******** Source: ../lib\ut\memory.inc
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; store16: Write a 16-bit immediate value to memory
    15                          ; -----------------------------------------------------------------------------
    16                          ; Inputs:
    17                          ;	.dst: destination address
    18                          ;	.val16: 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          !macro store16 .dst, .val16 {
    21                                  lda #<.val16
    22                                  sta .addr
    23                                  lda #>.val16
    24                                  sta .addr + 1
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; memcpy: Copy a fixed number of bytes from .src to dest
    29                          ; -----------------------------------------------------------------------------
    30                          ; Inputs:
    31                          ;	.src: source address
    32                          ;	.dst: destination address
    33                          ;	.cnt: number of bytes
    34                          ; -----------------------------------------------------------------------------
    35                          !macro memcpy .dst, .src, .cnt {
    36                          !if .cnt <= 0 {
    37                          	!error "memcpy: invalid count: ", .cnt
    38                          } else if .cnt <= 8 {
    39                          	!for i, 0, .cnt - 1 {
    40                          		lda .src + i
    41                          		sta .dst + i
    42                          	}
    43                          } else { !if .cnt <= 256 {
    44                          	ldx #0
    45                          -
    46                          	lda .src, x
    47                          	sta .dst, x
    48                          	inx
    49                          	cpx #(.cnt & $ff)	
    50                          	bne -
    51                          } else {
    52                          	lda #<.src
    53                          	sta MEM_SRC
    54                          	lda #>.src
    55                          	sta MEM_SRC + 1
    56                          
    57                          	lda #<.dst
    58                          	sta MEM_DST
    59                          	lda #>.dst
    60                          	sta MEM_DST + 1
    61                          
    62                          
    63                          		lda #<.cnt
    64                          		sta MEM_LEN
    65                          		lda #>.cnt
    66                          		sta MEM_LEN + 1
    67                          		jsr memcpyMultiPage
    68                          	}
    69                          }
    70                          }
    71                          
    72                          !macro setMemCpySrc .src {
    73                          	lda #<.src
    74                          	sta MEM_SRC
    75                          	lda #>.src
    76                          	sta MEM_SRC + 1
    77                          }
    78                          
    79                          !macro setMemCpyDst .dst {
    80                          	lda #<.dst
    81                          	sta MEM_DST
    82                          	lda #>.dst
    83                          	sta MEM_DST + 1
    84                          }
    85                          
    86                          !macro setMemCpySrcInd .srcRef {
    87                          	lda .srcRef
    88                          	sta MEM_SRC
    89                          	lda .srcRef + 1
    90                          	sta MEM_SRC + 1
    91                          }
    92                          
    93                          !macro setMemCpyDstInd .dstRef {
    94                          	lda .dstRef
    95                          	sta MEM_DST
    96                          	lda .dstRef + 1
    97                          	sta MEM_DST + 1
    98                          }
    99                          
   100                          !macro memcpySinglePage .bytes {
   101                          
   102                          	!if .bytes <= 0 {
   103                          		!error "memcpySinglePage: invalid count: ", .bytes
   104                          	}	
   105                          
   106                          	ldy #.bytes
   107                          	jsr memcpySinglePage
   108                          }
   109                          
   110                          
   111                          ; -----------------------------------------------------------------------------
   112                          ; memcpyPort: Copy a fixed number of bytes from .src ram to dest port
   113                          ; -----------------------------------------------------------------------------
   114                          ; Inputs:
   115                          ;	.src: source address
   116                          ;	.dst: destination address
   117                          ;	.cnt: number of bytes
   118                          ; -----------------------------------------------------------------------------
   119                          !macro memcpyPort .dst, .src, .cnt {
   120                          	!if .cnt <= 0 {
   121                          		!error "memcpyPort: invalid count: ", .cnt
   122                          	}
   123                          	
   124                          	lda #<.src
   125                          	sta MEM_SRC
   126                          	lda #>.src
   127                          	sta MEM_SRC + 1
   128                          
   129                          	lda #<.dst
   130                          	sta MEM_DST
   131                          	lda #>.dst
   132                          	sta MEM_DST + 1
   133                          
   134                          	!if .cnt <= 256 {
   135                          		ldy #<.cnt					
   136                          		jsr memcpySinglePagePort
   137                          	} else {
   138                          		lda #<.cnt
   139                          		sta MEM_LEN
   140                          		lda #>.cnt
   141                          		sta MEM_LEN + 1
   142                          		jsr memcpyMultiPagePort
   143                          	}
   144                          }
   145                          
   146                          !zone {
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; memset: Set a fixed number of bytes to a single value
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;	.dst: destination address
   153                          ;	val: the byte value
   154                          ;	.cnt: number of bytes
   155                          ; -----------------------------------------------------------------------------
   156                          !macro memset .dst, .val, .cnt {
   157                          !if .cnt <= 0 {
   158                          	!error "memset: invalid count: ", .cnt
   159                          } else if .cnt <= 8 {
   160                          	lda #.val
   161                          	!for i, 0, .cnt - 1 {
   162                          	sta .dst + i
   163                          	}
   164                          } else if .cnt <= 256 {
   165                          	ldx #<.cnt
   166                          	lda #.val
   167                          -
   168                          	dex
   169                          	sta .dst, x
   170                          	cpx #0
   171                          	bne -
   172                          } else {
   173                          	lda #<.dst
   174                          	sta MEM_DST
   175                          	lda #>.dst
   176                          	sta MEM_DST + 1
   177                          	lda #<.cnt
   178                          	sta MEM_LEN
   179                          	lda #>.cnt
   180                          	sta MEM_LEN + 1
   181                          	lda #.val
   182                          	jsr memsetMultiPage
   183                          }
   184                          }
   185                          
   186                          

; ******** Source: ../kernel\hbc56kernel.inc
    18                          

; ******** Source: ../lib\gfx\tms9918.inc
     1                          ; 6502 - TMS9918 VDP Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; tmsWaitReg: Not sure how much delay we need so make a macro for now
    15                          ; -----------------------------------------------------------------------------
    16                          !macro tmsWaitReg {
    17                                  jsr _tmsWaitReg
    18                          }
    19                          
    20                          ; -----------------------------------------------------------------------------
    21                          ; tmsWaitData: Not sure how much delay we need so make a macro for now
    22                          ; -----------------------------------------------------------------------------
    23                          !macro tmsWaitData {
    24                                  jsr _tmsWaitData
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; tmsSetAddressWrite: Set an address in the TMS9918
    29                          ; -----------------------------------------------------------------------------
    30                          !macro tmsSetAddressWrite .addr {
    31                                  +tmsSetAddressRead ($4000 | .addr)
    32                          }
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; tmsSetAddressRead: Set an address to read from the TMS9918
    36                          ; -----------------------------------------------------------------------------
    37                          !macro tmsSetAddressRead .addr {
    38                                  php
    39                                  sei             ; we can't be interrupted here
    40                                  lda #<(.addr)
    41                                  sta TMS9918_REG
    42                                  +tmsWaitReg
    43                                  lda #>(.addr)
    44                                  sta TMS9918_REG
    45                                  +tmsWaitReg
    46                                  plp
    47                          }
    48                          
    49                          ; -----------------------------------------------------------------------------
    50                          ; tmsGet: Get a byte of data from the TMS9918
    51                          ; -----------------------------------------------------------------------------
    52                          !macro tmsGet {
    53                                  lda TMS9918_RAM
    54                                  +tmsWaitData
    55                          }
    56                          
    57                          ; -----------------------------------------------------------------------------
    58                          ; tmsPut: Send a byte of data to the TMS9918
    59                          ; -----------------------------------------------------------------------------
    60                          !macro tmsPut .byte {
    61                                  lda #(.byte & 0xff)
    62                                  +tmsPut
    63                          }
    64                          
    65                          
    66                          ; -----------------------------------------------------------------------------
    67                          ; tmsPut: Send a byte (A) of data to the TMS9918
    68                          ; -----------------------------------------------------------------------------
    69                          !macro tmsPut {
    70                                  sta TMS9918_RAM
    71                                  +tmsWaitData
    72                          }
    73                          
    74                          ; -----------------------------------------------------------------------------
    75                          ; tmsSetColor: Set current fg/bg color
    76                          ; -----------------------------------------------------------------------------
    77                          !macro tmsSetColor .color {
    78                                  lda #.color
    79                                  jsr tmsSetBackground
    80                          }
    81                          
    82                          ; -----------------------------------------------------------------------------
    83                          ; tmsSetColorFgBg: Set current fg/bg color
    84                          ; -----------------------------------------------------------------------------
    85                          !macro tmsSetColorFgBg .fg, .bg {
    86                                  +tmsColorFgBg .fg, .bg
    87                                  jsr tmsSetBackground
    88                          }
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; byteTmsColorFgBg: Output a data byte
    92                          ; -----------------------------------------------------------------------------
    93                          !macro byteTmsColorFgBg .fg, .bg {
    94                          !byte (.fg << 4 | .bg)
    95                          }
    96                          
    97                          
    98                          ; -----------------------------------------------------------------------------
    99                          ; tmsDisableOutput: Disable the TMS9918 output
   100                          ; -----------------------------------------------------------------------------
   101                          !macro tmsDisableOutput {
   102                                  lda #TMS_R1_DISP_ACTIVE
   103                                  jsr tmsReg1ClearFields
   104                          }
   105                          
   106                          ; -----------------------------------------------------------------------------
   107                          ; tmsEnableOutput: Enable the TMS9918 output
   108                          ; -----------------------------------------------------------------------------
   109                          !macro tmsEnableOutput {
   110                                  lda #TMS_R1_DISP_ACTIVE
   111                                  jsr tmsReg1SetFields
   112                          }
   113                          
   114                          ; -
   115                          !macro tmsEnableInterrupts {
   116                                  lda #TMS_R1_INT_ENABLE
   117                                  jsr tmsReg1SetFields
   118                          }
   119                          
   120                          !macro tmsDisableInterrupts {
   121                                  lda #TMS_R1_INT_ENABLE
   122                                  jsr tmsReg1ClearFields
   123                          }
   124                          
   125                          !macro tmsConsoleOut .char {
   126                                  lda #.char
   127                                  jsr tmsConsoleOut
   128                          }
   129                          
   130                          
   131                          ; -----------------------------------------------------------------------------
   132                          ; tmsConsolePrintAddr: Print text to console
   133                          ; -----------------------------------------------------------------------------
   134                          ; Inputs:
   135                          ;  textAddr: Address of null-terminated string to print
   136                          ; -----------------------------------------------------------------------------
   137                          !macro tmsConsolePrintAddr .textAddr {
   138                                  lda #<.textAddr
   139                                  sta STR_ADDR_L
   140                                  lda #>.textAddr
   141                                  sta STR_ADDR_H
   142                                  jsr tmsConsolePrint        
   143                          }
   144                          
   145                          ; -----------------------------------------------------------------------------
   146                          ; tmsConsolePrint: Print immediate text to console
   147                          ; -----------------------------------------------------------------------------
   148                          ; Inputs:
   149                          ;  str: String to print
   150                          ; -----------------------------------------------------------------------------
   151                          !macro tmsConsolePrint .str {
   152                          	jmp .afterText
   153                          .textAddr
   154                          	!text .str,0
   155                          .afterText        
   156                                  +tmsConsolePrintAddr .textAddr
   157                          }
   158                          
   159                          ; -----------------------------------------------------------------------------
   160                          ; +tmsColorFgBg: Set A to the given FG / BG color
   161                          ; -----------------------------------------------------------------------------
   162                          !macro tmsColorFgBg .fg, .bg {
   163                                  lda #(.fg << 4 | .bg)
   164                          }
   165                          
   166                          ; -----------------------------------------------------------------------------
   167                          ; tmsReadStatus: Read status - clear interrupt
   168                          ; -----------------------------------------------------------------------------
   169                          !macro tmsReadStatus  {
   170                                  bit TMS9918_REG
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; tmsSendData: Send # bytes from .sourceAddr to tms9918 data port
   175                          ; -----------------------------------------------------------------------------
   176                          !macro tmsSendData .sourceAddr, .numBytes {
   177                                  lda #<.sourceAddr
   178                                  sta TMS_TMP_ADDRESS
   179                                  lda #>.sourceAddr
   180                                  sta TMS_TMP_ADDRESS + 1
   181                          
   182                                  !if .numBytes < 256 {
   183                                          ldx #.numBytes
   184                                          jsr tmsSendBytes
   185                                  } else {
   186                                          !do while .numBytes > 0 {
   187                                                  !if .numBytes > 255 {
   188                                                          ldx #0
   189                                                          !set .numBytes = .numBytes - 256
   190                                                  } else {
   191                                                          ldx #.numBytes
   192                                                          !set .numBytes = 0
   193                                                  }
   194                                                  jsr tmsSendBytes
   195                                                  inc TMS_TMP_ADDRESS + 1
   196                                          }
   197                                  }
   198                          
   199                          }
   200                          
   201                          ; -----------------------------------------------------------------------------
   202                          ; tmsSendDataRpt: Send # bytes from .sourceAddr to tms9918 data port .rpt times
   203                          ; -----------------------------------------------------------------------------
   204                          !macro tmsSendDataRpt .sourceAddr, .numBytes, .rpt {
   205                                  lda #<.sourceAddr
   206                                  sta TMS_TMP_ADDRESS
   207                                  lda #>.sourceAddr
   208                                  sta TMS_TMP_ADDRESS + 1
   209                          
   210                                  !if .numBytes < 256 {
   211                                          !if .rpt < 5 {
   212                                                  !for i,1,.rpt {
   213                                                          ldx #.numBytes
   214                                                          jsr tmsSendBytes
   215                                                  }
   216                                          } else {
   217                                                  lda #.rpt
   218                                                  sta TMS9918_TMP_BUFFER
   219                          -
   220                                                  ldx #.numBytes
   221                                                  jsr tmsSendBytes
   222                                                  dec TMS9918_TMP_BUFFER
   223                                                  bne -
   224                                          }
   225                                  } else {
   226                                          !error "tmsSendDataRpt supports <256 bytes only"
   227                                  }
   228                          }
   229                          
   230                          
   231                          ; -----------------------------------------------------------------------------
   232                          ; tmsPutRpt: Send value .rpt times
   233                          ; -----------------------------------------------------------------------------
   234                          !macro tmsPutRpt .value, .rpt {
   235                                  ldx #.rpt
   236                                  lda #.value
   237                          -
   238                                  +tmsPut
   239                                  dex
   240                                  bne -
   241                          }
   242                          
   243                          !macro tmsPutSeq .from, .count {
   244                                  lda #.from
   245                          -
   246                                  +tmsPut
   247                                  inc
   248                                  cmp #<(.from + .count)
   249                                  bne -
   250                          }
   251                          
   252                          !macro tmsSetSourceAddressInd .addr {
   253                          	lda .addr
   254                          	sta TMS_TMP_ADDRESS
   255                          	lda .addr + 1
   256                          	sta TMS_TMP_ADDRESS + 1
   257                          }
   258                          
   259                          !macro tmsSetSourceAddressIndOffset .addr, .offset {
   260                                  clc
   261                          	lda .addr
   262                                  adc #<.offset
   263                          	sta TMS_TMP_ADDRESS
   264                          	lda .addr + 1
   265                                  adc #>.offset
   266                          	sta TMS_TMP_ADDRESS + 1
   267                          }
   268                          
   269                          
   270                          !macro tmsSendBytes .bytes {
   271                                  ldx #.bytes
   272                                  jsr tmsSendBytes
   273                          }
   274                          
   275                          
   276                          ; -----------------------------------------------------------------------------
   277                          ; tmsSetAddrPattTable: Initialise address for font table
   278                          ; -----------------------------------------------------------------------------
   279                          !macro tmsSetAddrPattTable {
   280                                  +tmsSetAddrPattTable 0
   281                          }
   282                          
   283                          ; -----------------------------------------------------------------------------
   284                          ; tmsSetAddrPattTable: Initialise address for pattern table
   285                          ; -----------------------------------------------------------------------------
   286                          !macro tmsSetAddrPattTable .ind {
   287                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   288                          }
   289                          
   290                          ; -----------------------------------------------------------------------------
   291                          ; tmsSetAddrPattTable: Initialise address for pattern table
   292                          ; -----------------------------------------------------------------------------
   293                          !macro tmsSetAddrPattTable .ind, .row {
   294                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   295                          }
   296                          
   297                          ; -----------------------------------------------------------------------------
   298                          ; tmsSetAddrPattTableIIBank0: Initialise address for pattern table
   299                          ; -----------------------------------------------------------------------------
   300                          !macro tmsSetAddrPattTableIIBank0 .ind {
   301                                  +tmsSetAddrPattTable .ind
   302                          }
   303                          
   304                          ; -----------------------------------------------------------------------------
   305                          ; tmsSetAddrPattTableIIBank1: Initialise address for pattern table
   306                          ; -----------------------------------------------------------------------------
   307                          !macro tmsSetAddrPattTableIIBank1 .ind {
   308                                  +tmsSetAddrPattTable 256 + .ind
   309                          }
   310                          
   311                          ; -----------------------------------------------------------------------------
   312                          ; tmsSetAddrPattTableIIBank2: Initialise address for pattern table
   313                          ; -----------------------------------------------------------------------------
   314                          !macro tmsSetAddrPattTableIIBank2 .ind {
   315                                  +tmsSetAddrPattTable 512 + .ind
   316                          }
   317                          
   318                          ; -----------------------------------------------------------------------------
   319                          ; tmsSetAddrPattTableRead: Initialise address for pattern table to read
   320                          ; -----------------------------------------------------------------------------
   321                          !macro tmsSetAddrPattTableRead .ind {
   322                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   323                          }
   324                          
   325                          ; -----------------------------------------------------------------------------
   326                          ; tmsSetAddrPattTableRowRead: Initialise address for pattern table to read
   327                          ; -----------------------------------------------------------------------------
   328                          !macro tmsSetAddrPattTableRead .ind, .row {
   329                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   330                          }
   331                          
   332                          ; -----------------------------------------------------------------------------
   333                          ; tmsUpdateFont: Update the pattern table with a given font
   334                          ; -----------------------------------------------------------------------------
   335                          !macro tmsUpdateFont .fontAddr {
   336                                  +tmsSetAddrPattTable 32
   337                                  +tmsSendData .fontAddr, $300
   338                          }
   339                          
   340                          ; -----------------------------------------------------------------------------
   341                          ; tmsSetAddrNameTable: Initialise address for base (text) table
   342                          ; -----------------------------------------------------------------------------
   343                          !macro tmsSetAddrNameTable {
   344                                  +tmsSetAddressWrite TMS_VRAM_NAME_ADDRESS
   345                          }
   346                          
   347                          ; -----------------------------------------------------------------------------
   348                          ; tmsSetAddrColorTable: Initialise address for color table
   349                          ; -----------------------------------------------------------------------------
   350                          !macro tmsSetAddrColorTable {
   351                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS
   352                          }
   353                          
   354                          ; -----------------------------------------------------------------------------
   355                          ; tmsSetAddrColorTable: Initialise address for color table index
   356                          ; -----------------------------------------------------------------------------
   357                          !macro tmsSetAddrColorTable .ind {
   358                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind
   359                          }
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; tmsSetAddrColorTableII: Initialise address for color table index (mode II)
   363                          ; -----------------------------------------------------------------------------
   364                          !macro tmsSetAddrColorTableII .ind {
   365                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind * 8
   366                          }
   367                          
   368                          ; -----------------------------------------------------------------------------
   369                          ; tmsSetAddrColorTableIIBank0: Initialise address for color table index (mode II)
   370                          ; -----------------------------------------------------------------------------
   371                          !macro tmsSetAddrColorTableIIBank0 .ind {
   372                                  +tmsSetAddrColorTableII .ind
   373                          }
   374                          
   375                          ; -----------------------------------------------------------------------------
   376                          ; tmsSetAddrColorTableIIBank1: Initialise address for color table index (mode II)
   377                          ; -----------------------------------------------------------------------------
   378                          !macro tmsSetAddrColorTableIIBank1 .ind {
   379                                  +tmsSetAddrColorTableII 256 + .ind
   380                          }
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; tmsSetAddrColorTableIIBank2: Initialise address for color table index (mode II)
   384                          ; -----------------------------------------------------------------------------
   385                          !macro tmsSetAddrColorTableIIBank2 .ind {
   386                                  +tmsSetAddrColorTableII 512 + .ind
   387                          }
   388                          
   389                          ; -----------------------------------------------------------------------------
   390                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   391                          ; -----------------------------------------------------------------------------
   392                          !macro tmsSetAddrSpriteAttrTable {
   393                                  +tmsSetAddrSpriteAttrTable 0
   394                          }
   395                          
   396                          ; -----------------------------------------------------------------------------
   397                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   398                          ; -----------------------------------------------------------------------------
   399                          !macro tmsSetAddrSpriteAttrTable .index {
   400                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + .index * 4
   401                          }
   402                          
   403                          ; -----------------------------------------------------------------------------
   404                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   405                          ; -----------------------------------------------------------------------------
   406                          !macro tmsSetAddrSpritePattTable {
   407                                  +tmsSetAddrSpritePattTable 0
   408                          }
   409                          
   410                          ; -----------------------------------------------------------------------------
   411                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   412                          ; -----------------------------------------------------------------------------
   413                          !macro tmsSetAddrSpritePattTable .index {
   414                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_PATT_ADDRESS + .index * 8
   415                          }
   416                          
   417                          
   418                          ; -----------------------------------------------------------------------------
   419                          ; tmsCreateSpritePattern: Create a sprite pattern (.spriteDataAddr is 8 bytes)
   420                          ; -----------------------------------------------------------------------------
   421                          !macro tmsCreateSpritePattern .pattInd, .spriteDataAddr {
   422                          
   423                                  
   424                          
   425                                  ; sprite pattern table
   426                                  +tmsSetAddrSpritePattTable .pattInd
   427                          
   428                                  ldx #0
   429                          -
   430                                  lda .spriteDataAddr,x
   431                                  +tmsPut
   432                                  inx
   433                                  cpx #8
   434                          
   435                                  
   436                          
   437                                  bne -
   438                          }
   439                          
   440                          ; -----------------------------------------------------------------------------
   441                          ; tmsCreateSpritePatternQuad: Create a (size 1) sprite pattern 
   442                          ;   (.spriteDataAddr is 32 bytes)
   443                          ; -----------------------------------------------------------------------------
   444                          !macro tmsCreateSpritePatternQuad .pattInd, .spriteDataAddr {
   445                          
   446                                  
   447                          
   448                                  ; sprite pattern table
   449                                  +tmsSetAddrSpritePattTable .pattInd * 4
   450                          
   451                                  ldx #0
   452                          -
   453                                  lda .spriteDataAddr,x
   454                                  +tmsPut 
   455                                  inx
   456                                  cpx #32
   457                          
   458                                  
   459                          
   460                                  bne -
   461                          }
   462                          
   463                          
   464                          !macro tmsCreateSpritePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   465                          
   466                                  ; sprite pattern table
   467                                  +tmsSetAddrSpritePattTable .ind
   468                                  +tmsPut .b0
   469                                  +tmsPut .b2
   470                                  +tmsPut .b2
   471                                  +tmsPut .b3
   472                                  +tmsPut .b4
   473                                  +tmsPut .b5
   474                                  +tmsPut .b6
   475                                  +tmsPut .b7
   476                          }
   477                          
   478                          !macro tmsCreatePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   479                          
   480                                  ; sprite pattern table
   481                                  +tmsSetAddrPattTable .ind
   482                                  +tmsPut .b0
   483                                  +tmsPut .b2
   484                                  +tmsPut .b2
   485                                  +tmsPut .b3
   486                                  +tmsPut .b4
   487                                  +tmsPut .b5
   488                                  +tmsPut .b6
   489                                  +tmsPut .b7
   490                          }
   491                          
   492                          
   493                          ; -----------------------------------------------------------------------------
   494                          ; tmsCreateSprite: Create a sprite
   495                          ; -----------------------------------------------------------------------------
   496                          !macro tmsCreateSprite .ind, .pattInd, .xPos, .yPos, .color {
   497                          
   498                                  ; sprite attr table
   499                                  +tmsSetAddrSpriteAttrTable .ind
   500                          
   501                                  +tmsPut .yPos
   502                                  +tmsPut .xPos
   503                                  +tmsPut .pattInd
   504                                  +tmsPut .color
   505                          }
   506                          
   507                          ; -----------------------------------------------------------------------------
   508                          ; tmsSpritePos: Set a sprite position
   509                          ; -----------------------------------------------------------------------------
   510                          !macro tmsSpritePos .ind, .xPos, .yPos {
   511                                  
   512                          
   513                                  ; sprite attr table
   514                                  +tmsSetAddrSpriteAttrTable .ind
   515                          
   516                                  +tmsPut .yPos
   517                                  +tmsPut .xPos        
   518                          }
   519                          
   520                          
   521                          ; -----------------------------------------------------------------------------
   522                          ; tmsSetLastSprite: Mark a sprite as the last sprite (set next ypos to )
   523                          ; -----------------------------------------------------------------------------
   524                          !macro tmsSetLastSprite .ind {
   525                                  +tmsSpritePos .ind + 1, 0, $d0
   526                          }
   527                          
   528                          
   529                          ; -----------------------------------------------------------------------------
   530                          ; tmsSpritePosXYReg: Set a sprite position from x/y registers
   531                          ; -----------------------------------------------------------------------------
   532                          !macro tmsSpritePosXYReg .ind {
   533                                  
   534                          
   535                                  ; sprite attr table
   536                                  +tmsSetAddrSpriteAttrTable .ind
   537                          
   538                                  tya
   539                                  +tmsPut 
   540                                  txa
   541                                  +tmsPut 
   542                          }
   543                          
   544                          
   545                          ; -----------------------------------------------------------------------------
   546                          ; tmsSetAddrSpriteColor: Change a sprite color
   547                          ; -----------------------------------------------------------------------------
   548                          !macro tmsSetAddrSpriteColor .ind {
   549                          
   550                                  ; sprite attr table
   551                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + (.ind * 4) + 3
   552                          }
   553                          ; -----------------------------------------------------------------------------
   554                          ; tmsSpriteColor: Change a sprite color
   555                          ; -----------------------------------------------------------------------------
   556                          !macro tmsSpriteColor .ind, .color {
   557                          
   558                                  +tmsSetAddrSpriteColor .ind
   559                          
   560                                  +tmsPut .color
   561                          }
   562                          
   563                          
   564                          ; -----------------------------------------------------------------------------
   565                          ; tmsSetPosWrite: Set cursor position
   566                          ; -----------------------------------------------------------------------------
   567                          !macro tmsSetPosWrite .x, .y {
   568                                  +tmsSetAddressWrite (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   569                          }
   570                          
   571                          ; -----------------------------------------------------------------------------
   572                          ; tmsSetPosRead: Set read cursor position
   573                          ; -----------------------------------------------------------------------------
   574                          !macro tmsSetPosRead .x, .y {
   575                                  +tmsSetAddressRead (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   576                          }
   577                          
   578                          ; -----------------------------------------------------------------------------
   579                          ; tmsPrint: Print immediate text
   580                          ; -----------------------------------------------------------------------------
   581                          ; Inputs:
   582                          ;  str: String to print
   583                          ;  x: x position
   584                          ;  y: y position
   585                          ; -----------------------------------------------------------------------------
   586                          !macro tmsPrint .str, .x, .y {
   587                          	jmp .afterText
   588                          .textAddr
   589                          	!text .str,0
   590                          .afterText        
   591                          
   592                                  +tmsSetPosWrite .x, .y
   593                          
   594                                  lda #<.textAddr
   595                                  sta STR_ADDR_L
   596                                  lda #>.textAddr
   597                                  sta STR_ADDR_H
   598                                  jsr tmsPrint        
   599                          }
   600                          
   601                          
   602                          ; -----------------------------------------------------------------------------
   603                          ; tmsPrintCentre: Print centre-aligned immediate text
   604                          ; -----------------------------------------------------------------------------
   605                          ; Inputs:
   606                          ;  str: String to print
   607                          ;  y: y position
   608                          ; -----------------------------------------------------------------------------
   609                          !macro tmsPrintCentre .str, .y {
   610                          	jmp .afterText
   611                          .textAddr
   612                          	!text .str,0
   613                          .afterText        
   614                          
   615                                  +tmsSetPosWrite (32 - ((.afterText - 1) - .textAddr)) / 2, .y
   616                          
   617                                  lda #<.textAddr
   618                                  sta STR_ADDR_L
   619                                  lda #>.textAddr
   620                                  sta STR_ADDR_H
   621                                  jsr tmsPrint        
   622                          }
   623                          
   624                          
   625                          ; -----------------------------------------------------------------------------
   626                          ; tmsPrintZ: Print text
   627                          ; -----------------------------------------------------------------------------
   628                          ; Inputs:
   629                          ;  str: Address of zero-terminated string to print
   630                          ;  x: x position
   631                          ;  y: y position
   632                          ; -----------------------------------------------------------------------------
   633                          !macro tmsPrintZ .textAddr, .x, .y {
   634                                  +tmsSetPosWrite .x, .y
   635                          
   636                                  lda #<.textAddr
   637                                  sta STR_ADDR_L
   638                                  lda #>.textAddr
   639                                  sta STR_ADDR_H
   640                                  jsr tmsPrint        
   641                          }

; ******** Source: ../kernel\hbc56kernel.inc
    19                          

; ******** Source: ../lib\gfx\tilemap.inc
     1                          ; 6502 - Tilemap
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          
    12                          
    13                          !macro tilemapCreate .tilemapStructAddr, .bufferAddr, .tilesetAddr, .sizeFlags, .tileSizePx, .invertAddr, .dirtyAddr {
    14                          	!if <.tilesetAddr != 0 { !error "tilemapCreate: Tileset address must be page-aligned",.tilesetAddr }
    15                          	!if >.tilesetAddr < 3 { !error "tilemapCreate: Tileset address must be greater than $2ff",.tilesetAddr }
    16                          	!if <.bufferAddr != 0 { !error "tilemapCreate: Buffer address must be page-aligned",.bufferAddr }
    17                          	!if >.bufferAddr < 3 { !error "tilemapCreate: Buffer address must be greater than $2ff",.bufferAddr }
    18                          	!if .invertAddr != 0 and <.invertAddr != 0  {!error "tilemapCreate: Invert address must be page-aligned", .invertAddr}
    19                          	!if .invertAddr != 0 and >.invertAddr < 3  {!error "tilemapCreate: Invert address must be greater than $2ff", .invertAddr}
    20                          	!if .dirtyAddr != 0 and <.dirtyAddr != 0  {!error "tilemapCreate: Dirty address must be page-aligned", .dirtyAddr}
    21                          	!if .dirtyAddr != 0 and >.dirtyAddr < 3  {!error "tilemapCreate: Dirty address must be greater than $2ff", .dirtyAddr}
    22                          	!if .tileSizePx != 4 and .tileSizePx != 8 {!error "tilemapCreate: Tile size must be 4 or 8 pixels",.tileSizePx}
    23                          
    24                          	lda #<.tilemapStructAddr
    25                          	sta TILEMAP_ADDR
    26                          	lda #>.tilemapStructAddr
    27                          	sta TILEMAP_ADDR + 1
    28                          
    29                          	lda #>.bufferAddr
    30                          	sta .tilemapStructAddr + TILEMAP_BUFFER_ADDR
    31                          	lda #.sizeFlags
    32                          	sta .tilemapStructAddr + TILEMAP_SIZE
    33                          	lda #>.tilesetAddr
    34                          	sta .tilemapStructAddr + TILEMAP_TILES_ADDR
    35                          	lda #>.invertAddr
    36                          	sta .tilemapStructAddr + TILEMAP_INVERT_ADDR
    37                          	lda #>.dirtyAddr
    38                          	sta .tilemapStructAddr + TILEMAP_DIRTY_ADDR
    39                          	lda #.tileSizePx
    40                          	sta .tilemapStructAddr + TILEMAP_TILE_SIZE_PX
    41                          
    42                          	jsr tilemapInit
    43                          }
    44                          
    45                          !macro tilemapCreateDefault .sizeFlags, .tilesetAddr {
    46                          	+tilemapCreate TILEMAP_FIXED_ADDRESS, TILEMAP_DEFAULT_BUFFER_ADDRESS, .tilesetAddr, .sizeFlags, 8, $0, $0
    47                          }
    48                          
    49                          !macro tilemapSetActive .tilemapStructAddr {
    50                          	lda #<.tilemapStructAddr
    51                          	sta TILEMAP_ADDR
    52                          	lda #>.tilemapStructAddr
    53                          	sta TILEMAP_ADDR + 1
    54                          
    55                          	jsr tilemapSetActive

; ******** Source: ../kernel\hbc56kernel.inc
    20                          

; ******** Source: ../lib\lcd\lcd.inc
     1                          ; 6502 LCD Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          ; -----------------------------------------------------------------------------
    11                          ; lcdPrint: Print immediate text
    12                          ; -----------------------------------------------------------------------------
    13                          ; Inputs:
    14                          ;  str: String to print
    15                          ; -----------------------------------------------------------------------------
    16                          !macro lcdPrint str {
    17                          	jmp +
    18                          .textAddr
    19                          	!text str,0
    20                          +
    21                          	lda #<.textAddr
    22                          	sta STR_ADDR_L
    23                          	lda #>.textAddr
    24                          	sta STR_ADDR_H
    25                          	jsr lcdPrint
    26                          }
    27                          
    28                          
    29                          ; -----------------------------------------------------------------------------
    30                          ; lcdChar: Print immediate character
    31                          ; -----------------------------------------------------------------------------
    32                          ; Inputs:
    33                          ;  c: Character to print
    34                          ; -----------------------------------------------------------------------------
    35                          !macro lcdChar c {
    36                          	pha
    37                          	lda #c
    38                          	jsr lcdChar
    39                          	pla
    40                          }
    41                          
    42                          
    43                          ; -----------------------------------------------------------------------------
    44                          ; lcdConsolePrint: Print immediate text to console
    45                          ; -----------------------------------------------------------------------------
    46                          ; Inputs:
    47                          ;  str: String to print
    48                          ; -----------------------------------------------------------------------------
    49                          !macro lcdConsolePrint .str {
    50                          	jmp .afterText
    51                          .textAddr
    52                          	!text .str,0
    53                          .afterText        
    54                          
    55                                  lda #<.textAddr
    56                                  sta STR_ADDR_L
    57                                  lda #>.textAddr
    58                                  sta STR_ADDR_H
    59                                  jsr lcdConsolePrint        

; ******** Source: ../kernel\hbc56kernel.inc
    21                          

; ******** Source: ../lib\inp\nes.inc
     1                          ; 6502 NES Controller Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ; Dependencies:
    10                          ;  - hbc56.asm
    11                          
    12                          
    13                          !macro nes1BranchIfPressed .buttonMask, .addr {
    14                                  pha
    15                                  lda #(.buttonMask)
    16                                  jsr nes1Pressed
    17                                  pla
    18                                  bcs .addr
    19                          }
    20                          
    21                          !macro nes1BranchIfNotPressed .buttonMask, .addr {
    22                                  pha
    23                                  lda #(.buttonMask)
    24                                  jsr nes1Pressed
    25                                  pla
    26                                  bcc .addr
    27                          }
    28                          
    29                          !macro nes2BranchIfPressed .buttonMask, addr {
    30                                  pha
    31                                  lda #(.buttonMask)
    32                                  jsr nes2Pressed
    33                                  pla
    34                                  bcs addr
    35                          }
    36                          
    37                          !macro nes2BranchIfNotPressed .buttonMask, addr {
    38                                  pha
    39                                  lda #(.buttonMask)
    40                                  jsr nes2Pressed
    41                                  pla
    42                                  bcc addr
    43                          }

; ******** Source: ../kernel\hbc56kernel.inc
    22                          

; ******** Source: ../lib\inp\keyboard.inc
     1                          ; 6502 KB Controller Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ; Dependencies:
    10                          ;  - hbc56.asm
    11                          
    12                          
    13                          !macro kbBranchIfNotPressed .scancode, .addr {
    14                                  ldx #.scancode
    15                                  jsr kbReadAscii
    16                                  beq .addr
    17                          }
    18                          
    19                          !macro kbBranchIfPressed .scancode, .addr {
    20                                  ldx #.scancode
    21                                  jsr kbIsPressed
    22                                  bne .addr
    23                          }
    24                          
    25                          !macro kbSetEventHandlerPressed .cb {
    26                                  lda #<.cb
    27                                  sta KB_CB_PRESSED
    28                                  lda #>.cb
    29                                  sta KB_CB_PRESSED + 1
    30                          }
    31                          
    32                          !macro kbSetEventHandlerReleased .cb {
    33                                  lda #<.cb
    34                                  sta KB_CB_RELEASED
    35                                  lda #>.cb
    36                                  sta KB_CB_RELEASED + 1

; ******** Source: ../kernel\hbc56kernel.inc
    23                          

; ******** Source: ../lib\sfx\ay3891x.inc
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          !macro ayWrite .dev, .reg, .val {
    13                                  lda #.reg
    14                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    15                                  lda #.val
    16                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    17                          }        
    18                          
    19                          !macro ayRead .dev, .reg {
    20                                  lda #.reg
    21                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    22                                  lda IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_READ | .dev
    23                          }        
    24                          
    25                          
    26                          !macro ayWriteX .dev, .reg {
    27                                  lda #.reg
    28                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    29                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    30                          }
    31                          
    32                          !macro ayWriteA .dev, .reg {
    33                                  ldx #.reg
    34                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    35                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    36                          }
    37                          
    38                          !macro ayPlayNote .dev, .chan, .freq {
    39                                  !if .freq <= 0 {
    40                                          .val = 0
    41                                  } else {
    42                                          .val = AY_CLOCK_FREQ / (32.0 * .freq)
    43                                  }
    44                                  +ayWrite .dev, AY_CHA_TONE_L + (.chan * 2), <.val
    45                                  +ayWrite .dev, AY_CHA_TONE_H + (.chan * 2), >.val
    46                          }
    47                          
    48                          !macro ayToneWord .freq {
    49                                  !word (AY_CLOCK_FREQ / (32.0 * .freq))
    50                          }
    51                          
    52                          !macro ayToneByteL .freq {
    53                                  !byte <(AY_CLOCK_FREQ / (32.0 * .freq))
    54                          }
    55                          
    56                          !macro ayToneByteH .freq {
    57                                  !byte >(AY_CLOCK_FREQ / (32.0 * .freq))
    58                          }
    59                          
    60                          
    61                          !macro ayToneEnable .dev, .chan {
    62                                  +ayRead .dev, AY_ENABLES
    63                                  and #!($01 << .chan)
    64                                  +ayWriteA .dev, AY_ENABLES
    65                          }
    66                          
    67                          !macro ayToneDisable .dev, .chan {
    68                                  +ayRead .dev, AY_ENABLES
    69                                  ora #($01 << .chan)
    70                                  +ayWriteA .dev, AY_ENABLES
    71                          }
    72                          
    73                          !macro ayNoiseEnable .dev, .chan {
    74                                  +ayRead .dev, AY_ENABLES
    75                                  eor #($08 << .chan)
    76                                  +ayWriteA .dev, AY_ENABLES
    77                          }
    78                          
    79                          !macro ayNoiseDisable .dev, .chan {
    80                                  +ayRead .dev, AY_ENABLES
    81                                  ora #($08 << .chan)
    82                                  +ayWriteA .dev, AY_ENABLES
    83                          }
    84                          
    85                          !macro aySetVolume .dev, .chan, .vol {
    86                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), (.vol >> 4)
    87                          }
    88                          
    89                          !macro aySetVolumeEnvelope .dev, .chan {
    90                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), $10
    91                          }
    92                          
    93                          !macro aySetEnvelopePeriod .dev, .period {
    94                                  +ayWrite .dev, AY_ENV_PERIOD_L, <.period
    95                                  +ayWrite .dev, AY_ENV_PERIOD_H, >.period
    96                          }
    97                          
    98                          !macro aySetEnvShape .dev, .shape {
    99                                  +ayWrite .dev, AY_ENV_SHAPE, .shape
   100                          }
   101                          
   102                          !macro aySetNoise .dev, .freq {
   103                                  +ayWrite .dev, AY_ENV_SHAPE, .freq >> 3
   104                          }
   105                          
   106                          !macro ayStop .dev, .chan {
   107                                  +ayPlayNote .dev, .chan, 0
   108                          }

; ******** Source: ../kernel\hbc56kernel.inc
    24                          

; ******** Source: ../lib\ser\uart.inc
     1                          ; 6502 - MC68B50 UART Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          ; -----------------------------------------------------------------------------
    11                          ; uartOutStringAddr: Output a string to the uart
    12                          ; -----------------------------------------------------------------------------
    13                          ; Inputs:
    14                          ;  .addr: Address of null-terminated string to print
    15                          ; -----------------------------------------------------------------------------
    16                          !macro uartOutStringAddr .addr {
    17                                  lda #<.addr
    18                                  sta STR_ADDR_L
    19                                  lda #>.addr
    20                                  sta STR_ADDR_H
    21                                  jsr uartOutString        
    22                          }
    23                          
    24                          
    25                          ; -----------------------------------------------------------------------------
    26                          ; uartOutString: Output an immediate string to the uart
    27                          ; -----------------------------------------------------------------------------
    28                          ; Inputs:
    29                          ;  .str: String to output
    30                          ; -----------------------------------------------------------------------------
    31                          !macro uartOutString .str {
    32                          	jmp @afterText
    33                          @textAddr
    34                          	!text .str,0
    35                          @afterText        
    36                                  +uartOutStringAddr @textAddr
    37                          }
    38                          

; ******** Source: ../kernel\hbc56kernel.inc
    25                          

; ******** Source: ../kernel\kernel.inc
     1                          ; 6502 - HBC-56 Kernel Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !macro setIntHandler .address {
    12                                  lda #<.address
    13                                  sta HBC56_INT_VECTOR + 1
    14                                  lda #>.address
    15                                  sta HBC56_INT_VECTOR + 2
    16                                  lda #JMP_OPCODE
    17                                  sta HBC56_INT_VECTOR
    18                          }
    19                          
    20                          !macro setNmiHandler .address {
    21                                  lda #<.address
    22                                  sta HBC56_NMI_VECTOR + 1
    23                                  lda #>.address
    24                                  sta HBC56_NMI_VECTOR + 2
    25                                  lda #JMP_OPCODE
    26                                  sta HBC56_NMI_VECTOR
    27                          }
    28                          
    29                          !macro setHbcMetaNES {
    30                                  lda #HBC56_CONSOLE_FLAG_NES
    31                                  ora HBC56_CONSOLE_FLAGS
    32                                  sta HBC56_CONSOLE_FLAGS
    33                          }
    34                          
    35                          !macro setHbcMetaNoWait {
    36                                  lda #HBC56_CONSOLE_FLAG_NOWAIT
    37                                  ora HBC56_CONSOLE_FLAGS
    38                                  sta HBC56_CONSOLE_FLAGS
    39                          }
    40                          
    41                          
    42                          !macro hbc56SetVsyncCallback .vsync {
    43                                  lda #<.vsync
    44                                  sta HBC56_VSYNC_CALLBACK
    45                                  lda #>.vsync
    46                                  sta HBC56_VSYNC_CALLBACK + 1
    47                          }
    48                          
    49                          !macro hbc56SetViaCallback .cb {
    50                                  lda #<.cb
    51                                  sta HBC56_VIA_CALLBACK
    52                                  lda #>.cb
    53                                  sta HBC56_VIA_CALLBACK + 1
    54                          }
    55                          
    56                          
    57                          !macro setHbcMetaTitle .titleStr {
    58                                  jmp .hbcMetaTitleOut
    59                          .titleStrLabel:
    60                                  !text .titleStr
    61                          .titleStrLabelLen = * - .titleStrLabel
    62                                  !byte 0 ; nul terminator for game name
    63                          
    64                          !if .titleStrLabelLen > HBC56_META_TITLE_MAX_LEN {
    65                                  !error "setHbcMetaTitle: Title metadata limited to ",HBC56_META_TITLE_MAX_LEN,"bytes"
    66                          }
    67                          .hbcMetaTitleOut:
    68                                  +memcpy HBC56_META_TITLE + (HBC56_META_TITLE_MAX_LEN-.titleStrLabelLen)/2, .titleStrLabel, .titleStrLabelLen
    69                                  lda #.titleStrLabelLen
    70                                  sta HBC56_META_TITLE_LEN
    71                          }
    72                          
    73                          !macro consoleEnableCursor {
    74                                  lda HBC56_CONSOLE_FLAGS
    75                                  ora #HBC56_CONSOLE_FLAG_CURSOR
    76                                  sta HBC56_CONSOLE_FLAGS
    77                          }
    78                          
    79                          !macro consoleDisableCursor {
    80                                  lda HBC56_CONSOLE_FLAGS
    81                                  and #!HBC56_CONSOLE_FLAG_CURSOR & $ff
    82                                  sta HBC56_CONSOLE_FLAGS
    83                          }
    84                          
    85                          !macro consoleLCDMode {
    86                                  lda HBC56_CONSOLE_FLAGS
    87                                  ora #HBC56_CONSOLE_FLAG_LCD
    88                                  sta HBC56_CONSOLE_FLAGS
    89                          }
    90                          
    91                          !macro setBreakpoint {
    92                                 !byte $db 
    93                          }
    94                          
    95                          !macro hbc56CustomDelay .delay {
    96                                  ldy #.delay
    97                                  jsr hbc56CustomDelay
    98                          }
    99                          
   100                          !macro hbc56DelayUs .us {
   101                          !if .us = 1 {
   102                                  nop
   103                                  nop
   104                          }
   105                          }
   106                          !macro hbc56DelayMs .ms {
   107                                  lda #<.ms
   108                                  sta DELAY_L
   109                                  lda #>.ms
   110                                  sta DELAY_H
   111                          
   112                                  jsr hbc56CustomDelayMs

; ******** Source: ../kernel\hbc56kernel.inc
    26                          
    27                          
    28                          !ifndef HBC_56_EXCLUDE_KERNEL_ROM {
    29                          
    30                                  ; if the program requires the kernal image
    31                                  ; then... include it
    32                          
    33                                  *=HBC56_META_VECTOR
    34                                  !ifdef hbc56Meta {
    35  dffc 4cacb8                             jmp hbc56Meta
    36                                  } else {
    37                                          rts
    38                                  }
    39                          
    40                                  *=HBC56_KERNEL_START
    41  e000 c9619005c97b9002...        !bin "kernel.o"
    42                          
    43                                  *=DEFAULT_HBC56_RST_VECTOR
    44  8000 4c3bb8                     jmp hbc56Main
    45                          
    46                          } else {
    47                          
    48                                  ; otherwise, place the program in RAM
    49                          
    50                                  *=$0400

; ******** Source: basic_hbc56_core.asm
    11                          

; ******** Source: ehbasic\basic.asm
     1                          
     2                          ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22
     3                          
     4                          ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
     5                          
     6                          ; 2.00	new revision numbers start here
     7                          ; 2.01	fixed LCASE$() and UCASE$()
     8                          ; 2.02	new get value routine done
     9                          ; 2.03	changed RND() to galoise method
    10                          ; 2.04	fixed SPC()
    11                          ; 2.05	new get value routine fixed
    12                          ; 2.06	changed USR() code
    13                          ; 2.07	fixed STR$()
    14                          ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
    15                          ; 2.09	fixed RND()
    16                          ; 2.10	integrated missed changes from an earlier version
    17                          ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    18                          ; 2.21	fixed IF .. THEN RETURN to not cause error
    19                          ; 2.22	fixed RND() breaking the get byte routine
    20                          
    21                          ; zero page use ..
    22                          
    23                          LAB_WARM 		= $00		; BASIC warm start entry point
    24                          Wrmjpl 		= LAB_WARM+1; BASIC warm start vector jump low byte
    25                          Wrmjph 		= LAB_WARM+2; BASIC warm start vector jump high byte
    26                          
    27                          Usrjmp		= $0A		; USR function JMP address
    28                          Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
    29                          Usrjph		= Usrjmp+2	; USR function JMP vector high byte
    30                          Nullct		= $0D		; nulls output after each line
    31                          TPos			= $0E		; BASIC terminal position byte
    32                          TWidth		= $0F		; BASIC terminal width byte
    33                          Iclim			= $10		; input column limit
    34                          Itempl		= $11		; temporary integer low byte
    35                          Itemph		= Itempl+1	; temporary integer high byte
    36                          
    37                          nums_1		= Itempl	; number to bin/hex string convert MSB
    38                          nums_2		= nums_1+1	; number to bin/hex string convert
    39                          nums_3		= nums_1+2	; number to bin/hex string convert LSB
    40                          
    41                          Srchc			= $5B		; search character
    42                          Temp3			= Srchc	; temp byte used in number routines
    43                          Scnquo		= $5C		; scan-between-quotes flag
    44                          Asrch			= Scnquo	; alt search character
    45                          
    46                          XOAw_l		= Srchc	; eXclusive OR, OR and AND word low byte
    47                          XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
    48                          
    49                          Ibptr			= $5D		; input buffer pointer
    50                          Dimcnt		= Ibptr	; # of dimensions
    51                          Tindx			= Ibptr	; token index
    52                          
    53                          Defdim		= $5E		; default DIM flag
    54                          Dtypef		= $5F		; data type flag, $FF=string, $00=numeric
    55                          Oquote		= $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
    56                          Gclctd		= $60		; garbage collected flag
    57                          Sufnxf		= $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    58                          Imode			= $62		; input mode flag, $00=INPUT, $80=READ
    59                          
    60                          Cflag			= $63		; comparison evaluation flag
    61                          
    62                          TabSiz		= $64		; TAB step size (was input flag)
    63                          
    64                          next_s		= $65		; next descriptor stack address
    65                          
    66                          					; these two bytes form a word pointer to the item
    67                          					; currently on top of the descriptor stack
    68                          last_sl		= $66		; last descriptor stack address low byte
    69                          last_sh		= $67		; last descriptor stack address high byte (always $00)
    70                          
    71                          des_sk		= $68		; descriptor stack start address (temp strings)
    72                          
    73                          ;			= $70		; End of descriptor stack
    74                          
    75                          ut1_pl		= $71		; utility pointer 1 low byte
    76                          ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
    77                          ut2_pl		= $73		; utility pointer 2 low byte
    78                          ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
    79                          
    80                          Temp_2		= ut1_pl	; temp byte for block move	
    81                          
    82                          FACt_1		= $75		; FAC temp mantissa1
    83                          FACt_2		= FACt_1+1	; FAC temp mantissa2
    84                          FACt_3		= FACt_2+1	; FAC temp mantissa3
    85                          
    86                          dims_l		= FACt_2	; array dimension size low byte
    87                          dims_h		= FACt_3	; array dimension size high byte
    88                          
    89                          TempB			= $78		; temp page 0 byte
    90                          
    91                          Smeml			= $79		; start of mem low byte		(Start-of-Basic)
    92                          Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
    93                          Svarl			= $7B		; start of vars low byte	(Start-of-Variables)
    94                          Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
    95                          Sarryl		= $7D		; var mem end low byte		(Start-of-Arrays)
    96                          Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
    97                          Earryl		= $7F		; array mem end low byte	(End-of-Arrays)
    98                          Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
    99                          Sstorl		= $81		; string storage low byte	(String storage (moving down))
   100                          Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
   101                          Sutill		= $83		; string utility ptr low byte
   102                          Sutilh		= Sutill+1	; string utility ptr high byte
   103                          Ememl			= $85		; end of mem low byte		(Limit-of-memory)
   104                          Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
   105                          Clinel		= $87		; current line low byte		(Basic line number)
   106                          Clineh		= Clinel+1	; current line high byte	(Basic line number)
   107                          Blinel		= $89		; break line low byte		(Previous Basic line number)
   108                          Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
   109                          
   110                          Cpntrl		= $8B		; continue pointer low byte
   111                          Cpntrh		= Cpntrl+1	; continue pointer high byte
   112                          
   113                          Dlinel		= $8D		; current DATA line low byte
   114                          Dlineh		= Dlinel+1	; current DATA line high byte
   115                          
   116                          Dptrl			= $8F		; DATA pointer low byte
   117                          Dptrh			= Dptrl+1	; DATA pointer high byte
   118                          
   119                          Rdptrl		= $91		; read pointer low byte
   120                          Rdptrh		= Rdptrl+1	; read pointer high byte
   121                          
   122                          Varnm1		= $93		; current var name 1st byte
   123                          Varnm2		= Varnm1+1	; current var name 2nd byte
   124                          
   125                          Cvaral		= $95		; current var address low byte
   126                          Cvarah		= Cvaral+1	; current var address high byte
   127                          
   128                          Frnxtl		= $97		; var pointer for FOR/NEXT low byte
   129                          Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
   130                          
   131                          Tidx1			= Frnxtl	; temp line index
   132                          
   133                          Lvarpl		= Frnxtl	; let var pointer low byte
   134                          Lvarph		= Frnxth	; let var pointer high byte
   135                          
   136                          prstk			= $99		; precedence stacked flag
   137                          
   138                          comp_f		= $9B		; compare function flag, bits 0,1 and 2 used
   139                          					; bit 2 set if >
   140                          					; bit 1 set if =
   141                          					; bit 0 set if <
   142                          
   143                          func_l		= $9C		; function pointer low byte
   144                          func_h		= func_l+1	; function pointer high byte
   145                          
   146                          garb_l		= func_l	; garbage collection working pointer low byte
   147                          garb_h		= func_h	; garbage collection working pointer high byte
   148                          
   149                          des_2l		= $9E		; string descriptor_2 pointer low byte
   150                          des_2h		= des_2l+1	; string descriptor_2 pointer high byte
   151                          
   152                          g_step		= $A0		; garbage collect step size
   153                          
   154                          Fnxjmp		= $A1		; jump vector for functions
   155                          Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
   156                          Fnxjph		= Fnxjmp+2	; functions jump vector high byte
   157                          
   158                          g_indx		= Fnxjpl	; garbage collect temp index
   159                          
   160                          FAC2_r		= $A3		; FAC2 rounding byte
   161                          
   162                          Adatal		= $A4		; array data pointer low byte
   163                          Adatah		= Adatal+1	; array data pointer high  byte
   164                          
   165                          Nbendl		= Adatal	; new block end pointer low byte
   166                          Nbendh		= Adatah	; new block end pointer high  byte
   167                          
   168                          Obendl		= $A6		; old block end pointer low byte
   169                          Obendh		= Obendl+1	; old block end pointer high  byte
   170                          
   171                          numexp		= $A8		; string to float number exponent count
   172                          expcnt		= $A9		; string to float exponent count
   173                          
   174                          numbit		= numexp	; bit count for array element calculations
   175                          
   176                          numdpf		= $AA		; string to float decimal point flag
   177                          expneg		= $AB		; string to float eval exponent -ve flag
   178                          
   179                          Astrtl		= numdpf	; array start pointer low byte
   180                          Astrth		= expneg	; array start pointer high  byte
   181                          
   182                          Histrl		= numdpf	; highest string low byte
   183                          Histrh		= expneg	; highest string high  byte
   184                          
   185                          Baslnl		= numdpf	; BASIC search line pointer low byte
   186                          Baslnh		= expneg	; BASIC search line pointer high  byte
   187                          
   188                          Fvar_l		= numdpf	; find/found variable pointer low byte
   189                          Fvar_h		= expneg	; find/found variable pointer high  byte
   190                          
   191                          Ostrtl		= numdpf	; old block start pointer low byte
   192                          Ostrth		= expneg	; old block start pointer high  byte
   193                          
   194                          Vrschl		= numdpf	; variable search pointer low byte
   195                          Vrschh		= expneg	; variable search pointer high  byte
   196                          
   197                          FAC1_e		= $AC		; FAC1 exponent
   198                          FAC1_1		= FAC1_e+1	; FAC1 mantissa1
   199                          FAC1_2		= FAC1_e+2	; FAC1 mantissa2
   200                          FAC1_3		= FAC1_e+3	; FAC1 mantissa3
   201                          FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
   202                          
   203                          str_ln		= FAC1_e	; string length
   204                          str_pl		= FAC1_1	; string pointer low byte
   205                          str_ph		= FAC1_2	; string pointer high byte
   206                          
   207                          des_pl		= FAC1_2	; string descriptor pointer low byte
   208                          des_ph		= FAC1_3	; string descriptor pointer high byte
   209                          
   210                          mids_l		= FAC1_3	; MID$ string temp length byte
   211                          
   212                          negnum		= $B1		; string to float eval -ve flag
   213                          numcon		= $B1		; series evaluation constant count
   214                          
   215                          FAC1_o		= $B2		; FAC1 overflow byte
   216                          
   217                          FAC2_e		= $B3		; FAC2 exponent
   218                          FAC2_1		= FAC2_e+1	; FAC2 mantissa1
   219                          FAC2_2		= FAC2_e+2	; FAC2 mantissa2
   220                          FAC2_3		= FAC2_e+3	; FAC2 mantissa3
   221                          FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
   222                          
   223                          FAC_sc		= $B8		; FAC sign comparison, Acc#1 vs #2
   224                          FAC1_r		= $B9		; FAC1 rounding byte
   225                          
   226                          ssptr_l		= FAC_sc	; string start pointer low byte
   227                          ssptr_h		= FAC1_r	; string start pointer high byte
   228                          
   229                          sdescr		= FAC_sc	; string descriptor pointer
   230                          
   231                          csidx			= $BA		; line crunch save index
   232                          Asptl			= csidx	; array size/pointer low byte
   233                          Aspth			= $BB		; array size/pointer high byte
   234                          
   235                          Btmpl			= Asptl	; BASIC pointer temp low byte
   236                          Btmph			= Aspth	; BASIC pointer temp low byte
   237                          
   238                          Cptrl			= Asptl	; BASIC pointer temp low byte
   239                          Cptrh			= Aspth	; BASIC pointer temp low byte
   240                          
   241                          Sendl			= Asptl	; BASIC pointer temp low byte
   242                          Sendh			= Aspth	; BASIC pointer temp low byte
   243                          
   244                          LAB_IGBY		= $BC		; get next BASIC byte subroutine
   245                          
   246                          LAB_GBYT		= $C2		; get current BASIC byte subroutine
   247                          Bpntrl		= $C3		; BASIC execute (get byte) pointer low byte
   248                          Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
   249                          
   250                          ;			= $D7		; end of get BASIC char subroutine
   251                          
   252                          Rbyte4		= $D8		; extra PRNG byte
   253                          Rbyte1		= Rbyte4+1	; most significant PRNG byte
   254                          Rbyte2		= Rbyte4+2	; middle PRNG byte
   255                          Rbyte3		= Rbyte4+3	; least significant PRNG byte
   256                          
   257                          NmiBase		= $DC		; NMI handler enabled/setup/triggered flags
   258                          					; bit	function
   259                          					; ===	========
   260                          					; 7	interrupt enabled
   261                          					; 6	interrupt setup
   262                          					; 5	interrupt happened
   263                          ;			= $DD		; NMI handler addr low byte
   264                          ;			= $DE		; NMI handler addr high byte
   265                          IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
   266                          ;			= $E0		; IRQ handler addr low byte
   267                          ;			= $E1		; IRQ handler addr high byte
   268                          
   269                          ;			= $DE		; unused
   270                          ;			= $DF		; unused
   271                          ;			= $E0		; unused
   272                          ;			= $E1		; unused
   273                          ;			= $E2		; unused
   274                          ;			= $E3		; unused
   275                          ;			= $E4		; unused
   276                          ;			= $E5		; unused
   277                          ;			= $E6		; unused
   278                          ;			= $E7		; unused
   279                          ;			= $E8		; unused
   280                          ;			= $E9		; unused
   281                          ;			= $EA		; unused
   282                          ;			= $EB		; unused
   283                          ;			= $EC		; unused
   284                          ;			= $ED		; unused
   285                          ;			= $EE		; unused
   286                          
   287                          Decss			= $E2		; number to decimal string start
   288                          Decssp1		= Decss+1	; number to decimal string start
   289                          
   290                          ;			= $FF		; decimal string end
   291                          
   292                          ; token values needed for BASIC
   293                          
   294                          ; primary command tokens (can start a statement)
   295                          
   296                          TK_END		= $80			; END token
   297                          TK_FOR		= TK_END+1		; FOR token
   298                          TK_NEXT		= TK_FOR+1		; NEXT token
   299                          TK_DATA		= TK_NEXT+1		; DATA token
   300                          TK_INPUT		= TK_DATA+1		; INPUT token
   301                          TK_DIM		= TK_INPUT+1	; DIM token
   302                          TK_READ		= TK_DIM+1		; READ token
   303                          TK_LET		= TK_READ+1		; LET token
   304                          TK_DEC		= TK_LET+1		; DEC token
   305                          TK_GOTO		= TK_DEC+1		; GOTO token
   306                          TK_RUN		= TK_GOTO+1		; RUN token
   307                          TK_IF			= TK_RUN+1		; IF token
   308                          TK_RESTORE		= TK_IF+1		; RESTORE token
   309                          TK_GOSUB		= TK_RESTORE+1	; GOSUB token
   310                          TK_RETIRQ		= TK_GOSUB+1	; RETIRQ token
   311                          TK_RETNMI		= TK_RETIRQ+1	; RETNMI token
   312                          TK_RETURN		= TK_RETNMI+1	; RETURN token
   313                          TK_REM		= TK_RETURN+1	; REM token
   314                          TK_STOP		= TK_REM+1		; STOP token
   315                          TK_ON			= TK_STOP+1		; ON token
   316                          TK_NULL		= TK_ON+1		; NULL token
   317                          TK_INC		= TK_NULL+1		; INC token
   318                          TK_WAIT		= TK_INC+1		; WAIT token
   319                          TK_LOAD		= TK_WAIT+1		; LOAD token
   320                          TK_SAVE		= TK_LOAD+1		; SAVE token
   321                          TK_DEF		= TK_SAVE+1		; DEF token
   322                          TK_POKE		= TK_DEF+1		; POKE token
   323                          TK_DOKE		= TK_POKE+1		; DOKE token
   324                          TK_CALL		= TK_DOKE+1		; CALL token
   325                          TK_DO			= TK_CALL+1		; DO token
   326                          TK_LOOP		= TK_DO+1		; LOOP token
   327                          TK_PRINT		= TK_LOOP+1		; PRINT token
   328                          TK_CONT		= TK_PRINT+1	; CONT token
   329                          TK_LIST		= TK_CONT+1		; LIST token
   330                          TK_CLEAR		= TK_LIST+1		; CLEAR token
   331                          TK_NEW		= TK_CLEAR+1	; NEW token
   332                          TK_WIDTH		= TK_NEW+1		; WIDTH token
   333                          TK_GET		= TK_WIDTH+1	; GET token
   334                          TK_SWAP		= TK_GET+1		; SWAP token
   335                          TK_BITSET		= TK_SWAP+1		; BITSET token
   336                          TK_BITCLR		= TK_BITSET+1	; BITCLR token
   337                          TK_IRQ		= TK_BITCLR+1	; IRQ token
   338                          TK_NMI		= TK_IRQ+1		; NMI token
   339                          
   340                          ; secondary command tokens, can't start a statement
   341                          
   342                          TK_TAB		= TK_NMI+1		; TAB token
   343                          TK_ELSE		= TK_TAB+1		; ELSE token
   344                          TK_TO			= TK_ELSE+1		; TO token
   345                          TK_FN			= TK_TO+1		; FN token
   346                          TK_SPC		= TK_FN+1		; SPC token
   347                          TK_THEN		= TK_SPC+1		; THEN token
   348                          TK_NOT		= TK_THEN+1		; NOT token
   349                          TK_STEP		= TK_NOT+1		; STEP token
   350                          TK_UNTIL		= TK_STEP+1		; UNTIL token
   351                          TK_WHILE		= TK_UNTIL+1	; WHILE token
   352                          TK_OFF		= TK_WHILE+1	; OFF token
   353                          
   354                          ; opperator tokens
   355                          
   356                          TK_PLUS		= TK_OFF+1		; + token
   357                          TK_MINUS		= TK_PLUS+1		; - token
   358                          TK_MUL		= TK_MINUS+1	; * token
   359                          TK_DIV		= TK_MUL+1		; / token
   360                          TK_POWER		= TK_DIV+1		; ^ token
   361                          TK_AND		= TK_POWER+1	; AND token
   362                          TK_EOR		= TK_AND+1		; EOR token
   363                          TK_OR			= TK_EOR+1		; OR token
   364                          TK_RSHIFT		= TK_OR+1		; RSHIFT token
   365                          TK_LSHIFT		= TK_RSHIFT+1	; LSHIFT token
   366                          TK_GT			= TK_LSHIFT+1	; > token
   367                          TK_EQUAL		= TK_GT+1		; = token
   368                          TK_LT			= TK_EQUAL+1	; < token
   369                          
   370                          ; functions tokens
   371                          
   372                          TK_SGN		= TK_LT+1		; SGN token
   373                          TK_INT		= TK_SGN+1		; INT token
   374                          TK_ABS		= TK_INT+1		; ABS token
   375                          TK_USR		= TK_ABS+1		; USR token
   376                          TK_FRE		= TK_USR+1		; FRE token
   377                          TK_POS		= TK_FRE+1		; POS token
   378                          TK_SQR		= TK_POS+1		; SQR token
   379                          TK_RND		= TK_SQR+1		; RND token
   380                          TK_LOG		= TK_RND+1		; LOG token
   381                          TK_EXP		= TK_LOG+1		; EXP token
   382                          TK_COS		= TK_EXP+1		; COS token
   383                          TK_SIN		= TK_COS+1		; SIN token
   384                          TK_TAN		= TK_SIN+1		; TAN token
   385                          TK_ATN		= TK_TAN+1		; ATN token
   386                          TK_PEEK		= TK_ATN+1		; PEEK token
   387                          TK_DEEK		= TK_PEEK+1		; DEEK token
   388                          TK_SADD		= TK_DEEK+1		; SADD token
   389                          TK_LEN		= TK_SADD+1		; LEN token
   390                          TK_STRS		= TK_LEN+1		; STR$ token
   391                          TK_VAL		= TK_STRS+1		; VAL token
   392                          TK_ASC		= TK_VAL+1		; ASC token
   393                          TK_UCASES		= TK_ASC+1		; UCASE$ token
   394                          TK_LCASES		= TK_UCASES+1	; LCASE$ token
   395                          TK_CHRS		= TK_LCASES+1	; CHR$ token
   396                          TK_HEXS		= TK_CHRS+1		; HEX$ token
   397                          TK_BINS		= TK_HEXS+1		; BIN$ token
   398                          TK_BITTST		= TK_BINS+1		; BITTST token
   399                          TK_MAX		= TK_BITTST+1	; MAX token
   400                          TK_MIN		= TK_MAX+1		; MIN token
   401                          TK_PI			= TK_MIN+1		; PI token
   402                          TK_TWOPI		= TK_PI+1		; TWOPI token
   403                          TK_VPTR		= TK_TWOPI+1	; VARPTR token
   404                          TK_LEFTS		= TK_VPTR+1		; LEFT$ token
   405                          TK_RIGHTS		= TK_LEFTS+1	; RIGHT$ token
   406                          TK_MIDS		= TK_RIGHTS+1	; MID$ token
   407                          
   408                          ; offsets from a base of X or Y
   409                          
   410                          PLUS_0		= $00		; X or Y plus 0
   411                          PLUS_1		= $01		; X or Y plus 1
   412                          PLUS_2		= $02		; X or Y plus 2
   413                          PLUS_3		= $03		; X or Y plus 3
   414                          
   415                          LAB_STAK		= $0100	; stack bottom, no offset
   416                          
   417                          LAB_SKFE		= LAB_STAK+$FE
   418                          					; flushed stack address
   419                          LAB_SKFF		= LAB_STAK+$FF
   420                          					; flushed stack address
   421                          
   422                          ccflag		= $0300	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   423                          ccbyte		= ccflag+1	; BASIC CTRL-C byte
   424                          ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
   425                          
   426                          VEC_CC		= ccnull+1	; ctrl c check vector
   427                          
   428                          VEC_IN		= VEC_CC+2	; input vector
   429                          VEC_OUT		= VEC_IN+2	; output vector
   430                          VEC_LD		= VEC_OUT+2	; load vector
   431                          VEC_SV		= VEC_LD+2	; save vector
   432                          
   433                          ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
   434                          
   435                          Ibuffs		= IRQ_vec+$14
   436                          					; start of input buffer after IRQ/NMI code
   437                          Ibuffe		= Ibuffs+$47; end of input buffer
   438                          
   439                          Ram_base	= $0400	; start of user RAM (set as needed, should be page aligned)
   440                          Ram_top		= $7000	; end of user RAM+1 (set as needed, should be page aligned)
   441                          
   442                          ; This start can be changed to suit your system
   443                          
   444                          *=$9000
   445                          
   446                          ; For convenience, put jump here to reset location so it can be
   447                          ; run from the load address.
   448                          
   449  9000 4c3bb8             JMP	RES_vec
   450                          
   451                          ; BASIC cold start entry point
   452                          
   453                          ; new page 2 initialisation, copy block to ccflag on
   454                          
   455                          LAB_COLD
   456  9003 a004               	LDY	#PG2_TABE-PG2_TABS-1
   457                          					; byte count-1
   458                          LAB_2D13
   459  9005 b908b1             	LDA	PG2_TABS,Y		; get byte
   460  9008 990003             	STA	ccflag,Y		; store in page 2
   461  900b 88                 	DEY				; decrement count
   462  900c 10f7               	BPL	LAB_2D13		; loop if not done
   463                          
   464  900e a2ff               	LDX	#$FF			; set byte
   465  9010 8688               	STX	Clineh		; set current line high byte (set immediate mode)
   466  9012 9a                 	TXS				; reset stack pointer
   467                          
   468  9013 a94c               	LDA	#$4C			; code for JMP
   469  9015 85a1               	STA	Fnxjmp		; save for jump vector for functions
   470                          
   471                          ; copy block from LAB_2CEE to $00BC - $00D3
   472                          
   473  9017 a21c               	LDX	#StrTab-LAB_2CEE	; set byte count
   474                          LAB_2D4E
   475  9019 bd0cb1             	LDA	LAB_2CEE-1,X	; get byte from table
   476  901c 95bb               	STA	LAB_IGBY-1,X	; save byte in page zero
   477  901e ca                 	DEX				; decrement count
   478  901f d0f8               	BNE	LAB_2D4E		; loop if not all done
   479                          
   480                          ; copy block from StrTab to $0000 - $0012
   481                          
   482                          LAB_GMEM
   483  9021 a212               	LDX	#EndTab-StrTab-1	; set byte count-1
   484                          TabLoop
   485  9023 bd29b1             	LDA	StrTab,X		; get byte from table
   486  9026 9500               	STA	PLUS_0,X		; save byte in page zero
   487  9028 ca                 	DEX				; decrement count
   488  9029 10f8               	BPL	TabLoop		; loop if not all done
   489                          
   490                          ; set-up start values
   491                          
   492  902b a900               	LDA	#$00			; clear A
   493  902d 85dc               	STA	NmiBase		; clear NMI handler enabled flag
   494  902f 85df               	STA	IrqBase		; clear IRQ handler enabled flag
   495  9031 85b2               	STA	FAC1_o		; clear FAC1 overflow byte
   496  9033 8567               	STA	last_sh		; clear descriptor stack top item pointer high byte
   497                          
   498  9035 a90e               	LDA	#$0E			; set default tab size
   499  9037 8564               	STA	TabSiz		; save it
   500  9039 a903               	LDA	#$03			; set garbage collect step size for descriptor stack
   501  903b 85a0               	STA	g_step		; save it
   502  903d a268               	LDX	#des_sk		; descriptor stack start
   503  903f 8665               	STX	next_s		; set descriptor stack pointer
   504                          
   505  9041 a900               	lda #$00
   506  9043 8511               	sta Itempl
   507  9045 a968               	lda #$68
   508  9047 8512               	sta Itemph	; 16KB
   509                          
   510  9049 4c6490                     JMP LAB_2D93    ; Skip memory question
   511                          
   512  904c 20a998             	JSR	LAB_CRLF		; print CR/LF
   513  904f a93c               	LDA	#<LAB_MSZM		; point to memory size message (low addr)
   514  9051 a0b1               	LDY	#>LAB_MSZM		; point to memory size message (high addr)
   515  9053 20e598             	JSR	LAB_18C3		; print null terminated string from memory
   516  9056 204b92             	JSR	LAB_INLN		; print "? " and get BASIC input
   517  9059 86c3               	STX	Bpntrl		; set BASIC execute pointer low byte
   518  905b 84c4               	STY	Bpntrh		; set BASIC execute pointer high byte
   519  905d 20c200             	JSR	LAB_GBYT		; get last byte back
   520                          
   521  9060 d01f               	BNE	LAB_2DAA		; branch if not null (user typed something)
   522                          
   523  9062 a000               	LDY	#$00			; else clear Y
   524                          					; character was null so get memory size the hard way
   525                          					; we get here with Y=0 and Itempl/h = Ram_base
   526                          LAB_2D93
   527  9064 e611               	INC	Itempl		; increment temporary integer low byte
   528  9066 d008               	BNE	LAB_2D99		; branch if no overflow
   529                          
   530  9068 e612               	INC	Itemph		; increment temporary integer high byte
   531  906a a512               	LDA	Itemph		; get high byte
   532  906c c970               	CMP	#>Ram_top		; compare with top of RAM+1
   533  906e f01d               	BEQ	LAB_2DB6		; branch if match (end of user RAM)
   534                          
   535                          LAB_2D99
   536  9070 a955               	LDA	#$55			; set test byte
   537  9072 9111               	STA	(Itempl),Y		; save via temporary integer
   538  9074 d111               	CMP	(Itempl),Y		; compare via temporary integer
   539  9076 d015               	BNE	LAB_2DB6		; branch if fail
   540                          
   541  9078 0a                 	ASL				; shift test byte left (now $AA)
   542  9079 9111               	STA	(Itempl),Y		; save via temporary integer
   543  907b d111               	CMP	(Itempl),Y		; compare via temporary integer
   544  907d f0e5               	BEQ	LAB_2D93		; if ok go do next byte
   545                          
   546  907f d00c               	BNE	LAB_2DB6		; branch if fail
   547                          
   548                          LAB_2DAA
   549  9081 20b8a9             	JSR	LAB_2887		; get FAC1 from string
   550  9084 a5ac               	LDA	FAC1_e		; get FAC1 exponent
   551  9086 c998               	CMP	#$98			; compare with exponent = 2^24
   552  9088 b097               	BCS	LAB_GMEM		; if too large go try again
   553                          
   554  908a 2009a5             	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
   555                          					; (no range check)
   556                          
   557                          LAB_2DB6
   558  908d a511               	LDA	Itempl		; get temporary integer low byte
   559  908f a412               	LDY	Itemph		; get temporary integer high byte
   560  9091 c001               	CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
   561  9093 908c               	BCC	LAB_GMEM		; if too small go try again
   562                          
   563                          
   564                          ; uncomment these lines if you want to check on the high limit of memory. Note if
   565                          ; Ram_top is set too low then this will fail. default is ignore it and assume the
   566                          ; users know what they're doing!
   567                          
   568                          ;	CPY	#>Ram_top		; compare with top of RAM high byte
   569                          ;	BCC	MEM_OK		; branch if < RAM top
   570                          
   571                          ;	BNE	LAB_GMEM		; if too large go try again
   572                          					; else was = so compare low bytes
   573                          ;	CMP	#<Ram_top		; compare with top of RAM low byte
   574                          ;	BEQ	MEM_OK		; branch if = RAM top
   575                          
   576                          ;	BCS	LAB_GMEM		; if too large go try again
   577                          
   578                          ;MEM_OK
   579  9095 8585               	STA	Ememl			; set end of mem low byte
   580  9097 8486               	STY	Ememh			; set end of mem high byte
   581  9099 8581               	STA	Sstorl		; set bottom of string space low byte
   582  909b 8482               	STY	Sstorh		; set bottom of string space high byte
   583                          
   584  909d a000               	LDY	#<Ram_base		; set start addr low byte
   585  909f a204               	LDX	#>Ram_base		; set start addr high byte
   586  90a1 8479               	STY	Smeml			; save start of mem low byte
   587  90a3 867a               	STX	Smemh			; save start of mem high byte
   588                          
   589                          ; this line is only needed if Ram_base is not $xx00
   590                          
   591                          ;	LDY	#$00			; clear Y
   592  90a5 98                 	TYA				; clear A
   593  90a6 9179               	STA	(Smeml),Y		; clear first byte
   594  90a8 e679               	INC	Smeml			; increment start of mem low byte
   595                          
   596                          ; these two lines are only needed if Ram_base is $xxFF
   597                          
   598                          ;	BNE	LAB_2E05		; branch if no rollover
   599                          
   600                          ;	INC	Smemh			; increment start of mem high byte
   601                          LAB_2E05
   602                          	;JSR	LAB_CRLF		; print CR/LF
   603  90aa 206793             	JSR	LAB_1463		; do "NEW" and "CLEAR"
   604  90ad a585               	LDA	Ememl			; get end of mem low byte
   605  90af 38                 	SEC				; set carry for subtract
   606  90b0 e579               	SBC	Smeml			; subtract start of mem low byte
   607  90b2 aa                 	TAX				; copy to X
   608  90b3 a586               	LDA	Ememh			; get end of mem high byte
   609  90b5 e57a               	SBC	Smemh			; subtract start of mem high byte
   610                          
   611                          ; TS: Don't print free RAM
   612                          ;	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
   613                          
   614  90b7 20a998             	JSR	LAB_CRLF		; print CR/LF
   615  90ba a94b               	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
   616  90bc a0b1               	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
   617  90be 20e598             	JSR	LAB_18C3		; print null terminated string from memory
   618  90c1 a965               	LDA	#<LAB_1274		; warm start vector low byte
   619  90c3 a091               	LDY	#>LAB_1274		; warm start vector high byte
   620  90c5 8501               	STA	Wrmjpl		; save warm start vector low byte
   621  90c7 8402               	STY	Wrmjph		; save warm start vector high byte
   622  90c9 6c0100             	JMP	(Wrmjpl)		; go do warm start
   623                          
   624                          ; open up space in memory
   625                          ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   626                          
   627                          ; Nbendl,Nbendh - new block end address (A/Y)
   628                          ; Obendl,Obendh - old block end address
   629                          ; Ostrtl,Ostrth - old block start address
   630                          
   631                          ; returns with ..
   632                          
   633                          ; Nbendl,Nbendh - new block start address (high byte - $100)
   634                          ; Obendl,Obendh - old block start address (high byte - $100)
   635                          ; Ostrtl,Ostrth - old block start address (unchanged)
   636                          
   637                          LAB_11CF
   638  90cc 201691             	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
   639                          					; addr to check is in AY (low/high)
   640  90cf 857f               	STA	Earryl		; save new array mem end low byte
   641  90d1 8480               	STY	Earryh		; save new array mem end high byte
   642                          
   643                          ; open up space in memory
   644                          ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   645                          ; don't set array end
   646                          
   647                          LAB_11D6
   648  90d3 38                 	SEC				; set carry for subtract
   649  90d4 a5a6               	LDA	Obendl		; get block end low byte
   650  90d6 e5aa               	SBC	Ostrtl		; subtract block start low byte
   651  90d8 a8                 	TAY				; copy MOD(block length/$100) byte to Y
   652  90d9 a5a7               	LDA	Obendh		; get block end high byte
   653  90db e5ab               	SBC	Ostrth		; subtract block start high byte
   654  90dd aa                 	TAX				; copy block length high byte to X
   655  90de e8                 	INX				; +1 to allow for count=0 exit
   656  90df 98                 	TYA				; copy block length low byte to A
   657  90e0 f024               	BEQ	LAB_120A		; branch if length low byte=0
   658                          
   659                          					; block is (X-1)*256+Y bytes, do the Y bytes first
   660                          
   661  90e2 38                 	SEC				; set carry for add + 1, two's complement
   662  90e3 49ff               	EOR	#$FF			; invert low byte for subtract
   663  90e5 65a6               	ADC	Obendl		; add block end low byte
   664                          
   665  90e7 85a6               	STA	Obendl		; save corrected old block end low byte
   666  90e9 b003               	BCS	LAB_11F3		; branch if no underflow
   667                          
   668  90eb c6a7               	DEC	Obendh		; else decrement block end high byte
   669  90ed 38                 	SEC				; set carry for add + 1, two's complement
   670                          LAB_11F3
   671  90ee 98                 	TYA				; get MOD(block length/$100) byte
   672  90ef 49ff               	EOR	#$FF			; invert low byte for subtract
   673  90f1 65a4               	ADC	Nbendl		; add destination end low byte
   674  90f3 85a4               	STA	Nbendl		; save modified new block end low byte
   675  90f5 b008               	BCS	LAB_1203		; branch if no underflow
   676                          
   677  90f7 c6a5               	DEC	Nbendh		; else decrement block end high byte
   678  90f9 9004               	BCC	LAB_1203		; branch always
   679                          
   680                          LAB_11FF
   681  90fb b1a6               	LDA	(Obendl),Y		; get byte from source
   682  90fd 91a4               	STA	(Nbendl),Y		; copy byte to destination
   683                          LAB_1203
   684  90ff 88                 	DEY				; decrement index
   685  9100 d0f9               	BNE	LAB_11FF		; loop until Y=0
   686                          
   687                          					; now do Y=0 indexed byte
   688  9102 b1a6               	LDA	(Obendl),Y		; get byte from source
   689  9104 91a4               	STA	(Nbendl),Y		; save byte to destination
   690                          LAB_120A
   691  9106 c6a7               	DEC	Obendh		; decrement source pointer high byte
   692  9108 c6a5               	DEC	Nbendh		; decrement destination pointer high byte
   693  910a ca                 	DEX				; decrement block count
   694  910b d0f2               	BNE	LAB_1203		; loop until count = $0
   695                          
   696  910d 60                 	RTS
   697                          
   698                          ; check room on stack for A bytes
   699                          ; stack too deep? do OM error
   700                          
   701                          LAB_1212
   702  910e 8578               	STA	TempB			; save result in temp byte
   703  9110 ba                 	TSX				; copy stack
   704  9111 e478               	CPX	TempB			; compare new "limit" with stack
   705  9113 9030               	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
   706                          
   707  9115 60                 	RTS
   708                          
   709                          ; check available memory, "Out of memory" error if no room
   710                          ; addr to check is in AY (low/high)
   711                          
   712                          LAB_121F
   713  9116 c482               	CPY	Sstorh		; compare bottom of string mem high byte
   714  9118 902a               	BCC	LAB_124B		; if less then exit (is ok)
   715                          
   716  911a d004               	BNE	LAB_1229		; skip next test if greater (tested <)
   717                          
   718                          					; high byte was =, now do low byte
   719  911c c581               	CMP	Sstorl		; compare with bottom of string mem low byte
   720  911e 9024               	BCC	LAB_124B		; if less then exit (is ok)
   721                          
   722                          					; addr is > string storage ptr (oops!)
   723                          LAB_1229
   724  9120 48                 	PHA				; push addr low byte
   725  9121 a208               	LDX	#$08			; set index to save Adatal to expneg inclusive
   726  9123 98                 	TYA				; copy addr high byte (to push on stack)
   727                          
   728                          					; save misc numeric work area
   729                          LAB_122D
   730  9124 48                 	PHA				; push byte
   731  9125 b5a3               	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
   732  9127 ca                 	DEX				; decrement index
   733  9128 10fa               	BPL	LAB_122D		; loop until all done
   734                          
   735  912a 20f1a1             	JSR	LAB_GARB		; garbage collection routine
   736                          
   737                          					; restore misc numeric work area
   738  912d a200               	LDX	#$00			; clear the index to restore bytes
   739                          LAB_1238
   740  912f 68                 	PLA				; pop byte
   741  9130 95a4               	STA	Adatal,X		; save byte to Adatal to expneg
   742  9132 e8                 	INX				; increment index
   743  9133 e008               	CPX	#$08			; compare with end + 1
   744  9135 30f8               	BMI	LAB_1238		; loop if more to do
   745                          
   746  9137 68                 	PLA				; pop addr high byte
   747  9138 a8                 	TAY				; copy back to Y
   748  9139 68                 	PLA				; pop addr low byte
   749  913a c482               	CPY	Sstorh		; compare bottom of string mem high byte
   750  913c 9006               	BCC	LAB_124B		; if less then exit (is ok)
   751                          
   752  913e d005               	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
   753                          
   754                          					; high byte was =, now do low byte
   755  9140 c581               	CMP	Sstorl		; compare with bottom of string mem low byte
   756  9142 b001               	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
   757                          
   758                          					; ok exit, carry clear
   759                          LAB_124B
   760  9144 60                 	RTS
   761                          
   762                          ; do "Out of memory" error then warm start
   763                          
   764                          LAB_OMER
   765  9145 a20c               	LDX	#$0C			; error code $0C ("Out of memory" error)
   766                          
   767                          ; do error #X, then warm start
   768                          
   769                          LAB_XERR
   770  9147 20a998             	JSR	LAB_CRLF		; print CR/LF
   771                          
   772  914a bdacb6             	LDA	LAB_BAER,X		; get error message pointer low byte
   773  914d bcadb6             	LDY	LAB_BAER+1,X	; get error message pointer high byte
   774  9150 20e598             	JSR	LAB_18C3		; print null terminated string from memory
   775                          
   776  9153 20a093             	JSR	LAB_1491		; flush stack and clear continue flag
   777  9156 a9fa               	LDA	#<LAB_EMSG		; point to " Error" low addr
   778  9158 a0b7               	LDY	#>LAB_EMSG		; point to " Error" high addr
   779                          LAB_1269
   780  915a 20e598             	JSR	LAB_18C3		; print null terminated string from memory
   781  915d a488               	LDY	Clineh		; get current line high byte
   782  915f c8                 	INY				; increment it
   783  9160 f003               	BEQ	LAB_1274		; go do warm start (was immediate mode)
   784                          
   785                          					; else print line number
   786  9162 2089aa             	JSR	LAB_2953		; print " in line [LINE #]"
   787                          
   788                          ; BASIC warm start entry point
   789                          ; wait for Basic command
   790                          
   791                          LAB_1274
   792                          					; clear ON IRQ/NMI bytes
   793  9165 a900               	LDA	#$00			; clear A
   794  9167 85df               	STA	IrqBase		; clear enabled byte
   795  9169 85dc               	STA	NmiBase		; clear enabled byte
   796  916b a90c               	LDA	#<LAB_RMSG		; point to "Ready" message low byte
   797  916d a0b8               	LDY	#>LAB_RMSG		; point to "Ready" message high byte
   798                          
   799  916f 20e598             	JSR	LAB_18C3		; go do print string
   800                          
   801                          ; wait for Basic command (no "Ready")
   802                          
   803                          LAB_127D
   804  9172 205892             	JSR	LAB_1357		; call for BASIC input
   805                          LAB_1280
   806  9175 86c3               	STX	Bpntrl		; set BASIC execute pointer low byte
   807  9177 84c4               	STY	Bpntrh		; set BASIC execute pointer high byte
   808  9179 20c200             	JSR	LAB_GBYT		; scan memory
   809  917c f0f4               	BEQ	LAB_127D		; loop while null
   810                          
   811                          ; got to interpret input line now ..
   812                          
   813  917e a2ff               	LDX	#$FF			; current line to null value
   814  9180 8688               	STX	Clineh		; set current line high byte
   815  9182 9006               	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
   816                          
   817                          					; no line number .. immediate mode
   818  9184 208992             	JSR	LAB_13A6		; crunch keywords into Basic tokens
   819  9187 4c0a95             	JMP	LAB_15F6		; go scan and interpret code
   820                          
   821                          ; handle new BASIC line
   822                          
   823                          LAB_1295
   824  918a 206c97             	JSR	LAB_GFPN		; get fixed-point number into temp integer
   825  918d 208992             	JSR	LAB_13A6		; crunch keywords into Basic tokens
   826  9190 845d               	STY	Ibptr			; save index pointer to end of crunched line
   827  9192 203b93             	JSR	LAB_SSLN		; search BASIC for temp integer line number
   828  9195 9044               	BCC	LAB_12E6		; branch if not found
   829                          
   830                          					; aroooogah! line # already exists! delete it
   831  9197 a001               	LDY	#$01			; set index to next line pointer high byte
   832  9199 b1aa               	LDA	(Baslnl),Y		; get next line pointer high byte
   833  919b 8572               	STA	ut1_ph		; save it
   834  919d a57b               	LDA	Svarl			; get start of vars low byte
   835  919f 8571               	STA	ut1_pl		; save it
   836  91a1 a5ab               	LDA	Baslnh		; get found line pointer high byte
   837  91a3 8574               	STA	ut2_ph		; save it
   838  91a5 a5aa               	LDA	Baslnl		; get found line pointer low byte
   839  91a7 88                 	DEY				; decrement index
   840  91a8 f1aa               	SBC	(Baslnl),Y		; subtract next line pointer low byte
   841  91aa 18                 	CLC				; clear carry for add
   842  91ab 657b               	ADC	Svarl			; add start of vars low byte
   843  91ad 857b               	STA	Svarl			; save new start of vars low byte
   844  91af 8573               	STA	ut2_pl		; save destination pointer low byte
   845  91b1 a57c               	LDA	Svarh			; get start of vars high byte
   846  91b3 69ff               	ADC	#$FF			; -1 + carry
   847  91b5 857c               	STA	Svarh			; save start of vars high byte
   848  91b7 e5ab               	SBC	Baslnh		; subtract found line pointer high byte
   849  91b9 aa                 	TAX				; copy to block count
   850  91ba 38                 	SEC				; set carry for subtract
   851  91bb a5aa               	LDA	Baslnl		; get found line pointer low byte
   852  91bd e57b               	SBC	Svarl			; subtract start of vars low byte
   853  91bf a8                 	TAY				; copy to bytes in first block count
   854  91c0 b003               	BCS	LAB_12D0		; branch if overflow
   855                          
   856  91c2 e8                 	INX				; increment block count (correct for =0 loop exit)
   857  91c3 c674               	DEC	ut2_ph		; decrement destination high byte
   858                          LAB_12D0
   859  91c5 18                 	CLC				; clear carry for add
   860  91c6 6571               	ADC	ut1_pl		; add source pointer low byte
   861  91c8 9003               	BCC	LAB_12D8		; branch if no overflow
   862                          
   863  91ca c672               	DEC	ut1_ph		; else decrement source pointer high byte
   864  91cc 18                 	CLC				; clear carry
   865                          
   866                          					; close up memory to delete old line
   867                          LAB_12D8
   868  91cd b171               	LDA	(ut1_pl),Y		; get byte from source
   869  91cf 9173               	STA	(ut2_pl),Y		; copy to destination
   870  91d1 c8                 	INY				; increment index
   871  91d2 d0f9               	BNE	LAB_12D8		; while <> 0 do this block
   872                          
   873  91d4 e672               	INC	ut1_ph		; increment source pointer high byte
   874  91d6 e674               	INC	ut2_ph		; increment destination pointer high byte
   875  91d8 ca                 	DEX				; decrement block count
   876  91d9 d0f2               	BNE	LAB_12D8		; loop until all done
   877                          
   878                          					; got new line in buffer and no existing same #
   879                          LAB_12E6
   880  91db ad2103             	LDA	Ibuffs		; get byte from start of input buffer
   881  91de f03f               	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
   882                          
   883                          					; got new line and it isn't empty line
   884  91e0 a585               	LDA	Ememl			; get end of mem low byte
   885  91e2 a486               	LDY	Ememh			; get end of mem high byte
   886  91e4 8581               	STA	Sstorl		; set bottom of string space low byte
   887  91e6 8482               	STY	Sstorh		; set bottom of string space high byte
   888  91e8 a57b               	LDA	Svarl			; get start of vars low byte	(end of BASIC)
   889  91ea 85a6               	STA	Obendl		; save old block end low byte
   890  91ec a47c               	LDY	Svarh			; get start of vars high byte	(end of BASIC)
   891  91ee 84a7               	STY	Obendh		; save old block end high byte
   892  91f0 655d               	ADC	Ibptr			; add input buffer pointer	(also buffer length)
   893  91f2 9001               	BCC	LAB_1301		; branch if no overflow from add
   894                          
   895  91f4 c8                 	INY				; else increment high byte
   896                          LAB_1301
   897  91f5 85a4               	STA	Nbendl		; save new block end low byte	(move to, low byte)
   898  91f7 84a5               	STY	Nbendh		; save new block end high byte
   899  91f9 20cc90             	JSR	LAB_11CF		; open up space in memory
   900                          					; old start pointer Ostrtl,Ostrth set by the find line call
   901  91fc a57f               	LDA	Earryl		; get array mem end low byte
   902  91fe a480               	LDY	Earryh		; get array mem end high byte
   903  9200 857b               	STA	Svarl			; save start of vars low byte
   904  9202 847c               	STY	Svarh			; save start of vars high byte
   905  9204 a45d               	LDY	Ibptr			; get input buffer pointer	(also buffer length)
   906  9206 88                 	DEY				; adjust for loop type
   907                          LAB_1311
   908  9207 b91d03             	LDA	Ibuffs-4,Y		; get byte from crunched line
   909  920a 91aa               	STA	(Baslnl),Y		; save it to program memory
   910  920c 88                 	DEY				; decrement count
   911  920d c003               	CPY	#$03			; compare with first byte-1
   912  920f d0f6               	BNE	LAB_1311		; continue while count <> 3
   913                          
   914  9211 a512               	LDA	Itemph		; get line # high byte
   915  9213 91aa               	STA	(Baslnl),Y		; save it to program memory
   916  9215 88                 	DEY				; decrement count
   917  9216 a511               	LDA	Itempl		; get line # low byte
   918  9218 91aa               	STA	(Baslnl),Y		; save it to program memory
   919  921a 88                 	DEY				; decrement count
   920  921b a9ff               	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
   921                          					; byte then a zero already here would stop the chain rebuild
   922                          					; as it would think it was the [EOT] marker.
   923  921d 91aa               	STA	(Baslnl),Y		; save it to program memory
   924                          
   925                          LAB_1319
   926  921f 207c93             	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
   927  9222 a679               	LDX	Smeml			; get start of mem low byte
   928  9224 a57a               	LDA	Smemh			; get start of mem high byte
   929  9226 a001               	LDY	#$01			; index to high byte of next line pointer
   930                          LAB_1325
   931  9228 8671               	STX	ut1_pl		; set line start pointer low byte
   932  922a 8572               	STA	ut1_ph		; set line start pointer high byte
   933  922c b171               	LDA	(ut1_pl),Y		; get it
   934  922e f018               	BEQ	LAB_133E		; exit if end of program
   935                          
   936                          ; rebuild chaining of Basic lines
   937                          
   938  9230 a004               	LDY	#$04			; point to first code byte of line
   939                          					; there is always 1 byte + [EOL] as null entries are deleted
   940                          LAB_1330
   941  9232 c8                 	INY				; next code byte
   942  9233 b171               	LDA	(ut1_pl),Y		; get byte
   943  9235 d0fb               	BNE	LAB_1330		; loop if not [EOL]
   944                          
   945  9237 38                 	SEC				; set carry for add + 1
   946  9238 98                 	TYA				; copy end index
   947  9239 6571               	ADC	ut1_pl		; add to line start pointer low byte
   948  923b aa                 	TAX				; copy to X
   949  923c a000               	LDY	#$00			; clear index, point to this line's next line pointer
   950  923e 9171               	STA	(ut1_pl),Y		; set next line pointer low byte
   951  9240 98                 	TYA				; clear A
   952  9241 6572               	ADC	ut1_ph		; add line start pointer high byte + carry
   953  9243 c8                 	INY				; increment index to high byte
   954  9244 9171               	STA	(ut1_pl),Y		; save next line pointer low byte
   955  9246 90e0               	BCC	LAB_1325		; go do next line, branch always, carry clear
   956                          
   957                          
   958                          LAB_133E
   959  9248 4c7291             	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
   960                          
   961                          ; print "? " and get BASIC input
   962                          
   963                          LAB_INLN
   964  924b 20fd98             	JSR	LAB_18E3		; print "?" character
   965  924e 20fa98             	JSR	LAB_18E0		; print " "
   966  9251 d005               	BNE	LAB_1357		; call for BASIC input and return
   967                          
   968                          ; receive line from keyboard
   969                          
   970                          					; $08 as delete key (BACKSPACE on standard keyboard)
   971                          LAB_134B
   972  9253 20ff98             	JSR	LAB_PRNA		; go print the character
   973  9256 ca                 	DEX				; decrement the buffer counter (delete)
   974  9257 2c                 	!text	$2C			; make LDX into BIT abs
   975                          
   976                          ; call for BASIC input (main entry point)
   977                          
   978                          LAB_1357
   979  9258 a200               	LDX	#$00			; clear BASIC line buffer pointer
   980                          LAB_1359
   981  925a 20fcb0             	JSR	V_INPT		; call scan input device
   982  925d 90fb               	BCC	LAB_1359		; loop if no byte
   983                          
   984  925f f0f9               	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
   985                          
   986  9261 c907               	CMP	#$07			; compare with [BELL]
   987  9263 f010               	BEQ	LAB_1378		; branch if [BELL]
   988                          
   989  9265 c90d               	CMP	#$0D			; compare with [CR]
   990  9267 f019               	BEQ	LAB_1384		; do CR/LF exit if [CR]
   991                          
   992  9269 e000               	CPX	#$00			; compare pointer with $00
   993  926b d004               	BNE	LAB_1374		; branch if not empty
   994                          
   995                          ; next two lines ignore any non print character and [SPACE] if input buffer empty
   996                          
   997  926d c921               	CMP	#$21			; compare with [SP]+1
   998  926f 90e9               	BCC	LAB_1359		; if < ignore character
   999                          
  1000                          LAB_1374
  1001  9271 c908               	CMP	#$08			; compare with [BACKSPACE] (delete last character)
  1002  9273 f0de               	BEQ	LAB_134B		; go delete last character
  1003                          
  1004                          LAB_1378
  1005  9275 e047               	CPX	#Ibuffe-Ibuffs	; compare character count with max
  1006  9277 b00c               	BCS	LAB_138E		; skip store and do [BELL] if buffer full
  1007                          
  1008  9279 9d2103             	STA	Ibuffs,X		; else store in buffer
  1009  927c e8                 	INX				; increment pointer
  1010                          LAB_137F
  1011  927d 20ff98             	JSR	LAB_PRNA		; go print the character
  1012  9280 d0d8               	BNE	LAB_1359		; always loop for next character
  1013                          
  1014                          LAB_1384
  1015  9282 4ca098             	JMP	LAB_1866		; do CR/LF exit to BASIC
  1016                          
  1017                          ; announce buffer full
  1018                          
  1019                          LAB_138E
  1020  9285 a907               	LDA	#$07			; [BELL] character into A
  1021  9287 d0f4               	BNE	LAB_137F		; go print the [BELL] but ignore input character
  1022                          					; branch always
  1023                          
  1024                          ; crunch keywords into Basic tokens
  1025                          ; position independent buffer version ..
  1026                          ; faster, dictionary search version ....
  1027                          
  1028                          LAB_13A6
  1029  9289 a0ff                     LDY   #$FF              ; set save index (makes for easy math later)
  1030                          
  1031  928b 38                       SEC                     ; set carry for subtract
  1032  928c a5c3                     LDA   Bpntrl            ; get basic execute pointer low byte
  1033  928e e921                     SBC   #<Ibuffs          ; subtract input buffer start pointer
  1034  9290 aa                       TAX                     ; copy result to X (index past line # if any)
  1035                          
  1036  9291 8660                     STX   Oquote            ; clear open quote/DATA flag
  1037                          LAB_13AC
  1038  9293 bd2103                   LDA   Ibuffs,X          ; get byte from input buffer
  1039  9296 f05d                     BEQ   LAB_13EC          ; if null save byte then exit
  1040                          
  1041                          ; Applied case sensitivity patch from 
  1042                          ; https://github.com/Klaus2m5/6502_EhBASIC_V2.22/blob/master/mixed_case_keywords_mod.txt
  1043                          ;
  1044                          ; *** begin patch: lower case token recognition V2 ***
  1045                          ; ***              WARNING! changes documented behavior!
  1046                          ; *** add
  1047  9298 c97b                     CMP   #'{'              ; convert lower to upper case
  1048  929a b059                     BCS   LAB_13EC          ; is above lower case
  1049  929c c961                     CMP   #'a'
  1050  929e 9002                     BCC   PATCH_LC          ; is below lower case
  1051  92a0 29df                     AND   #$DF              ; mask lower case bit
  1052                                
  1053                          PATCH_LC
  1054                          ; *** end
  1055                             
  1056  92a2 c95f                     CMP   #'_'              ; compare with "_"
  1057  92a4 b04f                     BCS   LAB_13EC          ; if >= go save byte then continue crunching
  1058                          
  1059  92a6 c93c                     CMP   #'<'              ; compare with "<"
  1060  92a8 b00e                     BCS   LAB_13CC          ; if >= go crunch now
  1061                          
  1062  92aa c930                     CMP   #'0'              ; compare with "0"
  1063  92ac b047                     BCS   LAB_13EC          ; if >= go save byte then continue crunching
  1064                          
  1065  92ae 855c                     STA   Scnquo            ; save buffer byte as search character
  1066  92b0 c922                     CMP   #$22              ; is it quote character?
  1067  92b2 f063                     BEQ   LAB_1410          ; branch if so (copy quoted string)
  1068                          
  1069  92b4 c92a                     CMP   #'*'              ; compare with "*"
  1070  92b6 903d                     BCC   LAB_13EC          ; if < go save byte then continue crunching
  1071                          
  1072                                                        ; else crunch now
  1073                          LAB_13CC
  1074  92b8 2460                     BIT   Oquote            ; get open quote/DATA token flag
  1075  92ba 7039                     BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
  1076                                                        ; go save byte then continue crunching
  1077                          
  1078  92bc 8678                     STX   TempB             ; save buffer read index
  1079  92be 84ba                     STY   csidx             ; copy buffer save index
  1080  92c0 a013                     LDY   #<TAB_1STC        ; get keyword first character table low address
  1081  92c2 8473                     STY   ut2_pl            ; save pointer low byte
  1082  92c4 a0b3                     LDY   #>TAB_1STC        ; get keyword first character table high address
  1083  92c6 8474                     STY   ut2_ph            ; save pointer high byte
  1084  92c8 a000                     LDY   #$00              ; clear table pointer
  1085                          
  1086                          LAB_13D0
  1087  92ca d173                     CMP   (ut2_pl),Y        ; compare with keyword first character table byte
  1088  92cc f005                     BEQ   LAB_13D1          ; go do word_table_chr if match
  1089                          
  1090                          ; *** replace
  1091                          ;      BCC   LAB_13EA          ; if < keyword first character table byte go restore
  1092                          ; *** with
  1093  92ce 905b                     BCC   PATCH_LC2         ; if < keyword first character table byte go restore
  1094                          ; *** end
  1095                                                        ; Y and save to crunched
  1096                          
  1097  92d0 c8                       INY                     ; else increment pointer
  1098  92d1 d0f7                     BNE   LAB_13D0          ; and loop (branch always)
  1099                          
  1100                          ; have matched first character of some keyword
  1101                          
  1102                          LAB_13D1
  1103  92d3 98                       TYA                     ; copy matching index
  1104  92d4 0a                       ASL                     ; *2 (bytes per pointer)
  1105  92d5 aa                       TAX                     ; copy to new index
  1106  92d6 bd31b3                   LDA   TAB_CHRT,X        ; get keyword table pointer low byte
  1107  92d9 8573                     STA   ut2_pl            ; save pointer low byte
  1108  92db bd32b3                   LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
  1109  92de 8574                     STA   ut2_ph            ; save pointer high byte
  1110                          
  1111  92e0 a0ff                     LDY   #$FF              ; clear table pointer (make -1 for start)
  1112                          
  1113  92e2 a678                     LDX   TempB             ; restore buffer read index
  1114                          
  1115                          LAB_13D6
  1116  92e4 c8                       INY                     ; next table byte
  1117  92e5 b173                     LDA   (ut2_pl),Y        ; get byte from table
  1118                          LAB_13D8
  1119  92e7 300a                     BMI   LAB_13EA          ; all bytes matched so go save token
  1120                          
  1121  92e9 e8                       INX                     ; next buffer byte
  1122                          ; *** replace
  1123                          ;      CMP   Ibuffs,X          ; compare with byte from input buffer
  1124                          ; *** with
  1125  92ea 5d2103                   EOR     Ibuffs,x        ; check bits against table
  1126  92ed 29df                     AND     #$DF            ; DF masks the upper/lower case bit
  1127                          ; *** end      
  1128  92ef f0f3                     BEQ   LAB_13D6          ; go compare next if match
  1129                          
  1130  92f1 d02b                     BNE   LAB_1417          ; branch if >< (not found keyword)
  1131                          
  1132                          LAB_13EA
  1133  92f3 a4ba                     LDY   csidx             ; restore save index
  1134                          
  1135                                                        ; save crunched to output
  1136                          LAB_13EC
  1137  92f5 e8                       INX                     ; increment buffer index (to next input byte)
  1138  92f6 c8                       INY                     ; increment save index (to next output byte)
  1139  92f7 992103                   STA   Ibuffs,Y          ; save byte to output
  1140  92fa c900                     CMP   #$00              ; set the flags, set carry
  1141  92fc f032                     BEQ   LAB_142A          ; do exit if was null [EOL]
  1142                          
  1143                                                        ; A holds token or byte here
  1144  92fe e93a                     SBC   #':'              ; subtract ":" (carry set by CMP #00)
  1145  9300 f004                     BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
  1146                          
  1147                                                        ; A now holds token-$3A
  1148  9302 c949                     CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
  1149  9304 d002                     BNE   LAB_1401          ; branch if not DATA
  1150                          
  1151                                                        ; token was : or DATA
  1152                          LAB_13FF
  1153  9306 8560                     STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
  1154                          LAB_1401
  1155  9308 4957                     EOR   #TK_REM-$3A       ; effectively subtract REM token offset
  1156  930a d087                     BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
  1157                          
  1158  930c 855c                     STA   Asrch             ; else was REM so set search for [EOL]
  1159                          
  1160                                                        ; loop for REM, "..." etc.
  1161                          
  1162                          LAB_1408
  1163  930e bd2103                   LDA   Ibuffs,X          ; get byte from input buffer
  1164  9311 f0e2                     BEQ   LAB_13EC          ; branch if null [EOL]
  1165                          
  1166  9313 c55c                     CMP   Asrch             ; compare with stored character
  1167  9315 f0de                     BEQ   LAB_13EC          ; branch if match (end quote)
  1168                          
  1169                                                        ; entry for copy string in quotes, don't crunch
  1170                          LAB_1410
  1171  9317 c8                       INY                     ; increment buffer save index
  1172  9318 992103                   STA   Ibuffs,Y          ; save byte to output
  1173  931b e8                       INX                     ; increment buffer read index
  1174  931c d0f0                     BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
  1175                          
  1176                                                        ; not found keyword this go
  1177                          LAB_1417
  1178  931e a678                     LDX   TempB             ; compare has failed, restore buffer index (start byte!)
  1179                          
  1180                                                        ; now find the end of this word in the table
  1181                          LAB_141B
  1182  9320 b173                     LDA   (ut2_pl),Y        ; get table byte
  1183  9322 08                       PHP                     ; save status
  1184  9323 c8                       INY                     ; increment table index
  1185  9324 28                       PLP                     ; restore byte status
  1186  9325 10f9                     BPL   LAB_141B          ; if not end of keyword go do next
  1187                          
  1188  9327 b173                     LDA   (ut2_pl),Y        ; get byte from keyword table
  1189  9329 d0bc                     BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
  1190                          
  1191                                                        ; reached end of table with no match
  1192                          ; *** add label
  1193                          PATCH_LC2
  1194                          ; *** end
  1195                          ; *** end   patch: lower case token recognition V2 ***
  1196                          
  1197  932b bd2103                   LDA   Ibuffs,X          ; restore byte from input buffer
  1198  932e 10c3                     BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
  1199                                                        ; go save byte in output and continue crunching
  1200                          
  1201                                                        ; reached [EOL]
  1202                          LAB_142A
  1203  9330 c8                       INY                     ; increment pointer
  1204  9331 c8                       INY                     ; increment pointer (makes it next line pointer high byte)
  1205  9332 992103                   STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
  1206  9335 c8                       INY                     ; adjust for line copy
  1207  9336 c8                       INY                     ; adjust for line copy
  1208  9337 c8                       INY                     ; adjust for line copy
  1209  9338 c6c3                     DEC   Bpntrl            ; allow for increment (change if buffer starts at $xxFF)
  1210  933a 60                       RTS
  1211                          
  1212                          ; search Basic for temp integer line number from start of mem
  1213                          
  1214                          LAB_SSLN
  1215  933b a579               	LDA	Smeml			; get start of mem low byte
  1216  933d a67a               	LDX	Smemh			; get start of mem high byte
  1217                          
  1218                          ; search Basic for temp integer line number from AX
  1219                          ; returns carry set if found
  1220                          ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  1221                          
  1222                          ; old 541 new 507
  1223                          
  1224                          LAB_SHLN
  1225  933f a001               	LDY	#$01			; set index
  1226  9341 85aa               	STA	Baslnl		; save low byte as current
  1227  9343 86ab               	STX	Baslnh		; save high byte as current
  1228  9345 b1aa               	LDA	(Baslnl),Y		; get pointer high byte from addr
  1229  9347 f01a               	BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
  1230                          
  1231  9349 a003               	LDY	#$03			; set index to line # high byte
  1232  934b b1aa               	LDA	(Baslnl),Y		; get line # high byte
  1233  934d 88                 	DEY				; decrement index (point to low byte)
  1234  934e c512               	CMP	Itemph		; compare with temporary integer high byte
  1235  9350 d004               	BNE	LAB_1455		; if <> skip low byte check
  1236                          
  1237  9352 b1aa               	LDA	(Baslnl),Y		; get line # low byte
  1238  9354 c511               	CMP	Itempl		; compare with temporary integer low byte
  1239                          LAB_1455
  1240  9356 b009               	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
  1241                          
  1242                          LAB_1456
  1243  9358 88                 	DEY				; decrement index to next line ptr high byte
  1244  9359 b1aa               	LDA	(Baslnl),Y		; get next line pointer high byte
  1245  935b aa                 	TAX				; copy to X
  1246  935c 88                 	DEY				; decrement index to next line ptr low byte
  1247  935d b1aa               	LDA	(Baslnl),Y		; get next line pointer low byte
  1248  935f 90de               	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
  1249                          					; (carry always clear)
  1250                          
  1251                          LAB_145E
  1252  9361 f001               	BEQ	LAB_1460		; exit if temp = found line #, carry is set
  1253                          
  1254                          LAB_145F
  1255  9363 18                 	CLC				; clear found flag
  1256                          LAB_1460
  1257  9364 60                 	RTS
  1258                          
  1259                          ; perform NEW
  1260                          
  1261                          LAB_NEW
  1262  9365 d0fd               	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
  1263                          
  1264                          LAB_1463
  1265  9367 a900               	LDA	#$00			; clear A
  1266  9369 a8                 	TAY				; clear Y
  1267  936a 9179               	STA	(Smeml),Y		; clear first line, next line pointer, low byte
  1268  936c c8                 	INY				; increment index
  1269  936d 9179               	STA	(Smeml),Y		; clear first line, next line pointer, high byte
  1270  936f 18                 	CLC				; clear carry
  1271  9370 a579               	LDA	Smeml			; get start of mem low byte
  1272  9372 6902               	ADC	#$02			; calculate end of BASIC low byte
  1273  9374 857b               	STA	Svarl			; save start of vars low byte
  1274  9376 a57a               	LDA	Smemh			; get start of mem high byte
  1275  9378 6900               	ADC	#$00			; add any carry
  1276  937a 857c               	STA	Svarh			; save start of vars high byte
  1277                          
  1278                          ; reset execution to start, clear vars and flush stack
  1279                          
  1280                          LAB_1477
  1281  937c 18                 	CLC				; clear carry
  1282  937d a579               	LDA	Smeml			; get start of mem low byte
  1283  937f 69ff               	ADC	#$FF			; -1
  1284  9381 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  1285  9383 a57a               	LDA	Smemh			; get start of mem high byte
  1286  9385 69ff               	ADC	#$FF			; -1+carry
  1287  9387 85c4               	STA	Bpntrh		; save BASIC execute pointer high byte
  1288                          
  1289                          ; "CLEAR" command gets here
  1290                          
  1291                          LAB_147A
  1292  9389 a585               	LDA	Ememl			; get end of mem low byte
  1293  938b a486               	LDY	Ememh			; get end of mem high byte
  1294  938d 8581               	STA	Sstorl		; set bottom of string space low byte
  1295  938f 8482               	STY	Sstorh		; set bottom of string space high byte
  1296  9391 a57b               	LDA	Svarl			; get start of vars low byte
  1297  9393 a47c               	LDY	Svarh			; get start of vars high byte
  1298  9395 857d               	STA	Sarryl		; save var mem end low byte
  1299  9397 847e               	STY	Sarryh		; save var mem end high byte
  1300  9399 857f               	STA	Earryl		; save array mem end low byte
  1301  939b 8480               	STY	Earryh		; save array mem end high byte
  1302  939d 205b95             	JSR	LAB_161A		; perform RESTORE command
  1303                          
  1304                          ; flush stack and clear continue flag
  1305                          
  1306                          LAB_1491
  1307  93a0 a268               	LDX	#des_sk		; set descriptor stack pointer
  1308  93a2 8665               	STX	next_s		; save descriptor stack pointer
  1309  93a4 68                 	PLA				; pull return address low byte
  1310  93a5 aa                 	TAX				; copy return address low byte
  1311  93a6 68                 	PLA				; pull return address high byte
  1312  93a7 8efe01             	STX	LAB_SKFE		; save to cleared stack
  1313  93aa 8dff01             	STA	LAB_SKFF		; save to cleared stack
  1314  93ad a2fd               	LDX	#$FD			; new stack pointer
  1315  93af 9a                 	TXS				; reset stack
  1316  93b0 a900               	LDA	#$00			; clear byte
  1317  93b2 858c               	STA	Cpntrh		; clear continue pointer high byte
  1318  93b4 8561               	STA	Sufnxf		; clear subscript/FNX flag
  1319                          LAB_14A6
  1320  93b6 60                 	RTS
  1321                          
  1322                          ; perform CLEAR
  1323                          
  1324                          LAB_CLEAR
  1325  93b7 f0d0               	BEQ	LAB_147A		; if no following token go do "CLEAR"
  1326                          
  1327                          					; else there was a following token (go do syntax error)
  1328  93b9 60                 	RTS
  1329                          
  1330                          ; perform LIST [n][-m]
  1331                          ; bigger, faster version (a _lot_ faster)
  1332                          
  1333                          LAB_LIST
  1334  93ba 9006               	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
  1335                          
  1336  93bc f004               	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
  1337                          
  1338  93be c9b7               	CMP	#TK_MINUS		; compare with token for -
  1339  93c0 d0f4               	BNE	LAB_14A6		; exit if not - (LIST -m)
  1340                          
  1341                          					; LIST [[n][-m]]
  1342                          					; this bit sets the n , if present, as the start and end
  1343                          LAB_14BD
  1344  93c2 206c97             	JSR	LAB_GFPN		; get fixed-point number into temp integer
  1345  93c5 203b93             	JSR	LAB_SSLN		; search BASIC for temp integer line number
  1346                          					; (pointer in Baslnl/Baslnh)
  1347  93c8 20c200             	JSR	LAB_GBYT		; scan memory
  1348  93cb f00c               	BEQ	LAB_14D4		; branch if no more characters
  1349                          
  1350                          					; this bit checks the - is present
  1351  93cd c9b7               	CMP	#TK_MINUS		; compare with token for -
  1352  93cf d093               	BNE	LAB_1460		; return if not "-" (will be Syntax error)
  1353                          
  1354                          					; LIST [n]-m
  1355                          					; the - was there so set m as the end value
  1356  93d1 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  1357  93d4 206c97             	JSR	LAB_GFPN		; get fixed-point number into temp integer
  1358  93d7 d08b               	BNE	LAB_1460		; exit if not ok
  1359                          
  1360                          LAB_14D4
  1361  93d9 a511               	LDA	Itempl		; get temporary integer low byte
  1362  93db 0512               	ORA	Itemph		; OR temporary integer high byte
  1363  93dd d006               	BNE	LAB_14E2		; branch if start set
  1364                          
  1365  93df a9ff               	LDA	#$FF			; set for -1
  1366  93e1 8511               	STA	Itempl		; set temporary integer low byte
  1367  93e3 8512               	STA	Itemph		; set temporary integer high byte
  1368                          LAB_14E2
  1369  93e5 a001               	LDY	#$01			; set index for line
  1370  93e7 8460               	STY	Oquote		; clear open quote flag
  1371  93e9 20a998             	JSR	LAB_CRLF		; print CR/LF
  1372  93ec b1aa               	LDA	(Baslnl),Y		; get next line pointer high byte
  1373                          					; pointer initially set by search at LAB_14BD
  1374  93ee f03e               	BEQ	LAB_152B		; if null all done so exit
  1375  93f0 202b95             	JSR	LAB_1629		; do CRTL-C check vector
  1376                          
  1377  93f3 c8                 	INY				; increment index for line
  1378  93f4 b1aa               	LDA	(Baslnl),Y		; get line # low byte
  1379  93f6 aa                 	TAX				; copy to X
  1380  93f7 c8                 	INY				; increment index
  1381  93f8 b1aa               	LDA	(Baslnl),Y		; get line # high byte
  1382  93fa c512               	CMP	Itemph		; compare with temporary integer high byte
  1383  93fc d004               	BNE	LAB_14FF		; branch if no high byte match
  1384                          
  1385  93fe e411               	CPX	Itempl		; compare with temporary integer low byte
  1386  9400 f002               	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
  1387                          
  1388                          LAB_14FF				; else ..
  1389  9402 b02a               	BCS	LAB_152B		; if greater all done so exit
  1390                          
  1391                          LAB_1501
  1392  9404 8497               	STY	Tidx1			; save index for line
  1393  9406 2094aa             	JSR	LAB_295E		; print XA as unsigned integer
  1394  9409 a920               	LDA	#$20			; space is the next character
  1395                          LAB_1508
  1396  940b a497               	LDY	Tidx1			; get index for line
  1397  940d 297f               	AND	#$7F			; mask top out bit of character
  1398                          LAB_150C
  1399  940f 20ff98             	JSR	LAB_PRNA		; go print the character
  1400  9412 c922               	CMP	#$22			; was it " character
  1401  9414 d006               	BNE	LAB_1519		; branch if not
  1402                          
  1403                          					; we are either entering or leaving a pair of quotes
  1404  9416 a560               	LDA	Oquote		; get open quote flag
  1405  9418 49ff               	EOR	#$FF			; toggle it
  1406  941a 8560               	STA	Oquote		; save it back
  1407                          LAB_1519
  1408  941c c8                 	INY				; increment index
  1409  941d b1aa               	LDA	(Baslnl),Y		; get next byte
  1410  941f d00e               	BNE	LAB_152E		; branch if not [EOL] (go print character)
  1411  9421 a8                 	TAY				; else clear index
  1412  9422 b1aa               	LDA	(Baslnl),Y		; get next line pointer low byte
  1413  9424 aa                 	TAX				; copy to X
  1414  9425 c8                 	INY				; increment index
  1415  9426 b1aa               	LDA	(Baslnl),Y		; get next line pointer high byte
  1416  9428 86aa               	STX	Baslnl		; set pointer to line low byte
  1417  942a 85ab               	STA	Baslnh		; set pointer to line high byte
  1418  942c d0b7               	BNE	LAB_14E2		; go do next line if not [EOT]
  1419                          					; else ..
  1420                          LAB_152B
  1421  942e 60                 	RTS
  1422                          
  1423                          LAB_152E
  1424  942f 10de               	BPL	LAB_150C		; just go print it if not token byte
  1425                          
  1426                          					; else was token byte so uncrunch it (maybe)
  1427  9431 2460               	BIT	Oquote		; test the open quote flag
  1428  9433 30da               	BMI	LAB_150C		; just go print character if open quote set
  1429                          
  1430  9435 a2b5               	LDX	#>LAB_KEYT		; get table address high byte
  1431  9437 0a                 	ASL				; *2
  1432  9438 0a                 	ASL				; *4
  1433  9439 9002               	BCC	LAB_152F		; branch if no carry
  1434                          
  1435  943b e8                 	INX				; else increment high byte
  1436  943c 18                 	CLC				; clear carry for add
  1437                          LAB_152F
  1438  943d 6914               	ADC	#<LAB_KEYT		; add low byte
  1439  943f 9001               	BCC	LAB_1530		; branch if no carry
  1440                          
  1441  9441 e8                 	INX				; else increment high byte
  1442                          LAB_1530
  1443  9442 8573               	STA	ut2_pl		; save table pointer low byte
  1444  9444 8674               	STX	ut2_ph		; save table pointer high byte
  1445  9446 8497               	STY	Tidx1			; save index for line
  1446  9448 a000               	LDY	#$00			; clear index
  1447  944a b173               	LDA	(ut2_pl),Y		; get length
  1448  944c aa                 	TAX				; copy length
  1449  944d c8                 	INY				; increment index
  1450  944e b173               	LDA	(ut2_pl),Y		; get 1st character
  1451  9450 ca                 	DEX				; decrement length
  1452  9451 f0b8               	BEQ	LAB_1508		; if no more characters exit and print
  1453                          
  1454  9453 20ff98             	JSR	LAB_PRNA		; go print the character
  1455  9456 c8                 	INY				; increment index
  1456  9457 b173               	LDA	(ut2_pl),Y		; get keyword address low byte
  1457  9459 48                 	PHA				; save it for now
  1458  945a c8                 	INY				; increment index
  1459  945b b173               	LDA	(ut2_pl),Y		; get keyword address high byte
  1460  945d a000               	LDY	#$00
  1461  945f 8574               	STA	ut2_ph		; save keyword pointer high byte
  1462  9461 68                 	PLA				; pull low byte
  1463  9462 8573               	STA	ut2_pl		; save keyword pointer low byte
  1464                          LAB_1540
  1465  9464 b173               	LDA	(ut2_pl),Y		; get character
  1466  9466 ca                 	DEX				; decrement character count
  1467  9467 f0a2               	BEQ	LAB_1508		; if last character exit and print
  1468                          
  1469  9469 20ff98             	JSR	LAB_PRNA		; go print the character
  1470  946c c8                 	INY				; increment index
  1471  946d d0f5               	BNE	LAB_1540		; loop for next character
  1472                          
  1473                          ; perform FOR
  1474                          
  1475                          LAB_FOR
  1476  946f a980               	LDA	#$80			; set FNX
  1477  9471 8561               	STA	Sufnxf		; set subscript/FNX flag
  1478  9473 20cb97             	JSR	LAB_LET		; go do LET
  1479  9476 68                 	PLA				; pull return address
  1480  9477 68                 	PLA				; pull return address
  1481  9478 a910               	LDA	#$10			; we need 16d bytes !
  1482  947a 200e91             	JSR	LAB_1212		; check room on stack for A bytes
  1483  947d 20b496             	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1484  9480 18                 	CLC				; clear carry for add
  1485  9481 98                 	TYA				; copy index to A
  1486  9482 65c3               	ADC	Bpntrl		; add BASIC execute pointer low byte
  1487  9484 48                 	PHA				; push onto stack
  1488  9485 a5c4               	LDA	Bpntrh		; get BASIC execute pointer high byte
  1489  9487 6900               	ADC	#$00			; add carry
  1490  9489 48                 	PHA				; push onto stack
  1491  948a a588               	LDA	Clineh		; get current line high byte
  1492  948c 48                 	PHA				; push onto stack
  1493  948d a587               	LDA	Clinel		; get current line low byte
  1494  948f 48                 	PHA				; push onto stack
  1495  9490 a9ad               	LDA	#TK_TO		; get "TO" token
  1496  9492 20039c             	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  1497  9495 20e29a             	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  1498  9498 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1499                          					; else do type mismatch
  1500  949b a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  1501  949d 097f               	ORA	#$7F			; set all non sign bits
  1502  949f 25ad               	AND	FAC1_1		; and FAC1 mantissa1
  1503  94a1 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  1504  94a3 a9ae               	LDA	#<LAB_159F		; set return address low byte
  1505  94a5 a094               	LDY	#>LAB_159F		; set return address high byte
  1506  94a7 8571               	STA	ut1_pl		; save return address low byte
  1507  94a9 8472               	STY	ut1_ph		; save return address high byte
  1508  94ab 4c969b             	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
  1509                          
  1510                          LAB_159F
  1511  94ae a9e3               	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
  1512  94b0 a0b1               	LDY	#>LAB_259C		; set 1 pointer high addr
  1513  94b2 208fa8             	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1514  94b5 20c200             	JSR	LAB_GBYT		; scan memory
  1515  94b8 c9b2               	CMP	#TK_STEP		; compare with STEP token
  1516  94ba d006               	BNE	LAB_15B3		; jump if not "STEP"
  1517                          
  1518                          					;.was step so ..
  1519  94bc 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  1520  94bf 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1521                          					; else do type mismatch
  1522                          LAB_15B3
  1523  94c2 20fba8             	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
  1524  94c5 85b0               	STA	FAC1_s		; set FAC1 sign (b7)
  1525                          					; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1526                          					; compare the FOR value and the TO value and return +1 if
  1527                          					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1528                          					; here (+/-1) is then compared to that result and if they
  1529                          					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1530                          					; the loop is done
  1531  94c7 208b9b             	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
  1532  94ca a598               	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
  1533  94cc 48                 	PHA				; push on stack
  1534  94cd a597               	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
  1535  94cf 48                 	PHA				; push on stack
  1536  94d0 a981               	LDA	#TK_FOR		; get FOR token
  1537  94d2 48                 	PHA				; push on stack
  1538                          
  1539                          ; interpreter inner loop
  1540                          
  1541                          LAB_15C2
  1542  94d3 202b95             	JSR	LAB_1629		; do CRTL-C check vector
  1543  94d6 a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  1544  94d8 a4c4               	LDY	Bpntrh		; get BASIC execute pointer high byte
  1545                          
  1546  94da a688               	LDX	Clineh		; continue line is $FFxx for immediate mode
  1547                          					; ($00xx for RUN from immediate mode)
  1548  94dc e8                 	INX				; increment it (now $00 if immediate mode)
  1549  94dd f004               	BEQ	LAB_15D1		; branch if null (immediate mode)
  1550                          
  1551  94df 858b               	STA	Cpntrl		; save continue pointer low byte
  1552  94e1 848c               	STY	Cpntrh		; save continue pointer high byte
  1553                          LAB_15D1
  1554  94e3 a000               	LDY	#$00			; clear index
  1555  94e5 b1c3               	LDA	(Bpntrl),Y		; get next byte
  1556  94e7 f007               	BEQ	LAB_15DC		; branch if null [EOL]
  1557                          
  1558  94e9 c93a               	CMP	#':'			; compare with ":"
  1559  94eb f01d               	BEQ	LAB_15F6		; branch if = (statement separator)
  1560                          
  1561                          LAB_15D9
  1562  94ed 4c149c             	JMP	LAB_SNER		; else syntax error then warm start
  1563                          
  1564                          					; have reached [EOL]
  1565                          LAB_15DC
  1566  94f0 a002               	LDY	#$02			; set index
  1567  94f2 b1c3               	LDA	(Bpntrl),Y		; get next line pointer high byte
  1568  94f4 18                 	CLC				; clear carry for no "BREAK" message
  1569  94f5 f056               	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
  1570                          					; marker)
  1571                          
  1572  94f7 c8                 	INY				; increment index
  1573  94f8 b1c3               	LDA	(Bpntrl),Y		; get line # low byte
  1574  94fa 8587               	STA	Clinel		; save current line low byte
  1575  94fc c8                 	INY				; increment index
  1576  94fd b1c3               	LDA	(Bpntrl),Y		; get line # high byte
  1577  94ff 8588               	STA	Clineh		; save current line high byte
  1578  9501 98                 	TYA				; A now = 4
  1579  9502 65c3               	ADC	Bpntrl		; add BASIC execute pointer low byte
  1580  9504 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  1581  9506 9002               	BCC	LAB_15F6		; branch if no overflow
  1582                          
  1583  9508 e6c4               	INC	Bpntrh		; else increment BASIC execute pointer high byte
  1584                          LAB_15F6
  1585  950a 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  1586                          
  1587                          LAB_15F9
  1588  950d 201395             	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
  1589                          
  1590                          LAB_15FC
  1591  9510 4cd394             	JMP	LAB_15C2		; loop
  1592                          
  1593                          ; interpret BASIC code from (Bpntrl)
  1594                          
  1595                          LAB_15FF
  1596  9513 f054               	BEQ	LAB_1628		; exit if zero [EOL]
  1597                          
  1598                          LAB_1602
  1599  9515 0a                 	ASL				; *2 bytes per vector and normalise token
  1600  9516 b003               	BCS	LAB_1609		; branch if was token
  1601                          
  1602  9518 4ccb97             	JMP	LAB_LET		; else go do implied LET
  1603                          
  1604                          LAB_1609
  1605  951b c956               	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
  1606  951d b0ce               	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
  1607                          					; only tokens before TAB can start a line
  1608  951f a8                 	TAY				; copy to index
  1609  9520 b90bb2             	LDA	LAB_CTBL+1,Y	; get vector high byte
  1610  9523 48                 	PHA				; onto stack
  1611  9524 b90ab2             	LDA	LAB_CTBL,Y		; get vector low byte
  1612  9527 48                 	PHA				; onto stack
  1613  9528 4cbc00             	JMP	LAB_IGBY		; jump to increment and scan memory
  1614                          					; then "return" to vector
  1615                          
  1616                          ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1617                          ; key press is detected.
  1618                          
  1619                          LAB_1629
  1620  952b 6c0303             	JMP	(VEC_CC)		; ctrl c check vector
  1621                          
  1622                          ; if there was a key press it gets back here ..
  1623                          
  1624                          LAB_1636
  1625  952e c903               	CMP	#$03			; compare with CTRL-C
  1626                          
  1627                          ; perform STOP
  1628                          
  1629                          LAB_STOP
  1630  9530 b001               	BCS	LAB_163B		; branch if token follows STOP
  1631                          					; else just END
  1632                          ; END
  1633                          
  1634                          LAB_END
  1635  9532 18                 	CLC				; clear the carry, indicate a normal program end
  1636                          LAB_163B
  1637  9533 d067               	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
  1638                          
  1639  9535 a5c4               	LDA	Bpntrh		; get the BASIC execute pointer high byte
  1640  9537 4903               	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
  1641  9539 f010               	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
  1642                          					; (can't continue in immediate mode)
  1643                          
  1644                          					; else ..
  1645  953b 4903               	EOR	#>Ibuffs		; correct the bits
  1646  953d a4c3               	LDY	Bpntrl		; get BASIC execute pointer low byte
  1647  953f 848b               	STY	Cpntrl		; save continue pointer low byte
  1648  9541 858c               	STA	Cpntrh		; save continue pointer high byte
  1649                          LAB_1647
  1650  9543 a587               	LDA	Clinel		; get current line low byte
  1651  9545 a488               	LDY	Clineh		; get current line high byte
  1652  9547 8589               	STA	Blinel		; save break line low byte
  1653  9549 848a               	STY	Blineh		; save break line high byte
  1654                          LAB_164F
  1655  954b 68                 	PLA				; pull return address low
  1656  954c 68                 	PLA				; pull return address high
  1657                          LAB_1651
  1658  954d 9007               	BCC	LAB_165E		; if was program end just do warm start
  1659                          
  1660                          					; else ..
  1661  954f a9f3               	LDA	#<LAB_BMSG		; point to "Break" low byte
  1662  9551 a0b7               	LDY	#>LAB_BMSG		; point to "Break" high byte
  1663  9553 4c5a91             	JMP	LAB_1269		; print "Break" and do warm start
  1664                          
  1665                          LAB_165E
  1666  9556 4c6591             	JMP	LAB_1274		; go do warm start
  1667                          
  1668                          ; perform RESTORE
  1669                          
  1670                          LAB_RESTORE
  1671  9559 d00f               	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
  1672                          
  1673                          LAB_161A
  1674  955b 38                 	SEC				; set carry for subtract
  1675  955c a579               	LDA	Smeml			; get start of mem low byte
  1676  955e e901               	SBC	#$01			; -1
  1677  9560 a47a               	LDY	Smemh			; get start of mem high byte
  1678  9562 b001               	BCS	LAB_1624		; branch if no underflow
  1679                          
  1680                          LAB_uflow
  1681  9564 88                 	DEY				; else decrement high byte
  1682                          LAB_1624
  1683  9565 858f               	STA	Dptrl			; save DATA pointer low byte
  1684  9567 8490               	STY	Dptrh			; save DATA pointer high byte
  1685                          LAB_1628
  1686  9569 60                 	RTS
  1687                          
  1688                          					; is RESTORE n
  1689                          LAB_RESTOREn
  1690  956a 206c97             	JSR	LAB_GFPN		; get fixed-point number into temp integer
  1691  956d 20b796             	JSR	LAB_SNBL		; scan for next BASIC line
  1692  9570 a588               	LDA	Clineh		; get current line high byte
  1693  9572 c512               	CMP	Itemph		; compare with temporary integer high byte
  1694  9574 b00b               	BCS	LAB_reset_search	; branch if >= (start search from beginning)
  1695                          
  1696  9576 98                 	TYA				; else copy line index to A
  1697  9577 38                 	SEC				; set carry (+1)
  1698  9578 65c3               	ADC	Bpntrl		; add BASIC execute pointer low byte
  1699  957a a6c4               	LDX	Bpntrh		; get BASIC execute pointer high byte
  1700  957c 9007               	BCC	LAB_go_search	; branch if no overflow to high byte
  1701                          
  1702  957e e8                 	INX				; increment high byte
  1703  957f b004               	BCS	LAB_go_search	; branch always (can never be carry clear)
  1704                          
  1705                          ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1706                          
  1707                          LAB_reset_search
  1708  9581 a579               	LDA	Smeml			; get start of mem low byte
  1709  9583 a67a               	LDX	Smemh			; get start of mem high byte
  1710                          
  1711                          ; search for line # in temp (Itempl/Itemph) from (AX)
  1712                          
  1713                          LAB_go_search
  1714                          
  1715  9585 203f93             	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1716  9588 b003               	BCS	LAB_line_found	; if carry set go set pointer
  1717                          
  1718  958a 4c8996             	JMP	LAB_16F7		; else go do "Undefined statement" error
  1719                          
  1720                          LAB_line_found
  1721                          					; carry already set for subtract
  1722  958d a5aa               	LDA	Baslnl		; get pointer low byte
  1723  958f e901               	SBC	#$01			; -1
  1724  9591 a4ab               	LDY	Baslnh		; get pointer high byte
  1725  9593 b0d0               	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
  1726                          
  1727  9595 90cd               	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
  1728                          					; return (branch always)
  1729                          
  1730                          ; perform NULL
  1731                          
  1732                          LAB_NULL
  1733  9597 209ea4             	JSR	LAB_GTBY		; get byte parameter
  1734  959a 860d               	STX	Nullct		; save new NULL count
  1735                          LAB_167A
  1736  959c 60                 	RTS
  1737                          
  1738                          ; perform CONT
  1739                          
  1740                          LAB_CONT
  1741  959d d0fd               	BNE	LAB_167A		; if following byte exit to do syntax error
  1742                          
  1743  959f a48c               	LDY	Cpntrh		; get continue pointer high byte
  1744  95a1 d005               	BNE	LAB_166C		; go do continue if we can
  1745                          
  1746  95a3 a21e               	LDX	#$1E			; error code $1E ("Can't continue" error)
  1747  95a5 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  1748                          
  1749                          					; we can continue so ..
  1750                          LAB_166C
  1751  95a8 a993               	LDA	#TK_ON		; set token for ON
  1752  95aa 2026af             	JSR	LAB_IRQ		; set IRQ flags
  1753  95ad a993               	LDA	#TK_ON		; set token for ON
  1754  95af 2029af             	JSR	LAB_NMI		; set NMI flags
  1755                          
  1756  95b2 84c4               	STY	Bpntrh		; save BASIC execute pointer high byte
  1757  95b4 a58b               	LDA	Cpntrl		; get continue pointer low byte
  1758  95b6 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  1759  95b8 a589               	LDA	Blinel		; get break line low byte
  1760  95ba a48a               	LDY	Blineh		; get break line high byte
  1761  95bc 8587               	STA	Clinel		; set current line low byte
  1762  95be 8488               	STY	Clineh		; set current line high byte
  1763  95c0 60                 	RTS
  1764                          
  1765                          ; perform RUN
  1766                          
  1767                          LAB_RUN
  1768  95c1 d003               	BNE	LAB_1696		; branch if RUN n
  1769  95c3 4c7c93             	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
  1770                          					; return
  1771                          
  1772                          ; does RUN n
  1773                          
  1774                          LAB_1696
  1775  95c6 208993             	JSR	LAB_147A		; go do "CLEAR"
  1776  95c9 f02e               	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1777                          
  1778                          ; perform DO
  1779                          
  1780                          LAB_DO
  1781  95cb a905               	LDA	#$05			; need 5 bytes for DO
  1782  95cd 200e91             	JSR	LAB_1212		; check room on stack for A bytes
  1783  95d0 a5c4               	LDA	Bpntrh		; get BASIC execute pointer high byte
  1784  95d2 48                 	PHA				; push on stack
  1785  95d3 a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  1786  95d5 48                 	PHA				; push on stack
  1787  95d6 a588               	LDA	Clineh		; get current line high byte
  1788  95d8 48                 	PHA				; push on stack
  1789  95d9 a587               	LDA	Clinel		; get current line low byte
  1790  95db 48                 	PHA				; push on stack
  1791  95dc a99d               	LDA	#TK_DO		; token for DO
  1792  95de 48                 	PHA				; push on stack
  1793  95df 20c200             	JSR	LAB_GBYT		; scan memory
  1794  95e2 4cd394             	JMP	LAB_15C2		; go do interpreter inner loop
  1795                          
  1796                          ; perform GOSUB
  1797                          
  1798                          LAB_GOSUB
  1799  95e5 a905               	LDA	#$05			; need 5 bytes for GOSUB
  1800  95e7 200e91             	JSR	LAB_1212		; check room on stack for A bytes
  1801  95ea a5c4               	LDA	Bpntrh		; get BASIC execute pointer high byte
  1802  95ec 48                 	PHA				; push on stack
  1803  95ed a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  1804  95ef 48                 	PHA				; push on stack
  1805  95f0 a588               	LDA	Clineh		; get current line high byte
  1806  95f2 48                 	PHA				; push on stack
  1807  95f3 a587               	LDA	Clinel		; get current line low byte
  1808  95f5 48                 	PHA				; push on stack
  1809  95f6 a98d               	LDA	#TK_GOSUB		; token for GOSUB
  1810  95f8 48                 	PHA				; push on stack
  1811                          LAB_16B0
  1812  95f9 20c200             	JSR	LAB_GBYT		; scan memory
  1813  95fc 200296             	JSR	LAB_GOTO		; perform GOTO n
  1814  95ff 4cd394             	JMP	LAB_15C2		; go do interpreter inner loop
  1815                          					; (can't RTS, we used the stack!)
  1816                          
  1817                          ; perform GOTO
  1818                          
  1819                          LAB_GOTO
  1820  9602 206c97             	JSR	LAB_GFPN		; get fixed-point number into temp integer
  1821  9605 20b796             	JSR	LAB_SNBL		; scan for next BASIC line
  1822  9608 a588               	LDA	Clineh		; get current line high byte
  1823  960a c512               	CMP	Itemph		; compare with temporary integer high byte
  1824  960c b00b               	BCS	LAB_16D0		; branch if >= (start search from beginning)
  1825                          
  1826  960e 98                 	TYA				; else copy line index to A
  1827  960f 38                 	SEC				; set carry (+1)
  1828  9610 65c3               	ADC	Bpntrl		; add BASIC execute pointer low byte
  1829  9612 a6c4               	LDX	Bpntrh		; get BASIC execute pointer high byte
  1830  9614 9007               	BCC	LAB_16D4		; branch if no overflow to high byte
  1831                          
  1832  9616 e8                 	INX				; increment high byte
  1833  9617 b004               	BCS	LAB_16D4		; branch always (can never be carry)
  1834                          
  1835                          ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1836                          
  1837                          LAB_16D0
  1838  9619 a579               	LDA	Smeml			; get start of mem low byte
  1839  961b a67a               	LDX	Smemh			; get start of mem high byte
  1840                          
  1841                          ; search for line # in temp (Itempl/Itemph) from (AX)
  1842                          
  1843                          LAB_16D4
  1844  961d 203f93             	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1845  9620 9067               	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
  1846                          					; (unspecified statement)
  1847                          
  1848                          					; carry already set for subtract
  1849  9622 a5aa               	LDA	Baslnl		; get pointer low byte
  1850  9624 e901               	SBC	#$01			; -1
  1851  9626 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  1852  9628 a5ab               	LDA	Baslnh		; get pointer high byte
  1853  962a e900               	SBC	#$00			; subtract carry
  1854  962c 85c4               	STA	Bpntrh		; save BASIC execute pointer high byte
  1855                          LAB_16E5
  1856  962e 60                 	RTS
  1857                          
  1858                          LAB_DONOK
  1859  962f a222               	LDX	#$22			; error code $22 ("LOOP without DO" error)
  1860  9631 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  1861                          
  1862                          ; perform LOOP
  1863                          
  1864                          LAB_LOOP
  1865  9634 a8                 	TAY				; save following token
  1866  9635 ba                 	TSX				; copy stack pointer
  1867  9636 bd0301             	LDA	LAB_STAK+3,X	; get token byte from stack
  1868  9639 c99d               	CMP	#TK_DO		; compare with DO token
  1869  963b d0f2               	BNE	LAB_DONOK		; branch if no matching DO
  1870                          
  1871  963d e8                 	INX				; dump calling routine return address
  1872  963e e8                 	INX				; dump calling routine return address
  1873  963f 9a                 	TXS				; correct stack
  1874  9640 98                 	TYA				; get saved following token back
  1875  9641 f020               	BEQ	LoopAlways		; if no following token loop forever
  1876                          					; (stack pointer in X)
  1877                          
  1878  9643 c93a               	CMP	#':'			; could be ':'
  1879  9645 f01c               	BEQ	LoopAlways		; if :... loop forever
  1880                          
  1881  9647 e9b3               	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
  1882  9649 aa                 	TAX				; copy to X (if it was UNTIL then Y will be correct)
  1883  964a f004               	BEQ	DoRest		; branch if was UNTIL
  1884                          
  1885  964c ca                 	DEX				; decrement result
  1886  964d d062               	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
  1887                          					; only if the token was WHILE will this fail
  1888                          
  1889  964f ca                 	DEX				; set invert result byte
  1890                          DoRest
  1891  9650 8698               	STX	Frnxth		; save invert result byte
  1892  9652 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  1893  9655 20f39a             	JSR	LAB_EVEX		; evaluate expression
  1894  9658 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  1895  965a f002               	BEQ	DoCmp			; if =0 go do straight compare
  1896                          
  1897  965c a9ff               	LDA	#$FF			; else set all bits
  1898                          DoCmp
  1899  965e ba                 	TSX				; copy stack pointer
  1900  965f 4598               	EOR	Frnxth		; EOR with invert byte
  1901  9661 d01a               	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
  1902                          
  1903                          					; loop condition wasn't met so do it again
  1904                          LoopAlways
  1905  9663 bd0201             	LDA	LAB_STAK+2,X	; get current line low byte
  1906  9666 8587               	STA	Clinel		; save current line low byte
  1907  9668 bd0301             	LDA	LAB_STAK+3,X	; get current line high byte
  1908  966b 8588               	STA	Clineh		; save current line high byte
  1909  966d bd0401             	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
  1910  9670 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  1911  9672 bd0501             	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
  1912  9675 85c4               	STA	Bpntrh		; save BASIC execute pointer high byte
  1913  9677 20c200             	JSR	LAB_GBYT		; scan memory
  1914  967a 4cd394             	JMP	LAB_15C2		; go do interpreter inner loop
  1915                          
  1916                          					; clear stack and back to interpreter loop
  1917                          LoopDone
  1918  967d e8                 	INX				; dump DO token
  1919  967e e8                 	INX				; dump current line low byte
  1920  967f e8                 	INX				; dump current line high byte
  1921  9680 e8                 	INX				; dump BASIC execute pointer low byte
  1922  9681 e8                 	INX				; dump BASIC execute pointer high byte
  1923  9682 9a                 	TXS				; correct stack
  1924  9683 4ca396             	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
  1925                          
  1926                          ; do the return without gosub error
  1927                          
  1928                          LAB_16F4
  1929  9686 a204               	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
  1930  9688 2c                 	!text	$2C			; makes next line BIT LAB_0EA2
  1931                          
  1932                          LAB_16F7				; do undefined statement error
  1933  9689 a20e               	LDX	#$0E			; error code $0E ("Undefined statement" error)
  1934  968b 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  1935                          
  1936                          ; perform RETURN
  1937                          
  1938                          LAB_RETURN
  1939  968e d09e               	BNE	LAB_16E5		; exit if following token (to allow syntax error)
  1940                          
  1941                          LAB_16E8
  1942  9690 68                 	PLA				; dump calling routine return address
  1943  9691 68                 	PLA				; dump calling routine return address
  1944  9692 68                 	PLA				; pull token
  1945  9693 c98d               	CMP	#TK_GOSUB		; compare with GOSUB token
  1946  9695 d0ef               	BNE	LAB_16F4		; branch if no matching GOSUB
  1947                          
  1948                          LAB_16FF
  1949  9697 68                 	PLA				; pull current line low byte
  1950  9698 8587               	STA	Clinel		; save current line low byte
  1951  969a 68                 	PLA				; pull current line high byte
  1952  969b 8588               	STA	Clineh		; save current line high byte
  1953  969d 68                 	PLA				; pull BASIC execute pointer low byte
  1954  969e 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  1955  96a0 68                 	PLA				; pull BASIC execute pointer high byte
  1956  96a1 85c4               	STA	Bpntrh		; save BASIC execute pointer high byte
  1957                          
  1958                          					; now do the DATA statement as we could be returning into
  1959                          					; the middle of an ON <var> GOSUB n,m,p,q line
  1960                          					; (the return address used by the DATA statement is the one
  1961                          					; pushed before the GOSUB was executed!)
  1962                          
  1963                          ; perform DATA
  1964                          
  1965                          LAB_DATA
  1966  96a3 20b496             	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1967                          
  1968                          					; set BASIC execute pointer
  1969                          LAB_170F
  1970  96a6 98                 	TYA				; copy index to A
  1971  96a7 18                 	CLC				; clear carry for add
  1972  96a8 65c3               	ADC	Bpntrl		; add BASIC execute pointer low byte
  1973  96aa 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  1974  96ac 9002               	BCC	LAB_1719		; skip next if no carry
  1975                          
  1976  96ae e6c4               	INC	Bpntrh		; else increment BASIC execute pointer high byte
  1977                          LAB_1719
  1978  96b0 60                 	RTS
  1979                          
  1980                          LAB_16FC
  1981  96b1 4c149c             	JMP	LAB_SNER		; do syntax error then warm start
  1982                          
  1983                          ; scan for next BASIC statement ([:] or [EOL])
  1984                          ; returns Y as index to [:] or [EOL]
  1985                          
  1986                          LAB_SNBS
  1987  96b4 a23a               	LDX	#':'			; set look for character = ":"
  1988  96b6 2c                 	!text	$2C			; makes next line BIT $00A2
  1989                          
  1990                          ; scan for next BASIC line
  1991                          ; returns Y as index to [EOL]
  1992                          
  1993                          LAB_SNBL
  1994  96b7 a200               	LDX	#$00			; set alt search character = [EOL]
  1995  96b9 a000               	LDY	#$00			; set search character = [EOL]
  1996  96bb 845c               	STY	Asrch			; store search character
  1997                          LAB_1725
  1998  96bd 8a                 	TXA				; get alt search character
  1999  96be 455c               	EOR	Asrch			; toggle search character, effectively swap with $00
  2000  96c0 855c               	STA	Asrch			; save swapped search character
  2001                          LAB_172D
  2002  96c2 b1c3               	LDA	(Bpntrl),Y		; get next byte
  2003  96c4 f0ea               	BEQ	LAB_1719		; exit if null [EOL]
  2004                          
  2005  96c6 c55c               	CMP	Asrch			; compare with search character
  2006  96c8 f0e6               	BEQ	LAB_1719		; exit if found
  2007                          
  2008  96ca c8                 	INY				; increment index
  2009  96cb c922               	CMP	#$22			; compare current character with open quote
  2010  96cd d0f3               	BNE	LAB_172D		; if not open quote go get next character
  2011                          
  2012  96cf f0ec               	BEQ	LAB_1725		; if found go swap search character for alt search character
  2013                          
  2014                          ; perform IF
  2015                          
  2016                          LAB_IF
  2017  96d1 20f39a             	JSR	LAB_EVEX		; evaluate the expression
  2018  96d4 20c200             	JSR	LAB_GBYT		; scan memory
  2019  96d7 c9b0               	CMP	#TK_THEN		; compare with THEN token
  2020  96d9 f011               	BEQ	LAB_174B		; if it was THEN go do IF
  2021                          
  2022                          					; wasn't IF .. THEN so must be IF .. GOTO
  2023  96db c989               	CMP	#TK_GOTO		; compare with GOTO token
  2024  96dd d0d2               	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
  2025                          
  2026  96df a6c3               	LDX	Bpntrl		; save the basic pointer low byte
  2027  96e1 a4c4               	LDY	Bpntrh		; save the basic pointer high byte
  2028  96e3 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  2029  96e6 b0c9               	BCS	LAB_16FC		; if not numeric go do syntax error
  2030                          
  2031  96e8 86c3               	STX	Bpntrl		; restore the basic pointer low byte
  2032  96ea 84c4               	STY	Bpntrh		; restore the basic pointer high byte
  2033                          LAB_174B
  2034  96ec a5ac               	LDA	FAC1_e		; get FAC1 exponent
  2035  96ee f01b               	BEQ	LAB_174E		; if the result was zero go look for an ELSE
  2036                          
  2037  96f0 20bc00             	JSR	LAB_IGBY		; else increment and scan memory
  2038  96f3 b003               	BCS	LAB_174D		; if not numeric go do var or keyword
  2039                          
  2040                          LAB_174C
  2041  96f5 4c0296             	JMP	LAB_GOTO		; else was numeric so do GOTO n
  2042                          
  2043                          					; is var or keyword
  2044                          LAB_174D
  2045  96f8 c990               	CMP	#TK_RETURN		; compare the byte with the token for RETURN
  2046  96fa d003               	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
  2047                          					; and return to this code to process any following code
  2048                          
  2049  96fc 4c1595             	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
  2050                          					; but don't return here
  2051                          
  2052                          LAB_174G
  2053  96ff 201395             	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2054                          
  2055                          ; the IF was executed and there may be a following ELSE so the code needs to return
  2056                          ; here to check and ignore the ELSE if present
  2057                          
  2058  9702 a000               	LDY	#$00			; clear the index
  2059  9704 b1c3               	LDA	(Bpntrl),Y		; get the next BASIC byte
  2060  9706 c9ac               	CMP	#TK_ELSE		; compare it with the token for ELSE
  2061  9708 f099               	BEQ	LAB_DATA		; if ELSE ignore the following statement
  2062                          
  2063                          ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2064                          ; following ELSE will, correctly, cause a syntax error
  2065                          
  2066  970a 60                 	RTS				; else return to the interpreter inner loop
  2067                          
  2068                          ; perform ELSE after IF
  2069                          
  2070                          LAB_174E
  2071  970b a000               	LDY	#$00			; clear the BASIC byte index
  2072  970d a201               	LDX	#$01			; clear the nesting depth
  2073                          LAB_1750
  2074  970f c8                 	INY				; increment the BASIC byte index
  2075  9710 b1c3               	LDA	(Bpntrl),Y		; get the next BASIC byte
  2076  9712 f00f               	BEQ	LAB_1753		; if EOL go add the pointer and return
  2077                          
  2078  9714 c98b               	CMP	#TK_IF		; compare the byte with the token for IF
  2079  9716 d003               	BNE	LAB_1752		; if not IF token skip the depth increment
  2080                          
  2081  9718 e8                 	INX				; else increment the nesting depth ..
  2082  9719 d0f4               	BNE	LAB_1750		; .. and continue looking
  2083                          
  2084                          LAB_1752
  2085  971b c9ac               	CMP	#TK_ELSE		; compare the byte with the token for ELSE
  2086  971d d0f0               	BNE	LAB_1750		; if not ELSE token continue looking
  2087                          
  2088  971f ca                 	DEX				; was ELSE so decrement the nesting depth
  2089  9720 d0ed               	BNE	LAB_1750		; loop if still nested
  2090                          
  2091  9722 c8                 	INY				; increment the BASIC byte index past the ELSE
  2092                          
  2093                          ; found the matching ELSE, now do <{n|statement}>
  2094                          
  2095                          LAB_1753
  2096  9723 98                 	TYA				; else copy line index to A
  2097  9724 18                 	CLC				; clear carry for add
  2098  9725 65c3               	ADC	Bpntrl		; add the BASIC execute pointer low byte
  2099  9727 85c3               	STA	Bpntrl		; save the BASIC execute pointer low byte
  2100  9729 9002               	BCC	LAB_1754		; branch if no overflow to high byte
  2101                          
  2102  972b e6c4               	INC	Bpntrh		; else increment the BASIC execute pointer high byte
  2103                          LAB_1754
  2104  972d 20c200             	JSR	LAB_GBYT		; scan memory
  2105  9730 90c3               	BCC	LAB_174C		; if numeric do GOTO n
  2106                          					; the code will return to the interpreter loop at the
  2107                          					; tail end of the GOTO <n>
  2108                          
  2109  9732 4c1395             	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
  2110                          					; the code will return to the interpreter loop at the
  2111                          					; tail end of the <statement>
  2112                          
  2113                          ; perform REM, skip (rest of) line
  2114                          
  2115                          LAB_REM
  2116  9735 20b796             	JSR	LAB_SNBL		; scan for next BASIC line
  2117  9738 4ca696             	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
  2118                          
  2119                          LAB_16FD
  2120  973b 4c149c             	JMP	LAB_SNER		; do syntax error then warm start
  2121                          
  2122                          ; perform ON
  2123                          
  2124                          LAB_ON
  2125  973e c9a9               	CMP	#TK_IRQ		; was it IRQ token ?
  2126  9740 d003               	BNE	LAB_NOIN		; if not go check NMI
  2127                          
  2128  9742 4c4aaf             	JMP	LAB_SIRQ		; else go set-up IRQ
  2129                          
  2130                          LAB_NOIN
  2131  9745 c9aa               	CMP	#TK_NMI		; was it NMI token ?
  2132  9747 d003               	BNE	LAB_NONM		; if not go do normal ON command
  2133                          
  2134  9749 4c4eaf             	JMP	LAB_SNMI		; else go set-up NMI
  2135                          
  2136                          LAB_NONM
  2137  974c 209ea4             	JSR	LAB_GTBY		; get byte parameter
  2138  974f 48                 	PHA				; push GOTO/GOSUB token
  2139  9750 c98d               	CMP	#TK_GOSUB		; compare with GOSUB token
  2140  9752 f004               	BEQ	LAB_176B		; branch if GOSUB
  2141                          
  2142  9754 c989               	CMP	#TK_GOTO		; compare with GOTO token
  2143                          LAB_1767
  2144  9756 d0e3               	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
  2145                          
  2146                          
  2147                          ; next character was GOTO or GOSUB
  2148                          
  2149                          LAB_176B
  2150  9758 c6af               	DEC	FAC1_3		; decrement index (byte value)
  2151  975a d004               	BNE	LAB_1773		; branch if not zero
  2152                          
  2153  975c 68                 	PLA				; pull GOTO/GOSUB token
  2154  975d 4c1595             	JMP	LAB_1602		; go execute it
  2155                          
  2156                          LAB_1773
  2157  9760 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  2158  9763 206c97             	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
  2159                          					; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2160                          					; just BNE LAB_176B for the loop. should be quicker ..
  2161                          					; no we can't, what if we meet a colon or [EOL]?)
  2162  9766 c92c               	CMP	#$2C			; compare next character with ","
  2163  9768 f0ee               	BEQ	LAB_176B		; loop if ","
  2164                          
  2165                          LAB_177E
  2166  976a 68                 	PLA				; else pull keyword token (run out of options)
  2167                          					; also dump +/-1 pointer low byte and exit
  2168                          LAB_177F
  2169  976b 60                 	RTS
  2170                          
  2171                          ; takes n * 106 + 11 cycles where n is the number of digits
  2172                          
  2173                          ; get fixed-point number into temp integer
  2174                          
  2175                          LAB_GFPN
  2176  976c a200               	LDX	#$00			; clear reg
  2177  976e 8611               	STX	Itempl		; clear temporary integer low byte
  2178                          LAB_1785
  2179  9770 8612               	STX	Itemph		; save temporary integer high byte
  2180  9772 b0f7               	BCS	LAB_177F		; return if carry set, end of scan, character was
  2181                          					; not 0-9
  2182                          
  2183  9774 e019               	CPX	#$19			; compare high byte with $19
  2184  9776 a8                 	TAY				; ensure Zb = 0 if the branch is taken
  2185  9777 b0dd               	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
  2186                          					; bit does *$0A, = 64000, compare at target will fail
  2187                          					; and do syntax error
  2188                          
  2189  9779 e92f               	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
  2190  977b a8                 	TAY				; copy binary digit
  2191  977c a511               	LDA	Itempl		; get temporary integer low byte
  2192  977e 0a                 	ASL				; *2 low byte
  2193  977f 2612               	ROL	Itemph		; *2 high byte
  2194  9781 0a                 	ASL				; *2 low byte
  2195  9782 2612               	ROL	Itemph		; *2 high byte, *4
  2196  9784 6511               	ADC	Itempl		; + low byte, *5
  2197  9786 8511               	STA	Itempl		; save it
  2198  9788 8a                 	TXA				; get high byte copy to A
  2199  9789 6512               	ADC	Itemph		; + high byte, *5
  2200  978b 0611               	ASL	Itempl		; *2 low byte, *10d
  2201  978d 2a                 	ROL				; *2 high byte, *10d
  2202  978e aa                 	TAX				; copy high byte back to X
  2203  978f 98                 	TYA				; get binary digit back
  2204  9790 6511               	ADC	Itempl		; add number low byte
  2205  9792 8511               	STA	Itempl		; save number low byte
  2206  9794 9001               	BCC	LAB_17B3		; if no overflow to high byte get next character
  2207                          
  2208  9796 e8                 	INX				; else increment high byte
  2209                          LAB_17B3
  2210  9797 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  2211  979a 4c7097             	JMP	LAB_1785		; loop for next character
  2212                          
  2213                          ; perform DEC
  2214                          
  2215                          LAB_DEC
  2216  979d a9e7               	LDA	#<LAB_2AFD		; set -1 pointer low byte
  2217  979f 2c                 	!text	$2C			; BIT abs to skip the LDA below
  2218                          
  2219                          ; perform INC
  2220                          
  2221                          LAB_INC
  2222  97a0 a9e3               	LDA	#<LAB_259C		; set 1 pointer low byte
  2223                          LAB_17B5
  2224  97a2 48                 	PHA				; save +/-1 pointer low byte
  2225                          LAB_17B7
  2226  97a3 20bc9d             	JSR	LAB_GVAR		; get var address
  2227  97a6 a65f               	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
  2228  97a8 301e               	BMI	IncrErr		; exit if string
  2229                          
  2230  97aa 8597               	STA	Lvarpl		; save var address low byte
  2231  97ac 8498               	STY	Lvarph		; save var address high byte
  2232  97ae 208fa8             	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  2233  97b1 68                 	PLA				; get +/-1 pointer low byte
  2234  97b2 48                 	PHA				; save +/-1 pointer low byte
  2235  97b3 a0b1               	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
  2236  97b5 20d0a5             	JSR	LAB_246C		; add (AY) to FAC1
  2237  97b8 20b5a8             	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
  2238                          
  2239  97bb 20c200             	JSR	LAB_GBYT		; scan memory
  2240  97be c92c               	CMP	#','			; compare with ","
  2241  97c0 d0a8               	BNE	LAB_177E		; exit if not "," (either end or error)
  2242                          
  2243                          					; was "," so another INCR variable to do
  2244  97c2 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  2245  97c5 4ca397             	JMP	LAB_17B7		; go do next var
  2246                          
  2247                          IncrErr
  2248  97c8 4cee9a             	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
  2249                          
  2250                          ; perform LET
  2251                          
  2252                          LAB_LET
  2253  97cb 20bc9d             	JSR	LAB_GVAR		; get var address
  2254  97ce 8597               	STA	Lvarpl		; save var address low byte
  2255  97d0 8498               	STY	Lvarph		; save var address high byte
  2256  97d2 a9c1               	LDA	#TK_EQUAL		; get = token
  2257  97d4 20039c             	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2258  97d7 a55f               	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
  2259  97d9 48                 	PHA				; push data type flag
  2260  97da 20f39a             	JSR	LAB_EVEX		; evaluate expression
  2261  97dd 68                 	PLA				; pop data type flag
  2262  97de 2a                 	ROL				; set carry if type = string
  2263  97df 20e59a             	JSR	LAB_CKTM		; type match check, set C for string
  2264  97e2 d003               	BNE	LAB_17D5		; branch if string
  2265                          
  2266  97e4 4cb5a8             	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2267                          
  2268                          ; string LET
  2269                          
  2270                          LAB_17D5
  2271  97e7 a002               	LDY	#$02			; set index to pointer high byte
  2272  97e9 b1ae               	LDA	(des_pl),Y		; get string pointer high byte
  2273  97eb c582               	CMP	Sstorh		; compare bottom of string space high byte
  2274  97ed 9017               	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2275                          
  2276  97ef d007               	BNE	LAB_17E6		; branch if >
  2277                          					; else was equal so compare low bytes
  2278  97f1 88                 	DEY				; decrement index
  2279  97f2 b1ae               	LDA	(des_pl),Y		; get pointer low byte
  2280  97f4 c581               	CMP	Sstorl		; compare bottom of string space low byte
  2281  97f6 900e               	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  2282                          
  2283                          					; pointer was >= to bottom of string space pointer
  2284                          LAB_17E6
  2285  97f8 a4af               	LDY	des_ph		; get descriptor pointer high byte
  2286  97fa c47c               	CPY	Svarh			; compare start of vars high byte
  2287  97fc 9008               	BCC	LAB_17F4		; branch if less (descriptor is on stack)
  2288                          
  2289  97fe d00d               	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
  2290                          
  2291                          					; else high bytes were equal so ..
  2292  9800 a5ae               	LDA	des_pl		; get descriptor pointer low byte
  2293  9802 c57b               	CMP	Svarl			; compare start of vars low byte
  2294  9804 b007               	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
  2295                          
  2296                          LAB_17F4
  2297  9806 a5ae               	LDA	des_pl		; get descriptor pointer low byte
  2298  9808 a4af               	LDY	des_ph		; get descriptor pointer high byte
  2299  980a 4c2398             	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
  2300                          
  2301                          					; make space and copy string
  2302                          LAB_17FB
  2303  980d a000               	LDY	#$00			; index to length
  2304  980f b1ae               	LDA	(des_pl),Y		; get string length
  2305  9811 2044a1             	JSR	LAB_209C		; copy string
  2306  9814 a59e               	LDA	des_2l		; get descriptor pointer low byte
  2307  9816 a49f               	LDY	des_2h		; get descriptor pointer high byte
  2308  9818 85b8               	STA	ssptr_l		; save descriptor pointer low byte
  2309  981a 84b9               	STY	ssptr_h		; save descriptor pointer high byte
  2310  981c 2023a3             	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  2311  981f a9ac               	LDA	#<FAC1_e		; set descriptor pointer low byte
  2312  9821 a000               	LDY	#>FAC1_e		; get descriptor pointer high byte
  2313                          
  2314                          					; clean stack and assign value to string variable
  2315                          LAB_1811
  2316  9823 859e               	STA	des_2l		; save descriptor_2 pointer low byte
  2317  9825 849f               	STY	des_2h		; save descriptor_2 pointer high byte
  2318  9827 2085a3             	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  2319  982a a000               	LDY	#$00			; index to length
  2320  982c b19e               	LDA	(des_2l),Y		; get string length
  2321  982e 9197               	STA	(Lvarpl),Y		; copy to let string variable
  2322  9830 c8                 	INY				; index to string pointer low byte
  2323  9831 b19e               	LDA	(des_2l),Y		; get string pointer low byte
  2324  9833 9197               	STA	(Lvarpl),Y		; copy to let string variable
  2325  9835 c8                 	INY				; index to string pointer high byte
  2326  9836 b19e               	LDA	(des_2l),Y		; get string pointer high byte
  2327  9838 9197               	STA	(Lvarpl),Y		; copy to let string variable
  2328  983a 60                 	RTS
  2329                          
  2330                          ; perform GET
  2331                          
  2332                          LAB_GET
  2333  983b 20bc9d             	JSR	LAB_GVAR		; get var address
  2334  983e 8597               	STA	Lvarpl		; save var address low byte
  2335  9840 8498               	STY	Lvarph		; save var address high byte
  2336  9842 2012af             	JSR	INGET			; get input byte
  2337  9845 a65f               	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
  2338  9847 3007               	BMI	LAB_GETS		; go get string character
  2339                          
  2340                          					; was numeric get
  2341  9849 a8                 	TAY				; copy character to Y
  2342  984a 2078a0             	JSR	LAB_1FD0		; convert Y to byte in FAC1
  2343  984d 4cb5a8             	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
  2344                          
  2345                          LAB_GETS
  2346  9850 48                 	PHA				; save character
  2347  9851 a901               	LDA	#$01			; string is single byte
  2348  9853 b001               	BCS	LAB_IsByte		; branch if byte received
  2349                          
  2350  9855 68                 	PLA				; string is null
  2351                          LAB_IsByte
  2352  9856 204ca1             	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  2353                          					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2354  9859 f005               	BEQ	LAB_NoSt		; skip store if null string
  2355                          
  2356  985b 68                 	PLA				; get character back
  2357  985c a000               	LDY	#$00			; clear index
  2358  985e 91ad               	STA	(str_pl),Y		; save byte in string (byte IS string!)
  2359                          LAB_NoSt
  2360  9860 2097a1             	JSR	LAB_RTST		; check for space on descriptor stack then put address
  2361                          					; and length on descriptor stack and update stack pointers
  2362                          
  2363  9863 4ce797             	JMP	LAB_17D5		; do string LET and return
  2364                          
  2365                          ; perform PRINT
  2366                          
  2367                          LAB_1829
  2368  9866 20e898             	JSR	LAB_18C6		; print string from Sutill/Sutilh
  2369                          LAB_182C
  2370  9869 20c200             	JSR	LAB_GBYT		; scan memory
  2371                          
  2372                          ; PRINT
  2373                          
  2374                          LAB_PRINT
  2375  986c f03b               	BEQ	LAB_CRLF		; if nothing following just print CR/LF
  2376                          
  2377                          LAB_1831
  2378  986e c9ab               	CMP	#TK_TAB		; compare with TAB( token
  2379  9870 f051               	BEQ	LAB_18A2		; go do TAB/SPC
  2380                          
  2381  9872 c9af               	CMP	#TK_SPC		; compare with SPC( token
  2382  9874 f04d               	BEQ	LAB_18A2		; go do TAB/SPC
  2383                          
  2384  9876 c92c               	CMP	#','			; compare with ","
  2385  9878 f033               	BEQ	LAB_188B		; go do move to next TAB mark
  2386                          
  2387  987a c93b               	CMP	#';'			; compare with ";"
  2388  987c f061               	BEQ	LAB_18BD		; if ";" continue with PRINT processing
  2389                          
  2390  987e 20f39a             	JSR	LAB_EVEX		; evaluate expression
  2391  9881 245f               	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
  2392  9883 30e1               	BMI	LAB_1829		; branch if string
  2393                          
  2394  9885 20a7aa             	JSR	LAB_296E		; convert FAC1 to string
  2395  9888 2056a1             	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
  2396  988b a000               	LDY	#$00			; clear index
  2397                          
  2398                          ; don't check fit if terminal width byte is zero
  2399                          
  2400  988d a50f               	LDA	TWidth		; get terminal width byte
  2401  988f f00a               	BEQ	LAB_185E		; skip check if zero
  2402                          
  2403  9891 38                 	SEC				; set carry for subtract
  2404  9892 e50e               	SBC	TPos			; subtract terminal position
  2405  9894 f1ae               	SBC	(des_pl),Y		; subtract string length
  2406  9896 b003               	BCS	LAB_185E		; branch if less than terminal width
  2407                          
  2408  9898 20a998             	JSR	LAB_CRLF		; else print CR/LF
  2409                          LAB_185E
  2410  989b 20e898             	JSR	LAB_18C6		; print string from Sutill/Sutilh
  2411  989e f0c9               	BEQ	LAB_182C		; always go continue processing line
  2412                          
  2413                          ; CR/LF return to BASIC from BASIC input handler
  2414                          
  2415                          LAB_1866
  2416  98a0 a900               	LDA	#$00			; clear byte
  2417  98a2 9d2103             	STA	Ibuffs,X		; null terminate input
  2418  98a5 a221               	LDX	#<Ibuffs		; set X to buffer start-1 low byte
  2419  98a7 a003               	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
  2420                          
  2421                          ; print CR/LF
  2422                          
  2423                          LAB_CRLF
  2424                          	;LDA	#$0D			; load [CR]
  2425                          	;JSR	LAB_PRNA		; go print the character
  2426  98a9 a90a               	LDA	#$0A			; load [LF]
  2427  98ab d052               	BNE	LAB_PRNA		; go print the character and return, branch always
  2428                          
  2429                          LAB_188B
  2430  98ad a50e               	LDA	TPos			; get terminal position
  2431  98af c510               	CMP	Iclim			; compare with input column limit
  2432  98b1 9005               	BCC	LAB_1897		; branch if less
  2433                          
  2434  98b3 20a998             	JSR	LAB_CRLF		; else print CR/LF (next line)
  2435  98b6 d027               	BNE	LAB_18BD		; continue with PRINT processing (branch always)
  2436                          
  2437                          LAB_1897
  2438  98b8 38                 	SEC				; set carry for subtract
  2439                          LAB_1898
  2440  98b9 e564               	SBC	TabSiz		; subtract TAB size
  2441  98bb b0fc               	BCS	LAB_1898		; loop if result was +ve
  2442                          
  2443  98bd 49ff               	EOR	#$FF			; complement it
  2444  98bf 6901               	ADC	#$01			; +1 (twos complement)
  2445  98c1 d012               	BNE	LAB_18B6		; always print A spaces (result is never $00)
  2446                          
  2447                          					; do TAB/SPC
  2448                          LAB_18A2
  2449  98c3 48                 	PHA				; save token
  2450  98c4 209ba4             	JSR	LAB_SGBY		; scan and get byte parameter
  2451  98c7 c929               	CMP	#$29			; is next character )
  2452  98c9 d07b               	BNE	LAB_1910		; if not do syntax error then warm start
  2453                          
  2454  98cb 68                 	PLA				; get token back
  2455  98cc c9ab               	CMP	#TK_TAB		; was it TAB ?
  2456  98ce d006               	BNE	LAB_18B7		; if not go do SPC
  2457                          
  2458                          					; calculate TAB offset
  2459  98d0 8a                 	TXA				; copy integer value to A
  2460  98d1 e50e               	SBC	TPos			; subtract terminal position
  2461  98d3 900a               	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
  2462                          
  2463                          					; print A spaces
  2464                          LAB_18B6
  2465  98d5 aa                 	TAX				; copy result to X
  2466                          LAB_18B7
  2467  98d6 8a                 	TXA				; set flags on size for SPC
  2468  98d7 f006               	BEQ	LAB_18BD		; branch if result was = $0, already here
  2469                          
  2470                          					; print X spaces
  2471                          LAB_18BA
  2472  98d9 20fa98             	JSR	LAB_18E0		; print " "
  2473  98dc ca                 	DEX				; decrement count
  2474  98dd d0fa               	BNE	LAB_18BA		; loop if not all done
  2475                          
  2476                          					; continue with PRINT processing
  2477                          LAB_18BD
  2478  98df 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  2479  98e2 d08a               	BNE	LAB_1831		; if more to print go do it
  2480                          
  2481  98e4 60                 	RTS
  2482                          
  2483                          ; print null terminated string from memory
  2484                          
  2485                          LAB_18C3
  2486  98e5 2056a1             	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
  2487                          
  2488                          ; print string from Sutill/Sutilh
  2489                          
  2490                          LAB_18C6
  2491  98e8 2050a3             	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  2492                          					; space returns with A = length, X=$71=pointer low byte,
  2493                          					; Y=$72=pointer high byte
  2494  98eb a000               	LDY	#$00			; reset index
  2495  98ed aa                 	TAX				; copy length to X
  2496  98ee f049               	BEQ	LAB_188C		; exit (RTS) if null string
  2497                          
  2498                          LAB_18CD
  2499                          
  2500  98f0 b171               	LDA	(ut1_pl),Y		; get next byte
  2501  98f2 20ff98             	JSR	LAB_PRNA		; go print the character
  2502  98f5 c8                 	INY				; increment index
  2503  98f6 ca                 	DEX				; decrement count
  2504  98f7 d0f7               	BNE	LAB_18CD		; loop if not done yet
  2505                          
  2506  98f9 60                 	RTS
  2507                          
  2508                          					; Print single format character
  2509                          ; print " "
  2510                          
  2511                          LAB_18E0
  2512  98fa a920               	LDA	#$20			; load " "
  2513  98fc 2c                 	!text	$2C			; change next line to BIT LAB_3FA9
  2514                          
  2515                          ; print "?" character
  2516                          
  2517                          LAB_18E3
  2518  98fd a93f               	LDA	#$3F			; load "?" character
  2519                          
  2520                          ; print character in A
  2521                          ; now includes the null handler
  2522                          ; also includes infinite line length code
  2523                          ; note! some routines expect this one to exit with Zb=0
  2524                          
  2525                          LAB_PRNA
  2526  98ff c920               	CMP	#' '			; compare with " "
  2527  9901 9019               	BCC	LAB_18F9		; branch if less (non printing)
  2528                          
  2529                          					; else printable character
  2530  9903 48                 	PHA				; save the character
  2531                          
  2532                          ; don't check fit if terminal width byte is zero
  2533                          
  2534  9904 a50f               	LDA	TWidth		; get terminal width
  2535  9906 d00a               	BNE	LAB_18F0		; branch if not zero (not infinite length)
  2536                          
  2537                          ; is "infinite line" so check TAB position
  2538                          
  2539  9908 a50e               	LDA	TPos			; get position
  2540  990a e564               	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
  2541  990c d00b               	BNE	LAB_18F7		; skip reset if different
  2542                          
  2543  990e 850e               	STA	TPos			; else reset position
  2544  9910 f007               	BEQ	LAB_18F7		; go print character
  2545                          
  2546                          LAB_18F0
  2547  9912 c50e               	CMP	TPos			; compare with terminal character position
  2548  9914 d003               	BNE	LAB_18F7		; branch if not at end of line
  2549                          
  2550  9916 20a998             	JSR	LAB_CRLF		; else print CR/LF
  2551                          LAB_18F7
  2552  9919 e60e               	INC	TPos			; increment terminal position
  2553  991b 68                 	PLA				; get character back
  2554                          LAB_18F9
  2555  991c 20ffb0             	JSR	V_OUTP		; output byte via output vector
  2556  991f c90d               	CMP	#$0D			; compare with [CR]
  2557  9921 d014               	BNE	LAB_188A		; branch if not [CR]
  2558                          
  2559                          					; else print nullct nulls after the [CR]
  2560  9923 8678               	STX	TempB			; save buffer index
  2561  9925 a60d               	LDX	Nullct		; get null count
  2562  9927 f00a               	BEQ	LAB_1886		; branch if no nulls
  2563                          
  2564  9929 a900               	LDA	#$00			; load [NULL]
  2565                          LAB_1880
  2566  992b 20ff98             	JSR	LAB_PRNA		; go print the character
  2567  992e ca                 	DEX				; decrement count
  2568  992f d0fa               	BNE	LAB_1880		; loop if not all done
  2569                          
  2570  9931 a90d               	LDA	#$0D			; restore the character (and set the flags)
  2571                          LAB_1886
  2572  9933 860e               	STX	TPos			; clear terminal position (X always = zero when we get here)
  2573  9935 a678               	LDX	TempB			; restore buffer index
  2574                          LAB_188A
  2575  9937 29ff               	AND	#$FF			; set the flags
  2576                          LAB_188C
  2577  9939 60                 	RTS
  2578                          
  2579                          ; handle bad input data
  2580                          
  2581                          LAB_1904
  2582  993a a562               	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
  2583  993c 100b               	BPL	LAB_1913		; branch if INPUT (go do redo)
  2584                          
  2585  993e a58d               	LDA	Dlinel		; get current DATA line low byte
  2586  9940 a48e               	LDY	Dlineh		; get current DATA line high byte
  2587  9942 8587               	STA	Clinel		; save current line low byte
  2588  9944 8488               	STY	Clineh		; save current line high byte
  2589                          LAB_1910
  2590  9946 4c149c             	JMP	LAB_SNER		; do syntax error then warm start
  2591                          
  2592                          					; mode was INPUT
  2593                          LAB_1913
  2594  9949 a928               	LDA	#<LAB_REDO		; point to redo message (low addr)
  2595  994b a0b8               	LDY	#>LAB_REDO		; point to redo message (high addr)
  2596  994d 20e598             	JSR	LAB_18C3		; print null terminated string from memory
  2597  9950 a58b               	LDA	Cpntrl		; get continue pointer low byte
  2598  9952 a48c               	LDY	Cpntrh		; get continue pointer high byte
  2599  9954 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  2600  9956 84c4               	STY	Bpntrh		; save BASIC execute pointer high byte
  2601  9958 60                 	RTS
  2602                          
  2603                          ; perform INPUT
  2604                          
  2605                          LAB_INPUT
  2606  9959 c922               	CMP	#$22			; compare next byte with open quote
  2607  995b d00b               	BNE	LAB_1934		; branch if no prompt string
  2608                          
  2609  995d 20d09b             	JSR	LAB_1BC1		; print "..." string
  2610  9960 a93b               	LDA	#$3B			; load A with ";"
  2611  9962 20039c             	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2612  9965 20e898             	JSR	LAB_18C6		; print string from Sutill/Sutilh
  2613                          
  2614                          					; done with prompt, now get data
  2615                          LAB_1934
  2616  9968 207ca0             	JSR	LAB_CKRN		; check not Direct, back here if ok
  2617  996b 204b92             	JSR	LAB_INLN		; print "? " and get BASIC input
  2618  996e a900               	LDA	#$00			; set mode = INPUT
  2619  9970 cd2103             	CMP	Ibuffs		; test first byte in buffer
  2620  9973 d00a               	BNE	LAB_1953		; branch if not null input
  2621                          
  2622  9975 18                 	CLC				; was null input so clear carry to exit program
  2623  9976 4c4395             	JMP	LAB_1647		; go do BREAK exit
  2624                          
  2625                          ; perform READ
  2626                          
  2627                          LAB_READ
  2628  9979 a68f               	LDX	Dptrl			; get DATA pointer low byte
  2629  997b a490               	LDY	Dptrh			; get DATA pointer high byte
  2630  997d a980               	LDA	#$80			; set mode = READ
  2631                          
  2632                          LAB_1953
  2633  997f 8562               	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
  2634  9981 8691               	STX	Rdptrl		; save READ pointer low byte
  2635  9983 8492               	STY	Rdptrh		; save READ pointer high byte
  2636                          
  2637                          					; READ or INPUT next variable from list
  2638                          LAB_195B
  2639  9985 20bc9d             	JSR	LAB_GVAR		; get (var) address
  2640  9988 8597               	STA	Lvarpl		; save address low byte
  2641  998a 8498               	STY	Lvarph		; save address high byte
  2642  998c a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  2643  998e a4c4               	LDY	Bpntrh		; get BASIC execute pointer high byte
  2644  9990 8511               	STA	Itempl		; save as temporary integer low byte
  2645  9992 8412               	STY	Itemph		; save as temporary integer high byte
  2646  9994 a691               	LDX	Rdptrl		; get READ pointer low byte
  2647  9996 a492               	LDY	Rdptrh		; get READ pointer high byte
  2648  9998 86c3               	STX	Bpntrl		; set BASIC execute pointer low byte
  2649  999a 84c4               	STY	Bpntrh		; set BASIC execute pointer high byte
  2650  999c 20c200             	JSR	LAB_GBYT		; scan memory
  2651  999f d011               	BNE	LAB_1988		; branch if not null
  2652                          
  2653                          					; pointer was to null entry
  2654  99a1 2462               	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
  2655  99a3 3065               	BMI	LAB_19DD		; branch if READ
  2656                          
  2657                          					; mode was INPUT
  2658  99a5 20fd98             	JSR	LAB_18E3		; print "?" character (double ? for extended input)
  2659  99a8 204b92             	JSR	LAB_INLN		; print "? " and get BASIC input
  2660  99ab 86c3               	STX	Bpntrl		; set BASIC execute pointer low byte
  2661  99ad 84c4               	STY	Bpntrh		; set BASIC execute pointer high byte
  2662                          LAB_1985
  2663  99af 20c200             	JSR	LAB_GBYT		; scan memory
  2664                          LAB_1988
  2665  99b2 245f               	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
  2666  99b4 1024               	BPL	LAB_19B0		; branch if numeric
  2667                          
  2668                          					; else get string
  2669  99b6 855b               	STA	Srchc			; save search character
  2670  99b8 c922               	CMP	#$22			; was it " ?
  2671  99ba f007               	BEQ	LAB_1999		; branch if so
  2672                          
  2673  99bc a93a               	LDA	#':'			; else search character is ":"
  2674  99be 855b               	STA	Srchc			; set new search character
  2675  99c0 a92c               	LDA	#','			; other search character is ","
  2676  99c2 18                 	CLC				; clear carry for add
  2677                          LAB_1999
  2678  99c3 855c               	STA	Asrch			; set second search character
  2679  99c5 a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  2680  99c7 a4c4               	LDY	Bpntrh		; get BASIC execute pointer high byte
  2681                          
  2682  99c9 6900               	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
  2683  99cb 9001               	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
  2684                          
  2685  99cd c8                 	INY				; else increment high byte
  2686                          LAB_19A4
  2687  99ce 205ca1             	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
  2688  99d1 20e1a4             	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2689  99d4 20e797             	JSR	LAB_17D5		; go do string LET
  2690  99d7 4ce099             	JMP	LAB_19B6		; go check string terminator
  2691                          
  2692                          					; get numeric INPUT
  2693                          LAB_19B0
  2694  99da 20b8a9             	JSR	LAB_2887		; get FAC1 from string
  2695  99dd 20b5a8             	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
  2696                          LAB_19B6
  2697  99e0 20c200             	JSR	LAB_GBYT		; scan memory
  2698  99e3 f00a               	BEQ	LAB_19C5		; branch if null (last entry)
  2699                          
  2700  99e5 c92c               	CMP	#','			; else compare with ","
  2701  99e7 f003               	BEQ	LAB_19C2		; branch if ","
  2702                          
  2703  99e9 4c3a99             	JMP	LAB_1904		; else go handle bad input data
  2704                          
  2705                          					; got good input data
  2706                          LAB_19C2
  2707  99ec 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  2708                          LAB_19C5
  2709  99ef a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2710  99f1 a4c4               	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2711  99f3 8591               	STA	Rdptrl		; save for now
  2712  99f5 8492               	STY	Rdptrh		; save for now
  2713  99f7 a511               	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
  2714  99f9 a412               	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
  2715  99fb 85c3               	STA	Bpntrl		; set BASIC execute pointer low byte
  2716  99fd 84c4               	STY	Bpntrh		; set BASIC execute pointer high byte
  2717  99ff 20c200             	JSR	LAB_GBYT		; scan memory
  2718  9a02 f02c               	BEQ	LAB_1A03		; if null go do extra ignored message
  2719                          
  2720  9a04 20109c             	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
  2721  9a07 4c8599             	JMP	LAB_195B		; go INPUT next variable from list
  2722                          
  2723                          					; find next DATA statement or do "Out of DATA" error
  2724                          LAB_19DD
  2725  9a0a 20b496             	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  2726  9a0d c8                 	INY				; increment index
  2727  9a0e aa                 	TAX				; copy character ([:] or [EOL])
  2728  9a0f d012               	BNE	LAB_19F6		; branch if [:]
  2729                          
  2730  9a11 a206               	LDX	#$06			; set for "Out of DATA" error
  2731  9a13 c8                 	INY				; increment index, now points to next line pointer high byte
  2732  9a14 b1c3               	LDA	(Bpntrl),Y		; get next line pointer high byte
  2733  9a16 f073               	BEQ	LAB_1A54		; branch if end (eventually does error X)
  2734                          
  2735  9a18 c8                 	INY				; increment index
  2736  9a19 b1c3               	LDA	(Bpntrl),Y		; get next line # low byte
  2737  9a1b 858d               	STA	Dlinel		; save current DATA line low byte
  2738  9a1d c8                 	INY				; increment index
  2739  9a1e b1c3               	LDA	(Bpntrl),Y		; get next line # high byte
  2740  9a20 c8                 	INY				; increment index
  2741  9a21 858e               	STA	Dlineh		; save current DATA line high byte
  2742                          LAB_19F6
  2743  9a23 b1c3               	LDA	(Bpntrl),Y		; get byte
  2744  9a25 c8                 	INY				; increment index
  2745  9a26 aa                 	TAX				; copy to X
  2746  9a27 20a696             	JSR	LAB_170F		; set BASIC execute pointer
  2747  9a2a e083               	CPX	#TK_DATA		; compare with "DATA" token
  2748  9a2c f081               	BEQ	LAB_1985		; was "DATA" so go do next READ
  2749                          
  2750  9a2e d0da               	BNE	LAB_19DD		; go find next statement if not "DATA"
  2751                          
  2752                          ; end of INPUT/READ routine
  2753                          
  2754                          LAB_1A03
  2755  9a30 a591               	LDA	Rdptrl		; get temp READ pointer low byte
  2756  9a32 a492               	LDY	Rdptrh		; get temp READ pointer high byte
  2757  9a34 a662               	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
  2758  9a36 1003               	BPL	LAB_1A0E		; branch if INPUT
  2759                          
  2760  9a38 4c6595             	JMP	LAB_1624		; save AY as DATA pointer and return
  2761                          
  2762                          					; we were getting INPUT
  2763                          LAB_1A0E
  2764  9a3b a000               	LDY	#$00			; clear index
  2765  9a3d b191               	LDA	(Rdptrl),Y		; get next byte
  2766  9a3f d001               	BNE	LAB_1A1B		; error if not end of INPUT
  2767                          
  2768  9a41 60                 	RTS
  2769                          
  2770                          					; user typed too much
  2771                          LAB_1A1B
  2772  9a42 a917               	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
  2773  9a44 a0b8               	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
  2774  9a46 4ce598             	JMP	LAB_18C3		; print null terminated string from memory and return
  2775                          
  2776                          ; search the stack for FOR activity
  2777                          ; exit with z=1 if FOR else exit with z=0
  2778                          
  2779                          LAB_11A1
  2780  9a49 ba                 	TSX				; copy stack pointer
  2781  9a4a e8                 	INX				; +1 pass return address
  2782  9a4b e8                 	INX				; +2 pass return address
  2783  9a4c e8                 	INX				; +3 pass calling routine return address
  2784  9a4d e8                 	INX				; +4 pass calling routine return address
  2785                          LAB_11A6
  2786  9a4e bd0101             	LDA	LAB_STAK+1,X	; get token byte from stack
  2787  9a51 c981               	CMP	#TK_FOR		; is it FOR token
  2788  9a53 d021               	BNE	LAB_11CE		; exit if not FOR token
  2789                          
  2790                          					; was FOR token
  2791  9a55 a598               	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
  2792  9a57 d00a               	BNE	LAB_11BB		; branch if not null
  2793                          
  2794  9a59 bd0201             	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
  2795  9a5c 8597               	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
  2796  9a5e bd0301             	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
  2797  9a61 8598               	STA	Frnxth		; save var pointer for FOR/NEXT high byte
  2798                          LAB_11BB
  2799  9a63 dd0301             	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
  2800  9a66 d007               	BNE	LAB_11C7		; branch if no match
  2801                          
  2802  9a68 a597               	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
  2803  9a6a dd0201             	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
  2804  9a6d f007               	BEQ	LAB_11CE		; exit if match found
  2805                          
  2806                          LAB_11C7
  2807  9a6f 8a                 	TXA				; copy index
  2808  9a70 18                 	CLC				; clear carry for add
  2809  9a71 6910               	ADC	#$10			; add FOR stack use size
  2810  9a73 aa                 	TAX				; copy back to index
  2811  9a74 d0d8               	BNE	LAB_11A6		; loop if not at start of stack
  2812                          
  2813                          LAB_11CE
  2814  9a76 60                 	RTS
  2815                          
  2816                          ; perform NEXT
  2817                          
  2818                          LAB_NEXT
  2819  9a77 d004               	BNE	LAB_1A46		; branch if NEXT var
  2820                          
  2821  9a79 a000               	LDY	#$00			; else clear Y
  2822  9a7b f003               	BEQ	LAB_1A49		; branch always (no variable to search for)
  2823                          
  2824                          ; NEXT var
  2825                          
  2826                          LAB_1A46
  2827  9a7d 20bc9d             	JSR	LAB_GVAR		; get variable address
  2828                          LAB_1A49
  2829  9a80 8597               	STA	Frnxtl		; store variable pointer low byte
  2830  9a82 8498               	STY	Frnxth		; store variable pointer high byte
  2831                          					; (both cleared if no variable defined)
  2832  9a84 20499a             	JSR	LAB_11A1		; search the stack for FOR activity
  2833  9a87 f004               	BEQ	LAB_1A56		; branch if found
  2834                          
  2835  9a89 a200               	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
  2836                          LAB_1A54
  2837  9a8b f063               	BEQ	LAB_1ABE		; do error #X, then warm start
  2838                          
  2839                          LAB_1A56
  2840  9a8d 9a                 	TXS				; set stack pointer, X set by search, dumps return addresses
  2841                          
  2842  9a8e 8a                 	TXA				; copy stack pointer
  2843  9a8f 38                 	SEC				; set carry for subtract
  2844  9a90 e9f7               	SBC	#$F7			; point to TO var
  2845  9a92 8573               	STA	ut2_pl		; save pointer to TO var for compare
  2846  9a94 69fb               	ADC	#$FB			; point to STEP var
  2847                          
  2848  9a96 a001               	LDY	#>LAB_STAK		; point to stack page high byte
  2849  9a98 208fa8             	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
  2850  9a9b ba                 	TSX				; get stack pointer back
  2851  9a9c bd0801             	LDA	LAB_STAK+8,X	; get step sign
  2852  9a9f 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  2853  9aa1 a597               	LDA	Frnxtl		; get FOR variable pointer low byte
  2854  9aa3 a498               	LDY	Frnxth		; get FOR variable pointer high byte
  2855  9aa5 20d0a5             	JSR	LAB_246C		; add (FOR variable) to FAC1
  2856  9aa8 20b5a8             	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
  2857  9aab a001               	LDY	#>LAB_STAK		; point to stack page high byte
  2858  9aad 202ba9             	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
  2859  9ab0 ba                 	TSX				; get stack pointer back
  2860  9ab1 dd0801             	CMP	LAB_STAK+8,X	; compare step sign
  2861  9ab4 f017               	BEQ	LAB_1A9B		; branch if = (loop complete)
  2862                          
  2863                          					; loop back and do it all again
  2864  9ab6 bd0d01             	LDA	LAB_STAK+$0D,X	; get FOR line low byte
  2865  9ab9 8587               	STA	Clinel		; save current line low byte
  2866  9abb bd0e01             	LDA	LAB_STAK+$0E,X	; get FOR line high byte
  2867  9abe 8588               	STA	Clineh		; save current line high byte
  2868  9ac0 bd1001             	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
  2869  9ac3 85c3               	STA	Bpntrl		; save BASIC execute pointer low byte
  2870  9ac5 bd0f01             	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
  2871  9ac8 85c4               	STA	Bpntrh		; save BASIC execute pointer high byte
  2872                          LAB_1A98
  2873  9aca 4cd394             	JMP	LAB_15C2		; go do interpreter inner loop
  2874                          
  2875                          					; loop complete so carry on
  2876                          LAB_1A9B
  2877  9acd 8a                 	TXA				; stack copy to A
  2878  9ace 690f               	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
  2879  9ad0 aa                 	TAX				; copy back to index
  2880  9ad1 9a                 	TXS				; copy to stack pointer
  2881  9ad2 20c200             	JSR	LAB_GBYT		; scan memory
  2882  9ad5 c92c               	CMP	#','			; compare with ","
  2883  9ad7 d0f1               	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
  2884                          
  2885                          					; was "," so another NEXT variable to do
  2886  9ad9 20bc00             	JSR	LAB_IGBY		; else increment and scan memory
  2887  9adc 207d9a             	JSR	LAB_1A46		; do NEXT (var)
  2888                          
  2889                          ; evaluate expression and check is numeric, else do type mismatch
  2890                          
  2891                          LAB_EVNM
  2892  9adf 20f39a             	JSR	LAB_EVEX		; evaluate expression
  2893                          
  2894                          ; check if source is numeric, else do type mismatch
  2895                          
  2896                          LAB_CTNM
  2897  9ae2 18                 	CLC				; destination is numeric
  2898  9ae3 24                 	!text	$24			; makes next line BIT $38
  2899                          
  2900                          ; check if source is string, else do type mismatch
  2901                          
  2902                          LAB_CTST
  2903  9ae4 38                 	SEC				; required type is string
  2904                          
  2905                          ; type match check, set C for string, clear C for numeric
  2906                          
  2907                          LAB_CKTM
  2908  9ae5 245f               	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
  2909  9ae7 3003               	BMI	LAB_1ABA		; branch if data type is string
  2910                          
  2911                          					; else data type was numeric
  2912  9ae9 b003               	BCS	LAB_1ABC		; if required type is string do type mismatch error
  2913                          LAB_1AB9
  2914  9aeb 60                 	RTS
  2915                          
  2916                          					; data type was string, now check required type
  2917                          LAB_1ABA
  2918  9aec b0fd               	BCS	LAB_1AB9		; exit if required type is string
  2919                          
  2920                          					; else do type mismatch error
  2921                          LAB_1ABC
  2922  9aee a218               	LDX	#$18			; error code $18 ("Type mismatch" error)
  2923                          LAB_1ABE
  2924  9af0 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  2925                          
  2926                          ; evaluate expression
  2927                          
  2928                          LAB_EVEX
  2929  9af3 a6c3               	LDX	Bpntrl		; get BASIC execute pointer low byte
  2930  9af5 d002               	BNE	LAB_1AC7		; skip next if not zero
  2931                          
  2932  9af7 c6c4               	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
  2933                          LAB_1AC7
  2934  9af9 c6c3               	DEC	Bpntrl		; decrement BASIC execute pointer low byte
  2935                          
  2936                          LAB_EVEZ
  2937  9afb a900               	LDA	#$00			; set null precedence (flag done)
  2938                          LAB_1ACC
  2939  9afd 48                 	PHA				; push precedence byte
  2940  9afe a902               	LDA	#$02			; 2 bytes
  2941  9b00 200e91             	JSR	LAB_1212		; check room on stack for A bytes
  2942  9b03 20df9b             	JSR	LAB_GVAL		; get value from line
  2943  9b06 a900               	LDA	#$00			; clear A
  2944  9b08 859b               	STA	comp_f		; clear compare function flag
  2945                          LAB_1ADB
  2946  9b0a 20c200             	JSR	LAB_GBYT		; scan memory
  2947                          LAB_1ADE
  2948  9b0d 38                 	SEC				; set carry for subtract
  2949  9b0e e9c0               	SBC	#TK_GT		; subtract token for > (lowest comparison function)
  2950  9b10 9017               	BCC	LAB_1AFA		; branch if < TK_GT
  2951                          
  2952  9b12 c903               	CMP	#$03			; compare with ">" to "<" tokens
  2953  9b14 b013               	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
  2954                          
  2955                          					; was token for > = or < (A = 0, 1 or 2)
  2956  9b16 c901               	CMP	#$01			; compare with token for =
  2957  9b18 2a                 	ROL				; *2, b0 = carry (=1 if token was = or <)
  2958                          					; (A = 0, 3 or 5)
  2959  9b19 4901               	EOR	#$01			; toggle b0
  2960                          					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2961  9b1b 459b               	EOR	comp_f		; EOR with compare function flag bits
  2962  9b1d c59b               	CMP	comp_f		; compare with compare function flag
  2963  9b1f 9067               	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
  2964                          					; was more than one <, = or >)
  2965                          
  2966  9b21 859b               	STA	comp_f		; save new compare function flag
  2967  9b23 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  2968  9b26 4c0d9b             	JMP	LAB_1ADE		; go do next character
  2969                          
  2970                          					; token is < ">" or > "<" tokens
  2971                          LAB_1AFA
  2972  9b29 a69b               	LDX	comp_f		; get compare function flag
  2973  9b2b d02c               	BNE	LAB_1B2A		; branch if compare function
  2974                          
  2975  9b2d b079               	BCS	LAB_1B78		; go do functions
  2976                          
  2977                          					; else was <  TK_GT so is operator or lower
  2978  9b2f 690a               	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2979  9b31 9075               	BCC	LAB_1B78		; branch if < + operator
  2980                          
  2981                          					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2982  9b33 d007               	BNE	LAB_1B0B		; branch if not + token
  2983                          
  2984  9b35 245f               	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
  2985  9b37 1003               	BPL	LAB_1B0B		; branch if not string
  2986                          
  2987                          					; will only be $00 if type is string and token was +
  2988  9b39 4ce6a2             	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
  2989                          					; is in line, and return
  2990                          
  2991                          LAB_1B0B
  2992  9b3c 8571               	STA	ut1_pl		; save it
  2993  9b3e 0a                 	ASL				; *2
  2994  9b3f 6571               	ADC	ut1_pl		; *3
  2995  9b41 a8                 	TAY				; copy to index
  2996                          LAB_1B13
  2997  9b42 68                 	PLA				; pull previous precedence
  2998  9b43 d9ecb2             	CMP	LAB_OPPT,Y		; compare with precedence byte
  2999  9b46 b065               	BCS	LAB_1B7D		; branch if A >=
  3000                          
  3001  9b48 20e29a             	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3002                          LAB_1B1C
  3003  9b4b 48                 	PHA				; save precedence
  3004                          LAB_1B1D
  3005  9b4c 20749b             	JSR	LAB_1B43		; get vector, execute function then continue evaluation
  3006  9b4f 68                 	PLA				; restore precedence
  3007  9b50 a499               	LDY	prstk			; get precedence stacked flag
  3008  9b52 1019               	BPL	LAB_1B3C		; branch if stacked values
  3009                          
  3010  9b54 aa                 	TAX				; copy precedence (set flags)
  3011  9b55 f076               	BEQ	LAB_1B9D		; exit if done
  3012                          
  3013  9b57 d05d               	BNE	LAB_1B86		; else pop FAC2 and return, branch always
  3014                          
  3015                          LAB_1B2A
  3016  9b59 265f               	ROL	Dtypef		; shift data type flag into Cb
  3017  9b5b 8a                 	TXA				; copy compare function flag
  3018  9b5c 855f               	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
  3019  9b5e 2a                 	ROL				; shift data type into compare function byte b0
  3020  9b5f a6c3               	LDX	Bpntrl		; get BASIC execute pointer low byte
  3021  9b61 d002               	BNE	LAB_1B34		; branch if no underflow
  3022                          
  3023  9b63 c6c4               	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
  3024                          LAB_1B34
  3025  9b65 c6c3               	DEC	Bpntrl		; decrement BASIC execute pointer low byte
  3026                          TK_LT_PLUS	= TK_LT-TK_PLUS
  3027  9b67 a024               	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
  3028  9b69 859b               	STA	comp_f		; save new compare function flag
  3029  9b6b d0d5               	BNE	LAB_1B13		; branch always
  3030                          
  3031                          LAB_1B3C
  3032  9b6d d9ecb2             	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
  3033  9b70 b044               	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
  3034                          
  3035  9b72 90d7               	BCC	LAB_1B1C		; branch always
  3036                          
  3037                          ;.get vector, execute function then continue evaluation
  3038                          
  3039                          LAB_1B43
  3040  9b74 b9eeb2             	LDA	LAB_OPPT+2,Y	; get function vector high byte
  3041  9b77 48                 	PHA				; onto stack
  3042  9b78 b9edb2             	LDA	LAB_OPPT+1,Y	; get function vector low byte
  3043  9b7b 48                 	PHA				; onto stack
  3044                          					; now push sign, round FAC1 and put on stack
  3045  9b7c 208b9b             	JSR	LAB_1B5B		; function will return here, then the next RTS will call
  3046                          					; the function
  3047  9b7f a59b               	LDA	comp_f		; get compare function flag
  3048  9b81 48                 	PHA				; push compare evaluation byte
  3049  9b82 b9ecb2             	LDA	LAB_OPPT,Y		; get precedence byte
  3050  9b85 4cfd9a             	JMP	LAB_1ACC		; continue evaluating expression
  3051                          
  3052                          LAB_1B53
  3053  9b88 4c149c             	JMP	LAB_SNER		; do syntax error then warm start
  3054                          
  3055                          ; push sign, round FAC1 and put on stack
  3056                          
  3057                          LAB_1B5B
  3058  9b8b 68                 	PLA				; get return addr low byte
  3059  9b8c 8571               	STA	ut1_pl		; save it
  3060  9b8e e671               	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
  3061                          					; note! no check is made on the high byte! if the calling
  3062                          					; routine assembles to a page edge then this all goes
  3063                          					; horribly wrong !!!
  3064  9b90 68                 	PLA				; get return addr high byte
  3065  9b91 8572               	STA	ut1_ph		; save it
  3066  9b93 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  3067  9b95 48                 	PHA				; push sign
  3068                          
  3069                          ; round FAC1 and put on stack
  3070                          
  3071                          LAB_1B66
  3072  9b96 20eba8             	JSR	LAB_27BA		; round FAC1
  3073  9b99 a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  3074  9b9b 48                 	PHA				; push on stack
  3075  9b9c a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  3076  9b9e 48                 	PHA				; push on stack
  3077  9b9f a5ad               	LDA	FAC1_1		; get FAC1 mantissa1
  3078  9ba1 48                 	PHA				; push on stack
  3079  9ba2 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  3080  9ba4 48                 	PHA				; push on stack
  3081  9ba5 6c7100             	JMP	(ut1_pl)		; return, sort of
  3082                          
  3083                          ; do functions
  3084                          
  3085                          LAB_1B78
  3086  9ba8 a0ff               	LDY	#$FF			; flag function
  3087  9baa 68                 	PLA				; pull precedence byte
  3088                          LAB_1B7B
  3089  9bab f020               	BEQ	LAB_1B9D		; exit if done
  3090                          
  3091                          LAB_1B7D
  3092  9bad c964               	CMP	#$64			; compare previous precedence with $64
  3093  9baf f003               	BEQ	LAB_1B84		; branch if was $64 (< function)
  3094                          
  3095  9bb1 20e29a             	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3096                          LAB_1B84
  3097  9bb4 8499               	STY	prstk			; save precedence stacked flag
  3098                          
  3099                          					; pop FAC2 and return
  3100                          LAB_1B86
  3101  9bb6 68                 	PLA				; pop byte
  3102  9bb7 4a                 	LSR				; shift out comparison evaluation lowest bit
  3103  9bb8 8563               	STA	Cflag			; save comparison evaluation flag
  3104  9bba 68                 	PLA				; pop exponent
  3105  9bbb 85b3               	STA	FAC2_e		; save FAC2 exponent
  3106  9bbd 68                 	PLA				; pop mantissa1
  3107  9bbe 85b4               	STA	FAC2_1		; save FAC2 mantissa1
  3108  9bc0 68                 	PLA				; pop mantissa2
  3109  9bc1 85b5               	STA	FAC2_2		; save FAC2 mantissa2
  3110  9bc3 68                 	PLA				; pop mantissa3
  3111  9bc4 85b6               	STA	FAC2_3		; save FAC2 mantissa3
  3112  9bc6 68                 	PLA				; pop sign
  3113  9bc7 85b7               	STA	FAC2_s		; save FAC2 sign (b7)
  3114  9bc9 45b0               	EOR	FAC1_s		; EOR FAC1 sign (b7)
  3115  9bcb 85b8               	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
  3116                          LAB_1B9D
  3117  9bcd a5ac               	LDA	FAC1_e		; get FAC1 exponent
  3118  9bcf 60                 	RTS
  3119                          
  3120                          ; print "..." string to string util area
  3121                          
  3122                          LAB_1BC1
  3123  9bd0 a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  3124  9bd2 a4c4               	LDY	Bpntrh		; get BASIC execute pointer high byte
  3125  9bd4 6900               	ADC	#$00			; add carry to low byte
  3126  9bd6 9001               	BCC	LAB_1BCA		; branch if no overflow
  3127                          
  3128  9bd8 c8                 	INY				; increment high byte
  3129                          LAB_1BCA
  3130  9bd9 2056a1             	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
  3131  9bdc 4ce1a4             	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
  3132                          
  3133                          ; get value from line
  3134                          
  3135                          LAB_GVAL
  3136  9bdf 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  3137  9be2 b003               	BCS	LAB_1BAC		; branch if not numeric character
  3138                          
  3139                          					; else numeric string found (e.g. 123)
  3140                          LAB_1BA9
  3141  9be4 4cb8a9             	JMP	LAB_2887		; get FAC1 from string and return
  3142                          
  3143                          ; get value from line .. continued
  3144                          
  3145                          					; wasn't a number so ..
  3146                          LAB_1BAC
  3147  9be7 aa                 	TAX				; set the flags
  3148  9be8 302f               	BMI	LAB_1BD0		; if -ve go test token values
  3149                          
  3150                          					; else it is either a string, number, variable or (<expr>)
  3151  9bea c924               	CMP	#'$'			; compare with "$"
  3152  9bec f0f6               	BEQ	LAB_1BA9		; branch if "$", hex number
  3153                          
  3154  9bee c925               	CMP	#'%'			; else compare with "%"
  3155  9bf0 f0f2               	BEQ	LAB_1BA9		; branch if "%", binary number
  3156                          
  3157  9bf2 c92e               	CMP	#'.'			; compare with "."
  3158  9bf4 f0ee               	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
  3159                          
  3160                          					; it wasn't any sort of number so ..
  3161  9bf6 c922               	CMP	#$22			; compare with "
  3162  9bf8 f0d6               	BEQ	LAB_1BC1		; branch if open quote
  3163                          
  3164                          					; wasn't any sort of number so ..
  3165                          
  3166                          ; evaluate expression within parentheses
  3167                          
  3168  9bfa c928               	CMP	#'('			; compare with "("
  3169  9bfc d04f               	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
  3170                          
  3171                          LAB_1BF7
  3172  9bfe 20fb9a             	JSR	LAB_EVEZ		; evaluate expression, no decrement
  3173                          
  3174                          ; all the 'scan for' routines return the character after the sought character
  3175                          
  3176                          ; scan for ")" , else do syntax error then warm start
  3177                          
  3178                          LAB_1BFB
  3179  9c01 a929               	LDA	#$29			; load A with ")"
  3180                          
  3181                          ; scan for CHR$(A) , else do syntax error then warm start
  3182                          
  3183                          LAB_SCCA
  3184  9c03 a000               	LDY	#$00			; clear index
  3185  9c05 d1c3               	CMP	(Bpntrl),Y		; check next byte is = A
  3186  9c07 d00b               	BNE	LAB_SNER		; if not do syntax error then warm start
  3187                          
  3188  9c09 4cbc00             	JMP	LAB_IGBY		; increment and scan memory then return
  3189                          
  3190                          ; scan for "(" , else do syntax error then warm start
  3191                          
  3192                          LAB_1BFE
  3193  9c0c a928               	LDA	#$28			; load A with "("
  3194  9c0e d0f3               	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3195                          					; (branch always)
  3196                          
  3197                          ; scan for "," , else do syntax error then warm start
  3198                          
  3199                          LAB_1C01
  3200  9c10 a92c               	LDA	#$2C			; load A with ","
  3201  9c12 d0ef               	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  3202                          					; (branch always)
  3203                          
  3204                          ; syntax error then warm start
  3205                          
  3206                          LAB_SNER
  3207  9c14 a202               	LDX	#$02			; error code $02 ("Syntax" error)
  3208  9c16 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  3209                          
  3210                          ; get value from line .. continued
  3211                          ; do tokens
  3212                          
  3213                          LAB_1BD0
  3214  9c19 c9b7               	CMP	#TK_MINUS		; compare with token for -
  3215  9c1b f029               	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
  3216                          
  3217                          					; wasn't -n so ..
  3218  9c1d c9b6               	CMP	#TK_PLUS		; compare with token for +
  3219  9c1f f0be               	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
  3220                          
  3221  9c21 c9b1               	CMP	#TK_NOT		; compare with token for NOT
  3222  9c23 d013               	BNE	LAB_1BE7		; branch if not token for NOT
  3223                          
  3224                          					; was NOT token
  3225                          TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
  3226  9c25 a021               	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
  3227  9c27 d01f               	BNE	LAB_1C13		; do set-up for function then execute (branch always)
  3228                          
  3229                          ; do = compare
  3230                          
  3231                          LAB_EQUAL
  3232  9c29 20b89e             	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3233  9c2c a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  3234  9c2e 49ff               	EOR	#$FF			; invert it
  3235  9c30 a8                 	TAY				; copy it
  3236  9c31 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  3237  9c33 49ff               	EOR	#$FF			; invert it
  3238  9c35 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3239                          
  3240                          ; get value from line .. continued
  3241                          
  3242                          					; wasn't +, -, or NOT so ..
  3243                          LAB_1BE7
  3244  9c38 c9ae               	CMP	#TK_FN		; compare with token for FN
  3245  9c3a d003               	BNE	LAB_1BEE		; branch if not token for FN
  3246                          
  3247  9c3c 4cc6a0             	JMP	LAB_201E		; go evaluate FNx
  3248                          
  3249                          ; get value from line .. continued
  3250                          
  3251                          					; wasn't +, -, NOT or FN so ..
  3252                          LAB_1BEE
  3253  9c3f e9c3               	SBC	#TK_SGN		; subtract with token for SGN
  3254  9c41 b019               	BCS	LAB_1C27		; if a function token go do it
  3255                          
  3256  9c43 4c149c             	JMP	LAB_SNER		; else do syntax error
  3257                          
  3258                          ; set-up for functions
  3259                          
  3260                          LAB_1C11
  3261                          TK_GT_PLUS	= TK_GT-TK_PLUS
  3262  9c46 a01e               	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
  3263                          LAB_1C13
  3264  9c48 68                 	PLA				; dump return address low byte
  3265  9c49 68                 	PLA				; dump return address high byte
  3266  9c4a 4c4c9b             	JMP	LAB_1B1D		; execute function then continue evaluation
  3267                          
  3268                          ; variable name set-up
  3269                          ; get (var), return value in FAC_1 and $ flag
  3270                          
  3271                          LAB_1C18
  3272  9c4d 20bc9d             	JSR	LAB_GVAR		; get (var) address
  3273  9c50 85ae               	STA	FAC1_2		; save address low byte in FAC1 mantissa2
  3274  9c52 84af               	STY	FAC1_3		; save address high byte in FAC1 mantissa3
  3275  9c54 a65f               	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
  3276  9c56 3003               	BMI	LAB_1C25		; if string then return (does RTS)
  3277                          
  3278                          LAB_1C24
  3279  9c58 4c8fa8             	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
  3280                          
  3281                          LAB_1C25
  3282  9c5b 60                 	RTS
  3283                          
  3284                          ; get value from line .. continued
  3285                          ; only functions left so ..
  3286                          
  3287                          ; set up function references
  3288                          
  3289                          ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3290                          ; to process function calls. now the function vector is computed and pushed on the stack
  3291                          ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3292                          ; is calculated and the routine called, if not this routine just does RTS. whichever
  3293                          ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3294                          ; the function code
  3295                          
  3296                          ; this also removes some less than elegant code that was used to bypass type checking
  3297                          ; for functions that returned strings
  3298                          
  3299                          LAB_1C27
  3300  9c5c 0a                 	ASL				; *2 (2 bytes per function address)
  3301  9c5d a8                 	TAY				; copy to index
  3302                          
  3303  9c5e b9a7b2             	LDA	LAB_FTBM,Y		; get function jump vector high byte
  3304  9c61 48                 	PHA				; push functions jump vector high byte
  3305  9c62 b9a6b2             	LDA	LAB_FTBL,Y		; get function jump vector low byte
  3306  9c65 48                 	PHA				; push functions jump vector low byte
  3307                          
  3308  9c66 b961b2             	LDA	LAB_FTPM,Y		; get function pre process vector high byte
  3309  9c69 f005               	BEQ	LAB_1C56		; skip pre process if null vector
  3310                          
  3311  9c6b 48                 	PHA				; push functions pre process vector high byte
  3312  9c6c b960b2             	LDA	LAB_FTPL,Y		; get function pre process vector low byte
  3313  9c6f 48                 	PHA				; push functions pre process vector low byte
  3314                          
  3315                          LAB_1C56
  3316  9c70 60                 	RTS				; do function, or pre process, call
  3317                          
  3318                          ; process string expression in parenthesis
  3319                          
  3320                          LAB_PPFS
  3321  9c71 20fe9b             	JSR	LAB_1BF7		; process expression in parenthesis
  3322  9c74 4ce49a             	JMP	LAB_CTST		; check if source is string then do function,
  3323                          					; else do type mismatch
  3324                          
  3325                          ; process numeric expression in parenthesis
  3326                          
  3327                          LAB_PPFN
  3328  9c77 20fe9b             	JSR	LAB_1BF7		; process expression in parenthesis
  3329  9c7a 4ce29a             	JMP	LAB_CTNM		; check if source is numeric then do function,
  3330                          					; else do type mismatch
  3331                          
  3332                          ; set numeric data type and increment BASIC execute pointer
  3333                          
  3334                          LAB_PPBI
  3335  9c7d 465f               	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
  3336  9c7f 4cbc00             	JMP	LAB_IGBY		; increment and scan memory then do function
  3337                          
  3338                          ; process string for LEFT$, RIGHT$ or MID$
  3339                          
  3340                          LAB_LRMS
  3341  9c82 20fb9a             	JSR	LAB_EVEZ		; evaluate (should be string) expression
  3342  9c85 20109c             	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
  3343  9c88 20e49a             	JSR	LAB_CTST		; check if source is string, else do type mismatch
  3344                          
  3345  9c8b 68                 	PLA				; get function jump vector low byte
  3346  9c8c aa                 	TAX				; save functions jump vector low byte
  3347  9c8d 68                 	PLA				; get function jump vector high byte
  3348  9c8e a8                 	TAY				; save functions jump vector high byte
  3349  9c8f a5af               	LDA	des_ph		; get descriptor pointer high byte
  3350  9c91 48                 	PHA				; push string pointer high byte
  3351  9c92 a5ae               	LDA	des_pl		; get descriptor pointer low byte
  3352  9c94 48                 	PHA				; push string pointer low byte
  3353  9c95 98                 	TYA				; get function jump vector high byte back
  3354  9c96 48                 	PHA				; save functions jump vector high byte
  3355  9c97 8a                 	TXA				; get function jump vector low byte back
  3356  9c98 48                 	PHA				; save functions jump vector low byte
  3357  9c99 209ea4             	JSR	LAB_GTBY		; get byte parameter
  3358  9c9c 8a                 	TXA				; copy byte parameter to A
  3359  9c9d 60                 	RTS				; go do function
  3360                          
  3361                          ; process numeric expression(s) for BIN$ or HEX$
  3362                          
  3363                          LAB_BHSS
  3364  9c9e 20fb9a             	JSR	LAB_EVEZ		; process expression
  3365  9ca1 20e29a             	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3366  9ca4 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  3367  9ca6 c998               	CMP	#$98			; compare with exponent = 2^24
  3368  9ca8 b020               	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
  3369                          
  3370  9caa 2062a9             	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  3371  9cad a202               	LDX	#$02			; 3 bytes to do
  3372                          LAB_CFAC
  3373  9caf b5ad               	LDA	FAC1_1,X		; get byte from FAC1
  3374  9cb1 9511               	STA	nums_1,X		; save byte to temp
  3375  9cb3 ca                 	DEX				; decrement index
  3376  9cb4 10f9               	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
  3377                          
  3378  9cb6 20c200             	JSR	LAB_GBYT		; get next BASIC byte
  3379  9cb9 a200               	LDX	#$00			; set default to no leading "0"s
  3380  9cbb c929               	CMP	#')'			; compare with close bracket
  3381  9cbd f00a               	BEQ	LAB_1C54		; if ")" go do rest of function
  3382                          
  3383  9cbf 20f0a4             	JSR	LAB_SCGB		; scan for "," and get byte
  3384  9cc2 20c200             	JSR	LAB_GBYT		; get last byte back
  3385  9cc5 c929               	CMP	#')'			; is next character )
  3386  9cc7 d001               	BNE	LAB_BHER		; if not ")" go do error
  3387                          
  3388                          LAB_1C54
  3389  9cc9 60                 	RTS				; else do function
  3390                          
  3391                          LAB_BHER
  3392  9cca 4c3b9f             	JMP	LAB_FCER		; do function call error then warm start
  3393                          
  3394                          ; perform EOR
  3395                          
  3396                          ; added operator format is the same as AND or OR, precedence is the same as OR
  3397                          
  3398                          ; this bit worked first time but it took a while to sort out the operator table
  3399                          ; pointers and offsets afterwards!
  3400                          
  3401                          LAB_EOR
  3402  9ccd 20f49c             	JSR	GetFirst		; get first integer expression (no sign check)
  3403  9cd0 455b               	EOR	XOAw_l		; EOR with expression 1 low byte
  3404  9cd2 a8                 	TAY				; save in Y
  3405  9cd3 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  3406  9cd5 455c               	EOR	XOAw_h		; EOR with expression 1 high byte
  3407  9cd7 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3408                          
  3409                          ; perform OR
  3410                          
  3411                          LAB_OR
  3412  9cda 20f49c             	JSR	GetFirst		; get first integer expression (no sign check)
  3413  9cdd 055b               	ORA	XOAw_l		; OR with expression 1 low byte
  3414  9cdf a8                 	TAY				; save in Y
  3415  9ce0 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  3416  9ce2 055c               	ORA	XOAw_h		; OR with expression 1 high byte
  3417  9ce4 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3418                          
  3419                          ; perform AND
  3420                          
  3421                          LAB_AND
  3422  9ce7 20f49c             	JSR	GetFirst		; get first integer expression (no sign check)
  3423  9cea 255b               	AND	XOAw_l		; AND with expression 1 low byte
  3424  9cec a8                 	TAY				; save in Y
  3425  9ced a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  3426  9cef 255c               	AND	XOAw_h		; AND with expression 1 high byte
  3427  9cf1 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3428                          
  3429                          ; get first value for OR, AND or EOR
  3430                          
  3431                          GetFirst
  3432  9cf4 20b89e             	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3433  9cf7 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  3434  9cf9 855c               	STA	XOAw_h		; save it
  3435  9cfb a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  3436  9cfd 855b               	STA	XOAw_l		; save it
  3437  9cff 20d5a5             	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3438  9d02 20b89e             	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3439  9d05 a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  3440                          LAB_1C95
  3441  9d07 60                 	RTS
  3442                          
  3443                          ; perform comparisons
  3444                          
  3445                          ; do < compare
  3446                          
  3447                          LAB_LTHAN
  3448  9d08 20e59a             	JSR	LAB_CKTM		; type match check, set C for string
  3449  9d0b b013               	BCS	LAB_1CAE		; branch if string
  3450                          
  3451                          					; do numeric < compare
  3452  9d0d a5b7               	LDA	FAC2_s		; get FAC2 sign (b7)
  3453  9d0f 097f               	ORA	#$7F			; set all non sign bits
  3454  9d11 25b4               	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
  3455  9d13 85b4               	STA	FAC2_1		; save FAC2 mantissa1
  3456  9d15 a9b3               	LDA	#<FAC2_e		; set pointer low byte to FAC2
  3457  9d17 a000               	LDY	#>FAC2_e		; set pointer high byte to FAC2
  3458  9d19 2029a9             	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
  3459  9d1c aa                 	TAX				; copy result
  3460  9d1d 4c519d             	JMP	LAB_1CE1		; go evaluate result
  3461                          
  3462                          					; do string < compare
  3463                          LAB_1CAE
  3464  9d20 465f               	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
  3465  9d22 c69b               	DEC	comp_f		; clear < bit in compare function flag
  3466  9d24 2050a3             	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3467                          					; space returns with A = length, X=pointer low byte,
  3468                          					; Y=pointer high byte
  3469  9d27 85ac               	STA	str_ln		; save length
  3470  9d29 86ad               	STX	str_pl		; save string pointer low byte
  3471  9d2b 84ae               	STY	str_ph		; save string pointer high byte
  3472  9d2d a5b5               	LDA	FAC2_2		; get descriptor pointer low byte
  3473  9d2f a4b6               	LDY	FAC2_3		; get descriptor pointer high byte
  3474  9d31 2054a3             	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  3475                          					; returns with A = length, X=pointer low byte,
  3476                          					; Y=pointer high byte
  3477  9d34 86b5               	STX	FAC2_2		; save string pointer low byte
  3478  9d36 84b6               	STY	FAC2_3		; save string pointer high byte
  3479  9d38 aa                 	TAX				; copy length
  3480  9d39 38                 	SEC				; set carry for subtract
  3481  9d3a e5ac               	SBC	str_ln		; subtract string 1 length
  3482  9d3c f008               	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
  3483                          
  3484  9d3e a901               	LDA	#$01			; set str 1 length > string 2 length
  3485  9d40 9004               	BCC	LAB_1CD6		; branch if so
  3486                          
  3487  9d42 a6ac               	LDX	str_ln		; get string 1 length
  3488  9d44 a9ff               	LDA	#$FF			; set str 1 length < string 2 length
  3489                          LAB_1CD6
  3490  9d46 85b0               	STA	FAC1_s		; save length compare
  3491  9d48 a0ff               	LDY	#$FF			; set index
  3492  9d4a e8                 	INX				; adjust for loop
  3493                          LAB_1CDB
  3494  9d4b c8                 	INY				; increment index
  3495  9d4c ca                 	DEX				; decrement count
  3496  9d4d d007               	BNE	LAB_1CE6		; branch if still bytes to do
  3497                          
  3498  9d4f a6b0               	LDX	FAC1_s		; get length compare back
  3499                          LAB_1CE1
  3500  9d51 300f               	BMI	LAB_1CF2		; branch if str 1 < str 2
  3501                          
  3502  9d53 18                 	CLC				; flag str 1 <= str 2
  3503  9d54 900c               	BCC	LAB_1CF2		; go evaluate result
  3504                          
  3505                          LAB_1CE6
  3506  9d56 b1b5               	LDA	(FAC2_2),Y		; get string 2 byte
  3507  9d58 d1ad               	CMP	(FAC1_1),Y		; compare with string 1 byte
  3508  9d5a f0ef               	BEQ	LAB_1CDB		; loop if bytes =
  3509                          
  3510  9d5c a2ff               	LDX	#$FF			; set str 1 < string 2
  3511  9d5e b002               	BCS	LAB_1CF2		; branch if so
  3512                          
  3513  9d60 a201               	LDX	#$01			;  set str 1 > string 2
  3514                          LAB_1CF2
  3515  9d62 e8                 	INX				; x = 0, 1 or 2
  3516  9d63 8a                 	TXA				; copy to A
  3517  9d64 2a                 	ROL				; *2 (1, 2 or 4)
  3518  9d65 2563               	AND	Cflag			; AND with comparison evaluation flag
  3519  9d67 f002               	BEQ	LAB_1CFB		; branch if 0 (compare is false)
  3520                          
  3521  9d69 a9ff               	LDA	#$FF			; else set result true
  3522                          LAB_1CFB
  3523  9d6b 4c0ca9             	JMP	LAB_27DB		; save A as integer byte and return
  3524                          
  3525                          LAB_1CFE
  3526  9d6e 20109c             	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
  3527                          
  3528                          ; perform DIM
  3529                          
  3530                          LAB_DIM
  3531  9d71 aa                 	TAX				; copy "DIM" flag to X
  3532  9d72 20c19d             	JSR	LAB_1D10		; search for variable
  3533  9d75 20c200             	JSR	LAB_GBYT		; scan memory
  3534  9d78 d0f4               	BNE	LAB_1CFE		; scan for "," and loop if not null
  3535                          
  3536  9d7a 60                 	RTS
  3537                          
  3538                          ; perform << (left shift)
  3539                          
  3540                          LAB_LSHIFT
  3541  9d7b 20b19d             	JSR	GetPair		; get integer expression and byte (no sign check)
  3542  9d7e a5ae               	LDA	FAC1_2		; get expression high byte
  3543  9d80 a678               	LDX	TempB			; get shift count
  3544  9d82 f022               	BEQ	NoShift		; branch if zero
  3545                          
  3546  9d84 e010               	CPX	#$10			; compare bit count with 16d
  3547  9d86 b023               	BCS	TooBig		; branch if >=
  3548                          
  3549                          Ls_loop
  3550  9d88 06af               	ASL	FAC1_3		; shift low byte
  3551  9d8a 2a                 	ROL				; shift high byte
  3552  9d8b ca                 	DEX				; decrement bit count
  3553  9d8c d0fa               	BNE	Ls_loop		; loop if shift not complete
  3554                          
  3555  9d8e a4af               	LDY	FAC1_3		; get expression low byte
  3556  9d90 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3557                          
  3558                          ; perform >> (right shift)
  3559                          
  3560                          LAB_RSHIFT
  3561  9d93 20b19d             	JSR	GetPair		; get integer expression and byte (no sign check)
  3562  9d96 a5ae               	LDA	FAC1_2		; get expression high byte
  3563  9d98 a678               	LDX	TempB			; get shift count
  3564  9d9a f00a               	BEQ	NoShift		; branch if zero
  3565                          
  3566  9d9c e010               	CPX	#$10			; compare bit count with 16d
  3567  9d9e b00b               	BCS	TooBig		; branch if >=
  3568                          
  3569                          Rs_loop
  3570  9da0 4a                 	LSR				; shift high byte
  3571  9da1 66af               	ROR	FAC1_3		; shift low byte
  3572  9da3 ca                 	DEX				; decrement bit count
  3573  9da4 d0fa               	BNE	Rs_loop		; loop if shift not complete
  3574                          
  3575                          NoShift
  3576  9da6 a4af               	LDY	FAC1_3		; get expression low byte
  3577  9da8 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3578                          
  3579                          TooBig
  3580  9dab a900               	LDA	#$00			; clear high byte
  3581  9dad a8                 	TAY				; copy to low byte
  3582  9dae 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3583                          
  3584                          GetPair
  3585  9db1 20a1a4             	JSR	LAB_EVBY		; evaluate byte expression, result in X
  3586  9db4 8678               	STX	TempB			; save it
  3587  9db6 20d5a5             	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3588  9db9 4cb89e             	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
  3589                          
  3590                          ; search for variable
  3591                          
  3592                          ; return pointer to variable in Cvaral/Cvarah
  3593                          
  3594                          LAB_GVAR
  3595  9dbc a200               	LDX	#$00			; set DIM flag = $00
  3596  9dbe 20c200             	JSR	LAB_GBYT		; scan memory (1st character)
  3597                          LAB_1D10
  3598  9dc1 865e               	STX	Defdim		; save DIM flag
  3599                          LAB_1D12
  3600  9dc3 8593               	STA	Varnm1		; save 1st character
  3601  9dc5 297f               	AND	#$7F			; clear FN flag bit
  3602  9dc7 20309e             	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
  3603  9dca b003               	BCS	LAB_1D1F		; branch if ok
  3604                          
  3605  9dcc 4c149c             	JMP	LAB_SNER		; else syntax error then warm start
  3606                          
  3607                          					; was variable name so ..
  3608                          LAB_1D1F
  3609  9dcf a200               	LDX	#$00			; clear 2nd character temp
  3610  9dd1 865f               	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
  3611  9dd3 20bc00             	JSR	LAB_IGBY		; increment and scan memory (2nd character)
  3612  9dd6 9005               	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
  3613                          
  3614                          					; 2nd character wasn't "0" to "9" so ..
  3615  9dd8 20309e             	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
  3616  9ddb 900b               	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
  3617                          
  3618                          LAB_1D2D
  3619  9ddd aa                 	TAX				; copy 2nd character
  3620                          
  3621                          					; ignore further (valid) characters in the variable name
  3622                          LAB_1D2E
  3623  9dde 20bc00             	JSR	LAB_IGBY		; increment and scan memory (3rd character)
  3624  9de1 90fb               	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
  3625                          
  3626  9de3 20309e             	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
  3627  9de6 b0f6               	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
  3628                          
  3629                          					; check if string variable
  3630                          LAB_1D38
  3631  9de8 c924               	CMP	#'$'			; compare with "$"
  3632  9dea d00b               	BNE	LAB_1D47		; branch if not string
  3633                          
  3634                          ; to introduce a new variable type (% suffix for integers say) then this branch
  3635                          ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3636                          
  3637                          					; type is string
  3638  9dec a9ff               	LDA	#$FF			; set data type = string
  3639  9dee 855f               	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
  3640  9df0 8a                 	TXA				; get 2nd character back
  3641  9df1 0980               	ORA	#$80			; set top bit (indicate string var)
  3642  9df3 aa                 	TAX				; copy back to 2nd character temp
  3643  9df4 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  3644                          
  3645                          ; after we have determined the variable type we need to come back here to determine
  3646                          ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3647                          
  3648                          
  3649                          LAB_1D47				; gets here with character after var name in A
  3650  9df7 8694               	STX	Varnm2		; save 2nd character
  3651  9df9 0561               	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
  3652  9dfb c928               	CMP	#'('			; compare with "("
  3653  9dfd d003               	BNE	LAB_1D53		; branch if not "("
  3654                          
  3655  9dff 4cca9e             	JMP	LAB_1E17		; go find, or make, array
  3656                          
  3657                          ; either find or create var
  3658                          ; var name (1st two characters only!) is in Varnm1,Varnm2
  3659                          
  3660                          					; variable name wasn't var(... so look for plain var
  3661                          LAB_1D53
  3662  9e02 a900               	LDA	#$00			; clear A
  3663  9e04 8561               	STA	Sufnxf		; clear subscript/FNX flag
  3664  9e06 a57b               	LDA	Svarl			; get start of vars low byte
  3665  9e08 a67c               	LDX	Svarh			; get start of vars high byte
  3666  9e0a a000               	LDY	#$00			; clear index
  3667                          LAB_1D5D
  3668  9e0c 86ab               	STX	Vrschh		; save search address high byte
  3669                          LAB_1D5F
  3670  9e0e 85aa               	STA	Vrschl		; save search address low byte
  3671  9e10 e47e               	CPX	Sarryh		; compare high address with var space end
  3672  9e12 d004               	BNE	LAB_1D69		; skip next compare if <>
  3673                          
  3674                          					; high addresses were = so compare low addresses
  3675  9e14 c57d               	CMP	Sarryl		; compare low address with var space end
  3676  9e16 f02c               	BEQ	LAB_1D8B		; if not found go make new var
  3677                          
  3678                          LAB_1D69
  3679  9e18 a593               	LDA	Varnm1		; get 1st character of var to find
  3680  9e1a d1aa               	CMP	(Vrschl),Y		; compare with variable name 1st character
  3681  9e1c d008               	BNE	LAB_1D77		; branch if no match
  3682                          
  3683                          					; 1st characters match so compare 2nd characters
  3684  9e1e a594               	LDA	Varnm2		; get 2nd character of var to find
  3685  9e20 c8                 	INY				; index to point to variable name 2nd character
  3686  9e21 d1aa               	CMP	(Vrschl),Y		; compare with variable name 2nd character
  3687  9e23 f069               	BEQ	LAB_1DD7		; branch if match (found var)
  3688                          
  3689  9e25 88                 	DEY				; else decrement index (now = $00)
  3690                          LAB_1D77
  3691  9e26 18                 	CLC				; clear carry for add
  3692  9e27 a5aa               	LDA	Vrschl		; get search address low byte
  3693  9e29 6906               	ADC	#$06			; +6 (offset to next var name)
  3694  9e2b 90e1               	BCC	LAB_1D5F		; loop if no overflow to high byte
  3695                          
  3696  9e2d e8                 	INX				; else increment high byte
  3697  9e2e d0dc               	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
  3698                          
  3699                          ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
  3700                          
  3701                          LAB_CASC
  3702  9e30 c961               	CMP	#'a'			; compare with "a"
  3703  9e32 b00a               	BCS	LAB_1D83		; go check <"z"+1
  3704                          
  3705                          ; check byte, return C=0 if<"A" or >"Z"
  3706                          
  3707                          LAB_1D82
  3708  9e34 c941               	CMP	#'A'			; compare with "A"
  3709  9e36 9005               	BCC	LAB_1D8A		; exit if less
  3710                          
  3711                          					; carry is set
  3712  9e38 e95b               	SBC	#$5B			; subtract "Z"+1
  3713  9e3a 38                 	SEC				; set carry
  3714  9e3b e9a5               	SBC	#$A5			; subtract $A5 (restore byte)
  3715                          					; carry clear if byte>$5A
  3716                          LAB_1D8A
  3717  9e3d 60                 	RTS
  3718                          
  3719                          LAB_1D83
  3720  9e3e e97b               	SBC	#$7B			; subtract "z"+1
  3721  9e40 38                 	SEC				; set carry
  3722  9e41 e985               	SBC	#$85			; subtract $85 (restore byte)
  3723                          					; carry clear if byte>$7A
  3724  9e43 60                 	RTS
  3725                          
  3726                          					; reached end of variable mem without match
  3727                          					; .. so create new variable
  3728                          LAB_1D8B
  3729  9e44 68                 	PLA				; pop return address low byte
  3730  9e45 48                 	PHA				; push return address low byte
  3731                          LAB_1C18p2	= LAB_1C18+2
  3732  9e46 c94f               	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
  3733  9e48 d005               	BNE	LAB_1D98		; if not get (var) go create new var
  3734                          
  3735                          ; This will only drop through if the call was from LAB_1C18 and is only called
  3736                          ; from there if it is searching for a variable from the RHS of a LET a=b statement
  3737                          ; it prevents the creation of variables not assigned a value.
  3738                          
  3739                          ; value returned by this is either numeric zero (exponent byte is $00) or null string
  3740                          ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3741                          
  3742                          ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3743                          
  3744                          ; this is where you would put the undefined variable error call e.g.
  3745                          
  3746                          ;					; variable doesn't exist so flag error
  3747                          ;	LDX	#$24			; error code $24 ("undefined variable" error)
  3748                          ;	JMP	LAB_XERR		; do error #X then warm start
  3749                          
  3750                          ; the above code has been tested and works a treat! (it replaces the three code lines
  3751                          ; below)
  3752                          
  3753                          					; else return dummy null value
  3754  9e4a a9e4               	LDA	#<LAB_1D96		; low byte point to $00,$00
  3755                          					; (uses part of misc constants table)
  3756  9e4c a0b1               	LDY	#>LAB_1D96		; high byte point to $00,$00
  3757  9e4e 60                 	RTS
  3758                          
  3759                          					; create new numeric variable
  3760                          LAB_1D98
  3761  9e4f a57d               	LDA	Sarryl		; get var mem end low byte
  3762  9e51 a47e               	LDY	Sarryh		; get var mem end high byte
  3763  9e53 85aa               	STA	Ostrtl		; save old block start low byte
  3764  9e55 84ab               	STY	Ostrth		; save old block start high byte
  3765  9e57 a57f               	LDA	Earryl		; get array mem end low byte
  3766  9e59 a480               	LDY	Earryh		; get array mem end high byte
  3767  9e5b 85a6               	STA	Obendl		; save old block end low byte
  3768  9e5d 84a7               	STY	Obendh		; save old block end high byte
  3769  9e5f 18                 	CLC				; clear carry for add
  3770  9e60 6906               	ADC	#$06			; +6 (space for one var)
  3771  9e62 9001               	BCC	LAB_1DAE		; branch if no overflow to high byte
  3772                          
  3773  9e64 c8                 	INY				; else increment high byte
  3774                          LAB_1DAE
  3775  9e65 85a4               	STA	Nbendl		; set new block end low byte
  3776  9e67 84a5               	STY	Nbendh		; set new block end high byte
  3777  9e69 20cc90             	JSR	LAB_11CF		; open up space in memory
  3778  9e6c a5a4               	LDA	Nbendl		; get new start low byte
  3779  9e6e a4a5               	LDY	Nbendh		; get new start high byte (-$100)
  3780  9e70 c8                 	INY				; correct high byte
  3781  9e71 857d               	STA	Sarryl		; save new var mem end low byte
  3782  9e73 847e               	STY	Sarryh		; save new var mem end high byte
  3783  9e75 a000               	LDY	#$00			; clear index
  3784  9e77 a593               	LDA	Varnm1		; get var name 1st character
  3785  9e79 91aa               	STA	(Vrschl),Y		; save var name 1st character
  3786  9e7b c8                 	INY				; increment index
  3787  9e7c a594               	LDA	Varnm2		; get var name 2nd character
  3788  9e7e 91aa               	STA	(Vrschl),Y		; save var name 2nd character
  3789  9e80 a900               	LDA	#$00			; clear A
  3790  9e82 c8                 	INY				; increment index
  3791  9e83 91aa               	STA	(Vrschl),Y		; initialise var byte
  3792  9e85 c8                 	INY				; increment index
  3793  9e86 91aa               	STA	(Vrschl),Y		; initialise var byte
  3794  9e88 c8                 	INY				; increment index
  3795  9e89 91aa               	STA	(Vrschl),Y		; initialise var byte
  3796  9e8b c8                 	INY				; increment index
  3797  9e8c 91aa               	STA	(Vrschl),Y		; initialise var byte
  3798                          
  3799                          					; found a match for var ((Vrschl) = ptr)
  3800                          LAB_1DD7
  3801  9e8e a5aa               	LDA	Vrschl		; get var address low byte
  3802  9e90 18                 	CLC				; clear carry for add
  3803  9e91 6902               	ADC	#$02			; +2 (offset past var name bytes)
  3804  9e93 a4ab               	LDY	Vrschh		; get var address high byte
  3805  9e95 9001               	BCC	LAB_1DE1		; branch if no overflow from add
  3806                          
  3807  9e97 c8                 	INY				; else increment high byte
  3808                          LAB_1DE1
  3809  9e98 8595               	STA	Cvaral		; save current var address low byte
  3810  9e9a 8496               	STY	Cvarah		; save current var address high byte
  3811  9e9c 60                 	RTS
  3812                          
  3813                          ; set-up array pointer (Adatal/h) to first element in array
  3814                          ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3815                          
  3816                          LAB_1DE6
  3817  9e9d a55d               	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
  3818  9e9f 0a                 	ASL				; *2 (also clears the carry !)
  3819  9ea0 6905               	ADC	#$05			; +5 (result is 7, 9 or 11 here)
  3820  9ea2 65aa               	ADC	Astrtl		; add array start pointer low byte
  3821  9ea4 a4ab               	LDY	Astrth		; get array pointer high byte
  3822  9ea6 9001               	BCC	LAB_1DF2		; branch if no overflow
  3823                          
  3824  9ea8 c8                 	INY				; else increment high byte
  3825                          LAB_1DF2
  3826  9ea9 85a4               	STA	Adatal		; save array data pointer low byte
  3827  9eab 84a5               	STY	Adatah		; save array data pointer high byte
  3828  9ead 60                 	RTS
  3829                          
  3830                          ; evaluate integer expression
  3831                          
  3832                          LAB_EVIN
  3833  9eae 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  3834  9eb1 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3835                          					; else do type mismatch
  3836                          
  3837                          ; evaluate integer expression (no check)
  3838                          
  3839                          LAB_EVPI
  3840  9eb4 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  3841  9eb6 300d               	BMI	LAB_1E12		; do function call error if -ve
  3842                          
  3843                          ; evaluate integer expression (no sign check)
  3844                          
  3845                          LAB_EVIR
  3846  9eb8 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  3847  9eba c990               	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
  3848  9ebc 9009               	BCC	LAB_1E14		; branch if n<2^16 (is ok)
  3849                          
  3850  9ebe a9eb               	LDA	#<LAB_1DF7		; set pointer low byte to -32768
  3851  9ec0 a0b1               	LDY	#>LAB_1DF7		; set pointer high byte to -32768
  3852  9ec2 2029a9             	JSR	LAB_27F8		; compare FAC1 with (AY)
  3853                          LAB_1E12
  3854  9ec5 d074               	BNE	LAB_FCER		; if <> do function call error then warm start
  3855                          
  3856                          LAB_1E14
  3857  9ec7 4c62a9             	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
  3858                          
  3859                          ; find or make array
  3860                          
  3861                          LAB_1E17
  3862  9eca a55e               	LDA	Defdim		; get DIM flag
  3863  9ecc 48                 	PHA				; push it
  3864  9ecd a55f               	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
  3865  9ecf 48                 	PHA				; push it
  3866  9ed0 a000               	LDY	#$00			; clear dimensions count
  3867                          
  3868                          ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3869                          
  3870                          LAB_1E1F
  3871  9ed2 98                 	TYA				; copy dimensions count
  3872  9ed3 48                 	PHA				; save it
  3873  9ed4 a594               	LDA	Varnm2		; get array name 2nd byte
  3874  9ed6 48                 	PHA				; save it
  3875  9ed7 a593               	LDA	Varnm1		; get array name 1st byte
  3876  9ed9 48                 	PHA				; save it
  3877  9eda 20ae9e             	JSR	LAB_EVIN		; evaluate integer expression
  3878  9edd 68                 	PLA				; pull array name 1st byte
  3879  9ede 8593               	STA	Varnm1		; restore array name 1st byte
  3880  9ee0 68                 	PLA				; pull array name 2nd byte
  3881  9ee1 8594               	STA	Varnm2		; restore array name 2nd byte
  3882  9ee3 68                 	PLA				; pull dimensions count
  3883  9ee4 a8                 	TAY				; restore it
  3884  9ee5 ba                 	TSX				; copy stack pointer
  3885  9ee6 bd0201             	LDA	LAB_STAK+2,X	; get DIM flag
  3886  9ee9 48                 	PHA				; push it
  3887  9eea bd0101             	LDA	LAB_STAK+1,X	; get data type flag
  3888  9eed 48                 	PHA				; push it
  3889  9eee a5ae               	LDA	FAC1_2		; get this dimension size high byte
  3890  9ef0 9d0201             	STA	LAB_STAK+2,X	; stack before flag bytes
  3891  9ef3 a5af               	LDA	FAC1_3		; get this dimension size low byte
  3892  9ef5 9d0101             	STA	LAB_STAK+1,X	; stack before flag bytes
  3893  9ef8 c8                 	INY				; increment dimensions count
  3894  9ef9 20c200             	JSR	LAB_GBYT		; scan memory
  3895  9efc c92c               	CMP	#','			; compare with ","
  3896  9efe f0d2               	BEQ	LAB_1E1F		; if found go do next dimension
  3897                          
  3898  9f00 845d               	STY	Dimcnt		; store dimensions count
  3899  9f02 20019c             	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  3900  9f05 68                 	PLA				; pull data type flag
  3901  9f06 855f               	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
  3902  9f08 68                 	PLA				; pull DIM flag
  3903  9f09 855e               	STA	Defdim		; restore DIM flag
  3904  9f0b a67d               	LDX	Sarryl		; get array mem start low byte
  3905  9f0d a57e               	LDA	Sarryh		; get array mem start high byte
  3906                          
  3907                          ; now check to see if we are at the end of array memory (we would be if there were
  3908                          ; no arrays).
  3909                          
  3910                          LAB_1E5C
  3911  9f0f 86aa               	STX	Astrtl		; save as array start pointer low byte
  3912  9f11 85ab               	STA	Astrth		; save as array start pointer high byte
  3913  9f13 c580               	CMP	Earryh		; compare with array mem end high byte
  3914  9f15 d004               	BNE	LAB_1E68		; branch if not reached array mem end
  3915                          
  3916  9f17 e47f               	CPX	Earryl		; else compare with array mem end low byte
  3917  9f19 f039               	BEQ	LAB_1EA1		; go build array if not found
  3918                          
  3919                          					; search for array
  3920                          LAB_1E68
  3921  9f1b a000               	LDY	#$00			; clear index
  3922  9f1d b1aa               	LDA	(Astrtl),Y		; get array name first byte
  3923  9f1f c8                 	INY				; increment index to second name byte
  3924  9f20 c593               	CMP	Varnm1		; compare with this array name first byte
  3925  9f22 d006               	BNE	LAB_1E77		; branch if no match
  3926                          
  3927  9f24 a594               	LDA	Varnm2		; else get this array name second byte
  3928  9f26 d1aa               	CMP	(Astrtl),Y		; compare with array name second byte
  3929  9f28 f016               	BEQ	LAB_1E8D		; array found so branch
  3930                          
  3931                          					; no match
  3932                          LAB_1E77
  3933  9f2a c8                 	INY				; increment index
  3934  9f2b b1aa               	LDA	(Astrtl),Y		; get array size low byte
  3935  9f2d 18                 	CLC				; clear carry for add
  3936  9f2e 65aa               	ADC	Astrtl		; add array start pointer low byte
  3937  9f30 aa                 	TAX				; copy low byte to X
  3938  9f31 c8                 	INY				; increment index
  3939  9f32 b1aa               	LDA	(Astrtl),Y		; get array size high byte
  3940  9f34 65ab               	ADC	Astrth		; add array mem pointer high byte
  3941  9f36 90d7               	BCC	LAB_1E5C		; if no overflow go check next array
  3942                          
  3943                          ; do array bounds error
  3944                          
  3945                          LAB_1E85
  3946  9f38 a210               	LDX	#$10			; error code $10 ("Array bounds" error)
  3947  9f3a 2c                 	!text	$2C			; makes next bit BIT LAB_08A2
  3948                          
  3949                          ; do function call error
  3950                          
  3951                          LAB_FCER
  3952  9f3b a208               	LDX	#$08			; error code $08 ("Function call" error)
  3953                          LAB_1E8A
  3954  9f3d 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  3955                          
  3956                          					; found array, are we trying to dimension it?
  3957                          LAB_1E8D
  3958  9f40 a212               	LDX	#$12			; set error $12 ("Double dimension" error)
  3959  9f42 a55e               	LDA	Defdim		; get DIM flag
  3960  9f44 d0f7               	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
  3961                          					; start
  3962                          
  3963                          ; found the array and we're not dimensioning it so we must find an element in it
  3964                          
  3965  9f46 209d9e             	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3966                          					; (Astrtl,Astrth points to start of array)
  3967  9f49 a55d               	LDA	Dimcnt		; get dimensions count
  3968  9f4b a004               	LDY	#$04			; set index to array's # of dimensions
  3969  9f4d d1aa               	CMP	(Astrtl),Y		; compare with no of dimensions
  3970  9f4f d0e7               	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
  3971                          					; dimensions" error here .. if we want a different
  3972                          					; error message
  3973                          
  3974  9f51 4cd79f             	JMP	LAB_1F28		; found array so go get element
  3975                          					; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3976                          					; Dimcnt and save it at (Astrtl),Y which is already the
  3977                          					; same or we would have taken the BNE)
  3978                          
  3979                          					; array not found, so build it
  3980                          LAB_1EA1
  3981  9f54 209d9e             	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
  3982                          					; (Astrtl,Astrth points to start of array)
  3983  9f57 201691             	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
  3984                          					; addr to check is in AY (low/high)
  3985  9f5a a000               	LDY	#$00			; clear Y (don't need to clear A)
  3986  9f5c 84bb               	STY	Aspth			; clear array data size high byte
  3987  9f5e a593               	LDA	Varnm1		; get variable name 1st byte
  3988  9f60 91aa               	STA	(Astrtl),Y		; save array name 1st byte
  3989  9f62 c8                 	INY				; increment index
  3990  9f63 a594               	LDA	Varnm2		; get variable name 2nd byte
  3991  9f65 91aa               	STA	(Astrtl),Y		; save array name 2nd byte
  3992  9f67 a55d               	LDA	Dimcnt		; get dimensions count
  3993  9f69 a004               	LDY	#$04			; index to dimension count
  3994  9f6b 84ba               	STY	Asptl			; set array data size low byte (four bytes per element)
  3995  9f6d 91aa               	STA	(Astrtl),Y		; set array's dimensions count
  3996                          
  3997                          					; now calculate the size of the data space for the array
  3998  9f6f 18                 	CLC				; clear carry for add (clear on subsequent loops)
  3999                          LAB_1EC0
  4000  9f70 a20b               	LDX	#$0B			; set default dimension value low byte
  4001  9f72 a900               	LDA	#$00			; set default dimension value high byte
  4002  9f74 245e               	BIT	Defdim		; test default DIM flag
  4003  9f76 5007               	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
  4004                          
  4005  9f78 68                 	PLA				; else pull dimension value low byte
  4006  9f79 6901               	ADC	#$01			; +1 (allow for zeroeth element)
  4007  9f7b aa                 	TAX				; copy low byte to X
  4008  9f7c 68                 	PLA				; pull dimension value high byte
  4009  9f7d 6900               	ADC	#$00			; add carry from low byte
  4010                          
  4011                          LAB_1ED0
  4012  9f7f c8                 	INY				; index to dimension value high byte
  4013  9f80 91aa               	STA	(Astrtl),Y		; save dimension value high byte
  4014  9f82 c8                 	INY				; index to dimension value high byte
  4015  9f83 8a                 	TXA				; get dimension value low byte
  4016  9f84 91aa               	STA	(Astrtl),Y		; save dimension value low byte
  4017  9f86 2026a0             	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  4018  9f89 86ba               	STX	Asptl			; save array data size low byte
  4019  9f8b 85bb               	STA	Aspth			; save array data size high byte
  4020  9f8d a471               	LDY	ut1_pl		; restore index (saved by subroutine)
  4021  9f8f c65d               	DEC	Dimcnt		; decrement dimensions count
  4022  9f91 d0dd               	BNE	LAB_1EC0		; loop while not = 0
  4023                          
  4024  9f93 65a5               	ADC	Adatah		; add size high byte to first element high byte
  4025                          					; (carry is always clear here)
  4026  9f95 b05d               	BCS	LAB_1F45		; if overflow go do "Out of memory" error
  4027                          
  4028  9f97 85a5               	STA	Adatah		; save end of array high byte
  4029  9f99 a8                 	TAY				; copy end high byte to Y
  4030  9f9a 8a                 	TXA				; get array size low byte
  4031  9f9b 65a4               	ADC	Adatal		; add array start low byte
  4032  9f9d 9003               	BCC	LAB_1EF3		; branch if no carry
  4033                          
  4034  9f9f c8                 	INY				; else increment end of array high byte
  4035  9fa0 f052               	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
  4036                          
  4037                          					; set-up mostly complete, now zero the array
  4038                          LAB_1EF3
  4039  9fa2 201691             	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
  4040                          					; addr to check is in AY (low/high)
  4041  9fa5 857f               	STA	Earryl		; save array mem end low byte
  4042  9fa7 8480               	STY	Earryh		; save array mem end high byte
  4043  9fa9 a900               	LDA	#$00			; clear byte for array clear
  4044  9fab e6bb               	INC	Aspth			; increment array size high byte (now block count)
  4045  9fad a4ba               	LDY	Asptl			; get array size low byte (now index to block)
  4046  9faf f005               	BEQ	LAB_1F07		; branch if low byte = $00
  4047                          
  4048                          LAB_1F02
  4049  9fb1 88                 	DEY				; decrement index (do 0 to n-1)
  4050  9fb2 91a4               	STA	(Adatal),Y		; zero byte
  4051  9fb4 d0fb               	BNE	LAB_1F02		; loop until this block done
  4052                          
  4053                          LAB_1F07
  4054  9fb6 c6a5               	DEC	Adatah		; decrement array pointer high byte
  4055  9fb8 c6bb               	DEC	Aspth			; decrement block count high byte
  4056  9fba d0f5               	BNE	LAB_1F02		; loop until all blocks done
  4057                          
  4058  9fbc e6a5               	INC	Adatah		; correct for last loop
  4059  9fbe 38                 	SEC				; set carry for subtract
  4060  9fbf a002               	LDY	#$02			; index to array size low byte
  4061  9fc1 a57f               	LDA	Earryl		; get array mem end low byte
  4062  9fc3 e5aa               	SBC	Astrtl		; subtract array start low byte
  4063  9fc5 91aa               	STA	(Astrtl),Y		; save array size low byte
  4064  9fc7 c8                 	INY				; index to array size high byte
  4065  9fc8 a580               	LDA	Earryh		; get array mem end high byte
  4066  9fca e5ab               	SBC	Astrth		; subtract array start high byte
  4067  9fcc 91aa               	STA	(Astrtl),Y		; save array size high byte
  4068  9fce a55e               	LDA	Defdim		; get default DIM flag
  4069  9fd0 d053               	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
  4070                          
  4071                          					; else, find element
  4072  9fd2 c8                 	INY				; index to # of dimensions
  4073                          
  4074                          LAB_1F24
  4075  9fd3 b1aa               	LDA	(Astrtl),Y		; get array's dimension count
  4076  9fd5 855d               	STA	Dimcnt		; save it
  4077                          
  4078                          ; we have found, or built, the array. now we need to find the element
  4079                          
  4080                          LAB_1F28
  4081  9fd7 a900               	LDA	#$00			; clear byte
  4082  9fd9 85ba               	STA	Asptl			; clear array data pointer low byte
  4083                          LAB_1F2C
  4084  9fdb 85bb               	STA	Aspth			; save array data pointer high byte
  4085  9fdd c8                 	INY				; increment index (point to array bound high byte)
  4086  9fde 68                 	PLA				; pull array index low byte
  4087  9fdf aa                 	TAX				; copy to X
  4088  9fe0 85ae               	STA	FAC1_2		; save index low byte to FAC1 mantissa2
  4089  9fe2 68                 	PLA				; pull array index high byte
  4090  9fe3 85af               	STA	FAC1_3		; save index high byte to FAC1 mantissa3
  4091  9fe5 d1aa               	CMP	(Astrtl),Y		; compare with array bound high byte
  4092  9fe7 900e               	BCC	LAB_1F48		; branch if within bounds
  4093                          
  4094  9fe9 d006               	BNE	LAB_1F42		; if outside bounds do array bounds error
  4095                          
  4096                          					; else high byte was = so test low bytes
  4097  9feb c8                 	INY				; index to array bound low byte
  4098  9fec 8a                 	TXA				; get array index low byte
  4099  9fed d1aa               	CMP	(Astrtl),Y		; compare with array bound low byte
  4100  9fef 9007               	BCC	LAB_1F49		; branch if within bounds
  4101                          
  4102                          LAB_1F42
  4103  9ff1 4c389f             	JMP	LAB_1E85		; else do array bounds error
  4104                          
  4105                          LAB_1F45
  4106  9ff4 4c4591             	JMP	LAB_OMER		; do "Out of memory" error then warm start
  4107                          
  4108                          LAB_1F48
  4109  9ff7 c8                 	INY				; index to array bound low byte
  4110                          LAB_1F49
  4111  9ff8 a5bb               	LDA	Aspth			; get array data pointer high byte
  4112  9ffa 05ba               	ORA	Asptl			; OR with array data pointer low byte
  4113  9ffc f00a               	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
  4114                          
  4115  9ffe 2026a0             	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
  4116  a001 8a                 	TXA				; get result low byte
  4117  a002 65ae               	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
  4118  a004 aa                 	TAX				; save result low byte
  4119  a005 98                 	TYA				; get result high byte
  4120  a006 a471               	LDY	ut1_pl		; restore index
  4121                          LAB_1F5A
  4122  a008 65af               	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
  4123  a00a 86ba               	STX	Asptl			; save array data pointer low byte
  4124  a00c c65d               	DEC	Dimcnt		; decrement dimensions count
  4125  a00e d0cb               	BNE	LAB_1F2C		; loop if dimensions still to do
  4126                          
  4127  a010 06ba               	ASL	Asptl			; array data pointer low byte * 2
  4128  a012 2a                 	ROL				; array data pointer high byte * 2
  4129  a013 06ba               	ASL	Asptl			; array data pointer low byte * 4
  4130  a015 2a                 	ROL				; array data pointer high byte * 4
  4131  a016 a8                 	TAY				; copy high byte
  4132  a017 a5ba               	LDA	Asptl			; get low byte
  4133  a019 65a4               	ADC	Adatal		; add array data start pointer low byte
  4134  a01b 8595               	STA	Cvaral		; save as current var address low byte
  4135  a01d 98                 	TYA				; get high byte back
  4136  a01e 65a5               	ADC	Adatah		; add array data start pointer high byte
  4137  a020 8596               	STA	Cvarah		; save as current var address high byte
  4138  a022 a8                 	TAY				; copy high byte to Y
  4139  a023 a595               	LDA	Cvaral		; get current var address low byte
  4140                          LAB_1F7B
  4141  a025 60                 	RTS
  4142                          
  4143                          ; does XY = (Astrtl),Y * (Asptl)
  4144                          
  4145                          LAB_1F7C
  4146  a026 8471               	STY	ut1_pl		; save index
  4147  a028 b1aa               	LDA	(Astrtl),Y		; get dimension size low byte
  4148  a02a 8576               	STA	dims_l		; save dimension size low byte
  4149  a02c 88                 	DEY				; decrement index
  4150  a02d b1aa               	LDA	(Astrtl),Y		; get dimension size high byte
  4151  a02f 8577               	STA	dims_h		; save dimension size high byte
  4152                          
  4153  a031 a910               	LDA	#$10			; count = $10 (16 bit multiply)
  4154  a033 85a8               	STA	numbit		; save bit count
  4155  a035 a200               	LDX	#$00			; clear result low byte
  4156  a037 a000               	LDY	#$00			; clear result high byte
  4157                          LAB_1F8F
  4158  a039 8a                 	TXA				; get result low byte
  4159  a03a 0a                 	ASL				; *2
  4160  a03b aa                 	TAX				; save result low byte
  4161  a03c 98                 	TYA				; get result high byte
  4162  a03d 2a                 	ROL				; *2
  4163  a03e a8                 	TAY				; save result high byte
  4164  a03f b0b3               	BCS	LAB_1F45		; if overflow go do "Out of memory" error
  4165                          
  4166  a041 06ba               	ASL	Asptl			; shift multiplier low byte
  4167  a043 26bb               	ROL	Aspth			; shift multiplier high byte
  4168  a045 900b               	BCC	LAB_1FA8		; skip add if no carry
  4169                          
  4170  a047 18                 	CLC				; else clear carry for add
  4171  a048 8a                 	TXA				; get result low byte
  4172  a049 6576               	ADC	dims_l		; add dimension size low byte
  4173  a04b aa                 	TAX				; save result low byte
  4174  a04c 98                 	TYA				; get result high byte
  4175  a04d 6577               	ADC	dims_h		; add dimension size high byte
  4176  a04f a8                 	TAY				; save result high byte
  4177  a050 b0a2               	BCS	LAB_1F45		; if overflow go do "Out of memory" error
  4178                          
  4179                          LAB_1FA8
  4180  a052 c6a8               	DEC	numbit		; decrement bit count
  4181  a054 d0e3               	BNE	LAB_1F8F		; loop until all done
  4182                          
  4183  a056 60                 	RTS
  4184                          
  4185                          ; perform FRE()
  4186                          
  4187                          LAB_FRE
  4188  a057 a55f               	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
  4189  a059 1003               	BPL	LAB_1FB4		; branch if numeric
  4190                          
  4191  a05b 2050a3             	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  4192                          					; space returns with A = length, X=$71=pointer low byte,
  4193                          					; Y=$72=pointer high byte
  4194                          
  4195                          					; FRE(n) was numeric so do this
  4196                          LAB_1FB4
  4197  a05e 20f1a1             	JSR	LAB_GARB		; go do garbage collection
  4198  a061 38                 	SEC				; set carry for subtract
  4199  a062 a581               	LDA	Sstorl		; get bottom of string space low byte
  4200  a064 e57f               	SBC	Earryl		; subtract array mem end low byte
  4201  a066 a8                 	TAY				; copy result to Y
  4202  a067 a582               	LDA	Sstorh		; get bottom of string space high byte
  4203  a069 e580               	SBC	Earryh		; subtract array mem end high byte
  4204                          
  4205                          ; save and convert integer AY to FAC1
  4206                          
  4207                          LAB_AYFC
  4208  a06b 465f               	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
  4209  a06d 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  4210  a06f 84ae               	STY	FAC1_2		; save FAC1 mantissa2
  4211  a071 a290               	LDX	#$90			; set exponent=2^16 (integer)
  4212  a073 4c14a9             	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
  4213                          
  4214                          ; perform POS()
  4215                          
  4216                          LAB_POS
  4217  a076 a40e               	LDY	TPos			; get terminal position
  4218                          
  4219                          ; convert Y to byte in FAC1
  4220                          
  4221                          LAB_1FD0
  4222  a078 a900               	LDA	#$00			; clear high byte
  4223  a07a f0ef               	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
  4224                          
  4225                          ; check not Direct (used by DEF and INPUT)
  4226                          
  4227                          LAB_CKRN
  4228  a07c a688               	LDX	Clineh		; get current line high byte
  4229  a07e e8                 	INX				; increment it
  4230  a07f d0a4               	BNE	LAB_1F7B		; return if can continue not direct mode
  4231                          
  4232                          					; else do illegal direct error
  4233                          LAB_1FD9
  4234  a081 a216               	LDX	#$16			; error code $16 ("Illegal direct" error)
  4235                          LAB_1FDB
  4236  a083 4c4791             	JMP	LAB_XERR		; go do error #X, then warm start
  4237                          
  4238                          ; perform DEF
  4239                          
  4240                          LAB_DEF
  4241  a086 20b7a0             	JSR	LAB_200B		; check FNx syntax
  4242  a089 859c               	STA	func_l		; save function pointer low byte
  4243  a08b 849d               	STY	func_h		; save function pointer high byte
  4244  a08d 207ca0             	JSR	LAB_CKRN		; check not Direct (back here if ok)
  4245  a090 200c9c             	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
  4246  a093 a980               	LDA	#$80			; set flag for FNx
  4247  a095 8561               	STA	Sufnxf		; save subscript/FNx flag
  4248  a097 20bc9d             	JSR	LAB_GVAR		; get (var) address
  4249  a09a 20e29a             	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4250  a09d 20019c             	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  4251  a0a0 a9c1               	LDA	#TK_EQUAL		; get = token
  4252  a0a2 20039c             	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  4253  a0a5 a596               	LDA	Cvarah		; get current var address high byte
  4254  a0a7 48                 	PHA				; push it
  4255  a0a8 a595               	LDA	Cvaral		; get current var address low byte
  4256  a0aa 48                 	PHA				; push it
  4257  a0ab a5c4               	LDA	Bpntrh		; get BASIC execute pointer high byte
  4258  a0ad 48                 	PHA				; push it
  4259  a0ae a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  4260  a0b0 48                 	PHA				; push it
  4261  a0b1 20a396             	JSR	LAB_DATA		; go perform DATA
  4262  a0b4 4c26a1             	JMP	LAB_207A		; put execute pointer and variable pointer into function
  4263                          					; and return
  4264                          
  4265                          ; check FNx syntax
  4266                          
  4267                          LAB_200B
  4268  a0b7 a9ae               	LDA	#TK_FN		; get FN" token
  4269  a0b9 20039c             	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  4270                          					; return character after A
  4271  a0bc 0980               	ORA	#$80			; set FN flag bit
  4272  a0be 8561               	STA	Sufnxf		; save FN flag so array variable test fails
  4273  a0c0 20c39d             	JSR	LAB_1D12		; search for FN variable
  4274  a0c3 4ce29a             	JMP	LAB_CTNM		; check if source is numeric and return, else do type
  4275                          					; mismatch
  4276                          
  4277                          					; Evaluate FNx
  4278                          LAB_201E
  4279  a0c6 20b7a0             	JSR	LAB_200B		; check FNx syntax
  4280  a0c9 48                 	PHA				; push function pointer low byte
  4281  a0ca 98                 	TYA				; copy function pointer high byte
  4282  a0cb 48                 	PHA				; push function pointer high byte
  4283  a0cc 200c9c             	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
  4284  a0cf 20f39a             	JSR	LAB_EVEX		; evaluate expression
  4285  a0d2 20019c             	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
  4286  a0d5 20e29a             	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4287  a0d8 68                 	PLA				; pop function pointer high byte
  4288  a0d9 859d               	STA	func_h		; restore it
  4289  a0db 68                 	PLA				; pop function pointer low byte
  4290  a0dc 859c               	STA	func_l		; restore it
  4291  a0de a220               	LDX	#$20			; error code $20 ("Undefined function" error)
  4292  a0e0 a003               	LDY	#$03			; index to variable pointer high byte
  4293  a0e2 b19c               	LDA	(func_l),Y		; get variable pointer high byte
  4294  a0e4 f09d               	BEQ	LAB_1FDB		; if zero go do undefined function error
  4295                          
  4296  a0e6 8596               	STA	Cvarah		; save variable address high byte
  4297  a0e8 88                 	DEY				; index to variable address low byte
  4298  a0e9 b19c               	LDA	(func_l),Y		; get variable address low byte
  4299  a0eb 8595               	STA	Cvaral		; save variable address low byte
  4300  a0ed aa                 	TAX				; copy address low byte
  4301                          
  4302                          					; now stack the function variable value before use
  4303  a0ee c8                 	INY				; index to mantissa_3
  4304                          LAB_2043
  4305  a0ef b195               	LDA	(Cvaral),Y		; get byte from variable
  4306  a0f1 48                 	PHA				; stack it
  4307  a0f2 88                 	DEY				; decrement index
  4308  a0f3 10fa               	BPL	LAB_2043		; loop until variable stacked
  4309                          
  4310  a0f5 a496               	LDY	Cvarah		; get variable address high byte
  4311  a0f7 20b9a8             	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
  4312                          					; (function variable), return Y=0, always
  4313  a0fa a5c4               	LDA	Bpntrh		; get BASIC execute pointer high byte
  4314  a0fc 48                 	PHA				; push it
  4315  a0fd a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  4316  a0ff 48                 	PHA				; push it
  4317  a100 b19c               	LDA	(func_l),Y		; get function execute pointer low byte
  4318  a102 85c3               	STA	Bpntrl		; save as BASIC execute pointer low byte
  4319  a104 c8                 	INY				; index to high byte
  4320  a105 b19c               	LDA	(func_l),Y		; get function execute pointer high byte
  4321  a107 85c4               	STA	Bpntrh		; save as BASIC execute pointer high byte
  4322  a109 a596               	LDA	Cvarah		; get variable address high byte
  4323  a10b 48                 	PHA				; push it
  4324  a10c a595               	LDA	Cvaral		; get variable address low byte
  4325  a10e 48                 	PHA				; push it
  4326  a10f 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4327                          					; else do type mismatch
  4328  a112 68                 	PLA				; pull variable address low byte
  4329  a113 859c               	STA	func_l		; save variable address low byte
  4330  a115 68                 	PLA				; pull variable address high byte
  4331  a116 859d               	STA	func_h		; save variable address high byte
  4332  a118 20c200             	JSR	LAB_GBYT		; scan memory
  4333  a11b f003               	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
  4334                          
  4335  a11d 4c149c             	JMP	LAB_SNER		; else syntax error then warm start
  4336                          
  4337                          ; restore Bpntrl,Bpntrh and function variable from stack
  4338                          
  4339                          LAB_2074
  4340  a120 68                 	PLA				; pull BASIC execute pointer low byte
  4341  a121 85c3               	STA	Bpntrl		; restore BASIC execute pointer low byte
  4342  a123 68                 	PLA				; pull BASIC execute pointer high byte
  4343  a124 85c4               	STA	Bpntrh		; restore BASIC execute pointer high byte
  4344                          
  4345                          ; put execute pointer and variable pointer into function
  4346                          
  4347                          LAB_207A
  4348  a126 a000               	LDY	#$00			; clear index
  4349  a128 68                 	PLA				; pull BASIC execute pointer low byte
  4350  a129 919c               	STA	(func_l),Y		; save to function
  4351  a12b c8                 	INY				; increment index
  4352  a12c 68                 	PLA				; pull BASIC execute pointer high byte
  4353  a12d 919c               	STA	(func_l),Y		; save to function
  4354  a12f c8                 	INY				; increment index
  4355  a130 68                 	PLA				; pull current var address low byte
  4356  a131 919c               	STA	(func_l),Y		; save to function
  4357  a133 c8                 	INY				; increment index
  4358  a134 68                 	PLA				; pull current var address high byte
  4359  a135 919c               	STA	(func_l),Y		; save to function
  4360  a137 60                 	RTS
  4361                          
  4362                          ; perform STR$()
  4363                          
  4364                          LAB_STRS
  4365  a138 20e29a             	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4366  a13b 20a7aa             	JSR	LAB_296E		; convert FAC1 to string
  4367  a13e a9e3               	LDA	#<Decssp1		; set result string low pointer
  4368  a140 a000               	LDY	#>Decssp1		; set result string high pointer
  4369  a142 f012               	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
  4370                          
  4371                          ; Do string vector
  4372                          ; copy des_pl/h to des_2l/h and make string space A bytes long
  4373                          
  4374                          LAB_209C
  4375  a144 a6ae               	LDX	des_pl		; get descriptor pointer low byte
  4376  a146 a4af               	LDY	des_ph		; get descriptor pointer high byte
  4377  a148 869e               	STX	des_2l		; save descriptor pointer low byte
  4378  a14a 849f               	STY	des_2h		; save descriptor pointer high byte
  4379                          
  4380                          ; make string space A bytes long
  4381                          ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4382                          
  4383                          LAB_MSSP
  4384  a14c 20bfa1             	JSR	LAB_2115		; make space in string memory for string A long
  4385                          					; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4386  a14f 86ad               	STX	str_pl		; save string pointer low byte
  4387  a151 84ae               	STY	str_ph		; save string pointer high byte
  4388  a153 85ac               	STA	str_ln		; save length
  4389  a155 60                 	RTS
  4390                          
  4391                          ; Scan, set up string
  4392                          ; print " terminated string to Sutill/Sutilh
  4393                          
  4394                          LAB_20AE
  4395  a156 a222               	LDX	#$22			; set terminator to "
  4396  a158 865b               	STX	Srchc			; set search character (terminator 1)
  4397  a15a 865c               	STX	Asrch			; set terminator 2
  4398                          
  4399                          ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4400                          ; source is AY
  4401                          
  4402                          LAB_20B4
  4403  a15c 85b8               	STA	ssptr_l		; store string start low byte
  4404  a15e 84b9               	STY	ssptr_h		; store string start high byte
  4405  a160 85ad               	STA	str_pl		; save string pointer low byte
  4406  a162 84ae               	STY	str_ph		; save string pointer high byte
  4407  a164 a0ff               	LDY	#$FF			; set length to -1
  4408                          LAB_20BE
  4409  a166 c8                 	INY				; increment length
  4410  a167 b1b8               	LDA	(ssptr_l),Y		; get byte from string
  4411  a169 f00c               	BEQ	LAB_20CF		; exit loop if null byte [EOS]
  4412                          
  4413  a16b c55b               	CMP	Srchc			; compare with search character (terminator 1)
  4414  a16d f004               	BEQ	LAB_20CB		; branch if terminator
  4415                          
  4416  a16f c55c               	CMP	Asrch			; compare with terminator 2
  4417  a171 d0f3               	BNE	LAB_20BE		; loop if not terminator 2
  4418                          
  4419                          LAB_20CB
  4420  a173 c922               	CMP	#$22			; compare with "
  4421  a175 f001               	BEQ	LAB_20D0		; branch if " (carry set if = !)
  4422                          
  4423                          LAB_20CF
  4424  a177 18                 	CLC				; clear carry for add (only if [EOL] terminated string)
  4425                          LAB_20D0
  4426  a178 84ac               	STY	str_ln		; save length in FAC1 exponent
  4427  a17a 98                 	TYA				; copy length to A
  4428  a17b 65b8               	ADC	ssptr_l		; add string start low byte
  4429  a17d 85ba               	STA	Sendl			; save string end low byte
  4430  a17f a6b9               	LDX	ssptr_h		; get string start high byte
  4431  a181 9001               	BCC	LAB_20DC		; branch if no low byte overflow
  4432                          
  4433  a183 e8                 	INX				; else increment high byte
  4434                          LAB_20DC
  4435  a184 86bb               	STX	Sendh			; save string end high byte
  4436  a186 a5b9               	LDA	ssptr_h		; get string start high byte
  4437  a188 c904               	CMP	#>Ram_base		; compare with start of program memory
  4438  a18a b00b               	BCS	LAB_RTST		; branch if not in utility area
  4439                          
  4440                          					; string in utility area, move to string memory
  4441  a18c 98                 	TYA				; copy length to A
  4442  a18d 2044a1             	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4443                          					; long
  4444  a190 a6b8               	LDX	ssptr_l		; get string start low byte
  4445  a192 a4b9               	LDY	ssptr_h		; get string start high byte
  4446  a194 2031a3             	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
  4447                          
  4448                          ; check for space on descriptor stack then ..
  4449                          ; put string address and length on descriptor stack and update stack pointers
  4450                          
  4451                          LAB_RTST
  4452  a197 a665               	LDX	next_s		; get string stack pointer
  4453  a199 e071               	CPX	#des_sk+$09		; compare with max+1
  4454  a19b d005               	BNE	LAB_20F8		; branch if space on string stack
  4455                          
  4456                          					; else do string too complex error
  4457  a19d a21c               	LDX	#$1C			; error code $1C ("String too complex" error)
  4458                          LAB_20F5
  4459  a19f 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  4460                          
  4461                          ; put string address and length on descriptor stack and update stack pointers
  4462                          
  4463                          LAB_20F8
  4464  a1a2 a5ac               	LDA	str_ln		; get string length
  4465  a1a4 9500               	STA	PLUS_0,X		; put on string stack
  4466  a1a6 a5ad               	LDA	str_pl		; get string pointer low byte
  4467  a1a8 9501               	STA	PLUS_1,X		; put on string stack
  4468  a1aa a5ae               	LDA	str_ph		; get string pointer high byte
  4469  a1ac 9502               	STA	PLUS_2,X		; put on string stack
  4470  a1ae a000               	LDY	#$00			; clear Y
  4471  a1b0 86ae               	STX	des_pl		; save string descriptor pointer low byte
  4472  a1b2 84af               	STY	des_ph		; save string descriptor pointer high byte (always $00)
  4473  a1b4 88                 	DEY				; Y = $FF
  4474  a1b5 845f               	STY	Dtypef		; save data type flag, $FF=string
  4475  a1b7 8666               	STX	last_sl		; save old stack pointer (current top item)
  4476  a1b9 e8                 	INX				; update stack pointer
  4477  a1ba e8                 	INX				; update stack pointer
  4478  a1bb e8                 	INX				; update stack pointer
  4479  a1bc 8665               	STX	next_s		; save new top item value
  4480  a1be 60                 	RTS
  4481                          
  4482                          ; Build descriptor
  4483                          ; make space in string memory for string A long
  4484                          ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4485                          
  4486                          LAB_2115
  4487  a1bf 4660               	LSR	Gclctd		; clear garbage collected flag (b7)
  4488                          
  4489                          					; make space for string A long
  4490                          LAB_2117
  4491  a1c1 48                 	PHA				; save string length
  4492  a1c2 49ff               	EOR	#$FF			; complement it
  4493  a1c4 38                 	SEC				; set carry for subtract (twos comp add)
  4494  a1c5 6581               	ADC	Sstorl		; add bottom of string space low byte (subtract length)
  4495  a1c7 a482               	LDY	Sstorh		; get bottom of string space high byte
  4496  a1c9 b001               	BCS	LAB_2122		; skip decrement if no underflow
  4497                          
  4498  a1cb 88                 	DEY				; decrement bottom of string space high byte
  4499                          LAB_2122
  4500  a1cc c480               	CPY	Earryh		; compare with array mem end high byte
  4501  a1ce 9011               	BCC	LAB_2137		; do out of memory error if less
  4502                          
  4503  a1d0 d004               	BNE	LAB_212C		; if not = skip next test
  4504                          
  4505  a1d2 c57f               	CMP	Earryl		; compare with array mem end low byte
  4506  a1d4 900b               	BCC	LAB_2137		; do out of memory error if less
  4507                          
  4508                          LAB_212C
  4509  a1d6 8581               	STA	Sstorl		; save bottom of string space low byte
  4510  a1d8 8482               	STY	Sstorh		; save bottom of string space high byte
  4511  a1da 8583               	STA	Sutill		; save string utility ptr low byte
  4512  a1dc 8484               	STY	Sutilh		; save string utility ptr high byte
  4513  a1de aa                 	TAX				; copy low byte to X
  4514  a1df 68                 	PLA				; get string length back
  4515  a1e0 60                 	RTS
  4516                          
  4517                          LAB_2137
  4518  a1e1 a20c               	LDX	#$0C			; error code $0C ("Out of memory" error)
  4519  a1e3 a560               	LDA	Gclctd		; get garbage collected flag
  4520  a1e5 30b8               	BMI	LAB_20F5		; if set then do error code X
  4521                          
  4522  a1e7 20f1a1             	JSR	LAB_GARB		; else go do garbage collection
  4523  a1ea a980               	LDA	#$80			; flag for garbage collected
  4524  a1ec 8560               	STA	Gclctd		; set garbage collected flag
  4525  a1ee 68                 	PLA				; pull length
  4526  a1ef d0d0               	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
  4527                          
  4528                          ; garbage collection routine
  4529                          
  4530                          LAB_GARB
  4531  a1f1 a685               	LDX	Ememl			; get end of mem low byte
  4532  a1f3 a586               	LDA	Ememh			; get end of mem high byte
  4533                          
  4534                          ; re-run routine from last ending
  4535                          
  4536                          LAB_214B
  4537  a1f5 8681               	STX	Sstorl		; set string storage low byte
  4538  a1f7 8582               	STA	Sstorh		; set string storage high byte
  4539  a1f9 a000               	LDY	#$00			; clear index
  4540  a1fb 849d               	STY	garb_h		; clear working pointer high byte (flag no strings to move)
  4541  a1fd a57f               	LDA	Earryl		; get array mem end low byte
  4542  a1ff a680               	LDX	Earryh		; get array mem end high byte
  4543  a201 85aa               	STA	Histrl		; save as highest string low byte
  4544  a203 86ab               	STX	Histrh		; save as highest string high byte
  4545  a205 a968               	LDA	#des_sk		; set descriptor stack pointer
  4546  a207 8571               	STA	ut1_pl		; save descriptor stack pointer low byte
  4547  a209 8472               	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
  4548                          LAB_2161
  4549  a20b c565               	CMP	next_s		; compare with descriptor stack pointer
  4550  a20d f005               	BEQ	LAB_216A		; branch if =
  4551                          
  4552  a20f 2075a2             	JSR	LAB_21D7		; go garbage collect descriptor stack
  4553  a212 f0f7               	BEQ	LAB_2161		; loop always
  4554                          
  4555                          					; done stacked strings, now do string vars
  4556                          LAB_216A
  4557  a214 06a0               	ASL	g_step		; set step size = $06
  4558  a216 a57b               	LDA	Svarl			; get start of vars low byte
  4559  a218 a67c               	LDX	Svarh			; get start of vars high byte
  4560  a21a 8571               	STA	ut1_pl		; save as pointer low byte
  4561  a21c 8672               	STX	ut1_ph		; save as pointer high byte
  4562                          LAB_2176
  4563  a21e e47e               	CPX	Sarryh		; compare start of arrays high byte
  4564  a220 d004               	BNE	LAB_217E		; branch if no high byte match
  4565                          
  4566  a222 c57d               	CMP	Sarryl		; else compare start of arrays low byte
  4567  a224 f005               	BEQ	LAB_2183		; branch if = var mem end
  4568                          
  4569                          LAB_217E
  4570  a226 206fa2             	JSR	LAB_21D1		; go garbage collect strings
  4571  a229 f0f3               	BEQ	LAB_2176		; loop always
  4572                          
  4573                          					; done string vars, now do string arrays
  4574                          LAB_2183
  4575  a22b 85a4               	STA	Nbendl		; save start of arrays low byte as working pointer
  4576  a22d 86a5               	STX	Nbendh		; save start of arrays high byte as working pointer
  4577  a22f a904               	LDA	#$04			; set step size
  4578  a231 85a0               	STA	g_step		; save step size
  4579                          LAB_218B
  4580  a233 a5a4               	LDA	Nbendl		; get pointer low byte
  4581  a235 a6a5               	LDX	Nbendh		; get pointer high byte
  4582                          LAB_218F
  4583  a237 e480               	CPX	Earryh		; compare with array mem end high byte
  4584  a239 d004               	BNE	LAB_219A		; branch if not at end
  4585                          
  4586  a23b c57f               	CMP	Earryl		; else compare with array mem end low byte
  4587  a23d f075               	BEQ	LAB_2216		; tidy up and exit if at end
  4588                          
  4589                          LAB_219A
  4590  a23f 8571               	STA	ut1_pl		; save pointer low byte
  4591  a241 8672               	STX	ut1_ph		; save pointer high byte
  4592  a243 a002               	LDY	#$02			; set index
  4593  a245 b171               	LDA	(ut1_pl),Y		; get array size low byte
  4594  a247 65a4               	ADC	Nbendl		; add start of this array low byte
  4595  a249 85a4               	STA	Nbendl		; save start of next array low byte
  4596  a24b c8                 	INY				; increment index
  4597  a24c b171               	LDA	(ut1_pl),Y		; get array size high byte
  4598  a24e 65a5               	ADC	Nbendh		; add start of this array high byte
  4599  a250 85a5               	STA	Nbendh		; save start of next array high byte
  4600  a252 a001               	LDY	#$01			; set index
  4601  a254 b171               	LDA	(ut1_pl),Y		; get name second byte
  4602  a256 10db               	BPL	LAB_218B		; skip if not string array
  4603                          
  4604                          ; was string array so ..
  4605                          
  4606  a258 a004               	LDY	#$04			; set index
  4607  a25a b171               	LDA	(ut1_pl),Y		; get # of dimensions
  4608  a25c 0a                 	ASL				; *2
  4609  a25d 6905               	ADC	#$05			; +5 (array header size)
  4610  a25f 20a7a2             	JSR	LAB_2208		; go set up for first element
  4611                          LAB_21C4
  4612  a262 e4a5               	CPX	Nbendh		; compare with start of next array high byte
  4613  a264 d004               	BNE	LAB_21CC		; branch if <> (go do this array)
  4614                          
  4615  a266 c5a4               	CMP	Nbendl		; else compare element pointer low byte with next array
  4616                          					; low byte
  4617  a268 f0cd               	BEQ	LAB_218F		; if equal then go do next array
  4618                          
  4619                          LAB_21CC
  4620  a26a 2075a2             	JSR	LAB_21D7		; go defrag array strings
  4621  a26d f0f3               	BEQ	LAB_21C4		; go do next array string (loop always)
  4622                          
  4623                          ; defrag string variables
  4624                          ; enter with XA = variable pointer
  4625                          ; return with XA = next variable pointer
  4626                          
  4627                          LAB_21D1
  4628  a26f c8                 	INY				; increment index (Y was $00)
  4629  a270 b171               	LDA	(ut1_pl),Y		; get var name byte 2
  4630  a272 1030               	BPL	LAB_2206		; if not string, step pointer to next var and return
  4631                          
  4632  a274 c8                 	INY				; else increment index
  4633                          LAB_21D7
  4634  a275 b171               	LDA	(ut1_pl),Y		; get string length
  4635  a277 f02b               	BEQ	LAB_2206		; if null, step pointer to next string and return
  4636                          
  4637  a279 c8                 	INY				; else increment index
  4638  a27a b171               	LDA	(ut1_pl),Y		; get string pointer low byte
  4639  a27c aa                 	TAX				; copy to X
  4640  a27d c8                 	INY				; increment index
  4641  a27e b171               	LDA	(ut1_pl),Y		; get string pointer high byte
  4642  a280 c582               	CMP	Sstorh		; compare bottom of string space high byte
  4643  a282 9006               	BCC	LAB_21EC		; branch if less
  4644                          
  4645  a284 d01e               	BNE	LAB_2206		; if greater, step pointer to next string and return
  4646                          
  4647                          					; high bytes were = so compare low bytes
  4648  a286 e481               	CPX	Sstorl		; compare bottom of string space low byte
  4649  a288 b01a               	BCS	LAB_2206		; if >=, step pointer to next string and return
  4650                          
  4651                          					; string pointer is < string storage pointer (pos in mem)
  4652                          LAB_21EC
  4653  a28a c5ab               	CMP	Histrh		; compare to highest string high byte
  4654  a28c 9017               	BCC	LAB_2207		; if <, step pointer to next string and return
  4655                          
  4656  a28e d004               	BNE	LAB_21F6		; if > update pointers, step to next and return
  4657                          
  4658                          					; high bytes were = so compare low bytes
  4659  a290 e4aa               	CPX	Histrl		; compare to highest string low byte
  4660  a292 9011               	BCC	LAB_2207		; if <, step pointer to next string and return
  4661                          
  4662                          					; string is in string memory space
  4663                          LAB_21F6
  4664  a294 86aa               	STX	Histrl		; save as new highest string low byte
  4665  a296 85ab               	STA	Histrh		; save as new highest string high byte
  4666  a298 a571               	LDA	ut1_pl		; get start of vars(descriptors) low byte
  4667  a29a a672               	LDX	ut1_ph		; get start of vars(descriptors) high byte
  4668  a29c 859c               	STA	garb_l		; save as working pointer low byte
  4669  a29e 869d               	STX	garb_h		; save as working pointer high byte
  4670  a2a0 88                 	DEY				; decrement index DIFFERS
  4671  a2a1 88                 	DEY				; decrement index (should point to descriptor start)
  4672  a2a2 84a2               	STY	g_indx		; save index pointer
  4673                          
  4674                          					; step pointer to next string
  4675                          LAB_2206
  4676  a2a4 18                 	CLC				; clear carry for add
  4677                          LAB_2207
  4678  a2a5 a5a0               	LDA	g_step		; get step size
  4679                          LAB_2208
  4680  a2a7 6571               	ADC	ut1_pl		; add pointer low byte
  4681  a2a9 8571               	STA	ut1_pl		; save pointer low byte
  4682  a2ab 9002               	BCC	LAB_2211		; branch if no overflow
  4683                          
  4684  a2ad e672               	INC	ut1_ph		; else increment high byte
  4685                          LAB_2211
  4686  a2af a672               	LDX	ut1_ph		; get pointer high byte
  4687  a2b1 a000               	LDY	#$00			; clear Y
  4688  a2b3 60                 	RTS
  4689                          
  4690                          ; search complete, now either exit or set-up and move string
  4691                          
  4692                          LAB_2216
  4693  a2b4 c6a0               	DEC	g_step		; decrement step size (now $03 for descriptor stack)
  4694  a2b6 a69d               	LDX	garb_h		; get string to move high byte
  4695  a2b8 f0f5               	BEQ	LAB_2211		; exit if nothing to move
  4696                          
  4697  a2ba a4a2               	LDY	g_indx		; get index byte back (points to descriptor)
  4698  a2bc 18                 	CLC				; clear carry for add
  4699  a2bd b19c               	LDA	(garb_l),Y		; get string length
  4700  a2bf 65aa               	ADC	Histrl		; add highest string low byte
  4701  a2c1 85a6               	STA	Obendl		; save old block end low pointer
  4702  a2c3 a5ab               	LDA	Histrh		; get highest string high byte
  4703  a2c5 6900               	ADC	#$00			; add any carry
  4704  a2c7 85a7               	STA	Obendh		; save old block end high byte
  4705  a2c9 a581               	LDA	Sstorl		; get bottom of string space low byte
  4706  a2cb a682               	LDX	Sstorh		; get bottom of string space high byte
  4707  a2cd 85a4               	STA	Nbendl		; save new block end low byte
  4708  a2cf 86a5               	STX	Nbendh		; save new block end high byte
  4709  a2d1 20d390             	JSR	LAB_11D6		; open up space in memory, don't set array end
  4710  a2d4 a4a2               	LDY	g_indx		; get index byte
  4711  a2d6 c8                 	INY				; point to descriptor low byte
  4712  a2d7 a5a4               	LDA	Nbendl		; get string pointer low byte
  4713  a2d9 919c               	STA	(garb_l),Y		; save new string pointer low byte
  4714  a2db aa                 	TAX				; copy string pointer low byte
  4715  a2dc e6a5               	INC	Nbendh		; correct high byte (move sets high byte -1)
  4716  a2de a5a5               	LDA	Nbendh		; get new string pointer high byte
  4717  a2e0 c8                 	INY				; point to descriptor high byte
  4718  a2e1 919c               	STA	(garb_l),Y		; save new string pointer high byte
  4719  a2e3 4cf5a1             	JMP	LAB_214B		; re-run routine from last ending
  4720                          					; (but don't collect this string)
  4721                          
  4722                          ; concatenate
  4723                          ; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4724                          
  4725                          LAB_224D
  4726  a2e6 a5af               	LDA	des_ph		; get descriptor pointer high byte
  4727  a2e8 48                 	PHA				; put on stack
  4728  a2e9 a5ae               	LDA	des_pl		; get descriptor pointer low byte
  4729  a2eb 48                 	PHA				; put on stack
  4730  a2ec 20df9b             	JSR	LAB_GVAL		; get value from line
  4731  a2ef 20e49a             	JSR	LAB_CTST		; check if source is string, else do type mismatch
  4732  a2f2 68                 	PLA				; get descriptor pointer low byte back
  4733  a2f3 85b8               	STA	ssptr_l		; set pointer low byte
  4734  a2f5 68                 	PLA				; get descriptor pointer high byte back
  4735  a2f6 85b9               	STA	ssptr_h		; set pointer high byte
  4736  a2f8 a000               	LDY	#$00			; clear index
  4737  a2fa b1b8               	LDA	(ssptr_l),Y		; get length_1 from descriptor
  4738  a2fc 18                 	CLC				; clear carry for add
  4739  a2fd 71ae               	ADC	(des_pl),Y		; add length_2
  4740  a2ff 9005               	BCC	LAB_226D		; branch if no overflow
  4741                          
  4742  a301 a21a               	LDX	#$1A			; else set error code $1A ("String too long" error)
  4743  a303 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  4744                          
  4745                          LAB_226D
  4746  a306 2044a1             	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
  4747                          					; long
  4748  a309 2023a3             	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
  4749  a30c a59e               	LDA	des_2l		; get descriptor pointer low byte
  4750  a30e a49f               	LDY	des_2h		; get descriptor pointer high byte
  4751  a310 2054a3             	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4752                          					; returns with A = length, ut1_pl = pointer low byte,
  4753                          					; ut1_ph = pointer high byte
  4754  a313 2035a3             	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4755  a316 a5b8               	LDA	ssptr_l		;.set descriptor pointer low byte
  4756  a318 a4b9               	LDY	ssptr_h		;.set descriptor pointer high byte
  4757  a31a 2054a3             	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4758                          					; returns with A = length, X=ut1_pl=pointer low byte,
  4759                          					; Y=ut1_ph=pointer high byte
  4760  a31d 2097a1             	JSR	LAB_RTST		; check for space on descriptor stack then put string
  4761                          					; address and length on descriptor stack and update stack
  4762                          					; pointers
  4763  a320 4c0a9b             	JMP	LAB_1ADB		;.continue evaluation
  4764                          
  4765                          ; copy string from descriptor (sdescr) to (Sutill)
  4766                          
  4767                          LAB_228A
  4768  a323 a000               	LDY	#$00			; clear index
  4769  a325 b1b8               	LDA	(sdescr),Y		; get string length
  4770  a327 48                 	PHA				; save on stack
  4771  a328 c8                 	INY				; increment index
  4772  a329 b1b8               	LDA	(sdescr),Y		; get source string pointer low byte
  4773  a32b aa                 	TAX				; copy to X
  4774  a32c c8                 	INY				; increment index
  4775  a32d b1b8               	LDA	(sdescr),Y		; get source string pointer high byte
  4776  a32f a8                 	TAY				; copy to Y
  4777  a330 68                 	PLA				; get length back
  4778                          
  4779                          ; store string A bytes long from YX to (Sutill)
  4780                          
  4781                          LAB_2298
  4782  a331 8671               	STX	ut1_pl		; save source string pointer low byte
  4783  a333 8472               	STY	ut1_ph		; save source string pointer high byte
  4784                          
  4785                          ; store string A bytes long from (ut1_pl) to (Sutill)
  4786                          
  4787                          LAB_229C
  4788  a335 aa                 	TAX				; copy length to index (don't count with Y)
  4789  a336 f014               	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
  4790                          
  4791  a338 a000               	LDY	#$00			; zero pointer (copy forward)
  4792                          LAB_22A0
  4793  a33a b171               	LDA	(ut1_pl),Y		; get source byte
  4794  a33c 9183               	STA	(Sutill),Y		; save destination byte
  4795                          
  4796  a33e c8                 	INY				; increment index
  4797  a33f ca                 	DEX				; decrement counter
  4798  a340 d0f8               	BNE	LAB_22A0		; loop while <> 0
  4799                          
  4800  a342 98                 	TYA				; restore length from Y
  4801                          LAB_22A9
  4802  a343 18                 	CLC				; clear carry for add
  4803  a344 6583               	ADC	Sutill		; add string utility ptr low byte
  4804  a346 8583               	STA	Sutill		; save string utility ptr low byte
  4805  a348 9002               	BCC	LAB_22B2		; branch if no carry
  4806                          
  4807  a34a e684               	INC	Sutilh		; else increment string utility ptr high byte
  4808                          LAB_22B2
  4809  a34c 60                 	RTS
  4810                          
  4811                          ; evaluate string
  4812                          
  4813                          LAB_EVST
  4814  a34d 20e49a             	JSR	LAB_CTST		; check if source is string, else do type mismatch
  4815                          
  4816                          ; pop string off descriptor stack, or from top of string space
  4817                          ; returns with A = length, X=pointer low byte, Y=pointer high byte
  4818                          
  4819                          LAB_22B6
  4820  a350 a5ae               	LDA	des_pl		; get descriptor pointer low byte
  4821  a352 a4af               	LDY	des_ph		; get descriptor pointer high byte
  4822                          
  4823                          ; pop (YA) descriptor off stack or from top of string space
  4824                          ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4825                          
  4826                          LAB_22BA
  4827  a354 8571               	STA	ut1_pl		; save descriptor pointer low byte
  4828  a356 8472               	STY	ut1_ph		; save descriptor pointer high byte
  4829  a358 2085a3             	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  4830  a35b 08                 	PHP				; save status flags
  4831  a35c a000               	LDY	#$00			; clear index
  4832  a35e b171               	LDA	(ut1_pl),Y		; get length from string descriptor
  4833  a360 48                 	PHA				; put on stack
  4834  a361 c8                 	INY				; increment index
  4835  a362 b171               	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
  4836  a364 aa                 	TAX				; copy to X
  4837  a365 c8                 	INY				; increment index
  4838  a366 b171               	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
  4839  a368 a8                 	TAY				; copy to Y
  4840  a369 68                 	PLA				; get string length back
  4841  a36a 28                 	PLP				; restore status
  4842  a36b d013               	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
  4843                          
  4844  a36d c482               	CPY	Sstorh		; compare bottom of string space high byte
  4845  a36f d00f               	BNE	LAB_22E6		; branch if <>
  4846                          
  4847  a371 e481               	CPX	Sstorl		; else compare bottom of string space low byte
  4848  a373 d00b               	BNE	LAB_22E6		; branch if <>
  4849                          
  4850  a375 48                 	PHA				; save string length
  4851  a376 18                 	CLC				; clear carry for add
  4852  a377 6581               	ADC	Sstorl		; add bottom of string space low byte
  4853  a379 8581               	STA	Sstorl		; save bottom of string space low byte
  4854  a37b 9002               	BCC	LAB_22E5		; skip increment if no overflow
  4855                          
  4856  a37d e682               	INC	Sstorh		; increment bottom of string space high byte
  4857                          LAB_22E5
  4858  a37f 68                 	PLA				; restore string length
  4859                          LAB_22E6
  4860  a380 8671               	STX	ut1_pl		; save string pointer low byte
  4861  a382 8472               	STY	ut1_ph		; save string pointer high byte
  4862  a384 60                 	RTS
  4863                          
  4864                          ; clean descriptor stack, YA = pointer
  4865                          ; checks if AY is on the descriptor stack, if so does a stack discard
  4866                          
  4867                          LAB_22EB
  4868  a385 c467               	CPY	last_sh		; compare pointer high byte
  4869  a387 d00c               	BNE	LAB_22FB		; exit if <>
  4870                          
  4871  a389 c566               	CMP	last_sl		; compare pointer low byte
  4872  a38b d008               	BNE	LAB_22FB		; exit if <>
  4873                          
  4874  a38d 8565               	STA	next_s		; save descriptor stack pointer
  4875  a38f e903               	SBC	#$03			; -3
  4876  a391 8566               	STA	last_sl		; save low byte -3
  4877  a393 a000               	LDY	#$00			; clear high byte
  4878                          LAB_22FB
  4879  a395 60                 	RTS
  4880                          
  4881                          ; perform CHR$()
  4882                          
  4883                          LAB_CHRS
  4884  a396 20a1a4             	JSR	LAB_EVBY		; evaluate byte expression, result in X
  4885  a399 8a                 	TXA				; copy to A
  4886  a39a 48                 	PHA				; save character
  4887  a39b a901               	LDA	#$01			; string is single byte
  4888  a39d 204ca1             	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4889                          					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4890  a3a0 68                 	PLA				; get character back
  4891  a3a1 a000               	LDY	#$00			; clear index
  4892  a3a3 91ad               	STA	(str_pl),Y		; save byte in string (byte IS string!)
  4893  a3a5 4c97a1             	JMP	LAB_RTST		; check for space on descriptor stack then put string
  4894                          					; address and length on descriptor stack and update stack
  4895                          					; pointers
  4896                          
  4897                          ; perform LEFT$()
  4898                          
  4899                          LAB_LEFT
  4900  a3a8 48                 	PHA				; push byte parameter
  4901  a3a9 2009a4             	JSR	LAB_236F		; pull string data and byte parameter from stack
  4902                          					; return pointer in des_2l/h, byte in A (and X), Y=0
  4903  a3ac d19e               	CMP	(des_2l),Y		; compare byte parameter with string length
  4904  a3ae 98                 	TYA				; clear A
  4905  a3af f009               	BEQ	LAB_2316		; go do string copy (branch always)
  4906                          
  4907                          ; perform RIGHT$()
  4908                          
  4909                          LAB_RIGHT
  4910  a3b1 48                 	PHA				; push byte parameter
  4911  a3b2 2009a4             	JSR	LAB_236F		; pull string data and byte parameter from stack
  4912                          					; return pointer in des_2l/h, byte in A (and X), Y=0
  4913  a3b5 18                 	CLC				; clear carry for add-1
  4914  a3b6 f19e               	SBC	(des_2l),Y		; subtract string length
  4915  a3b8 49ff               	EOR	#$FF			; invert it (A=LEN(expression$)-l)
  4916                          
  4917                          LAB_2316
  4918  a3ba 9004               	BCC	LAB_231C		; branch if string length > byte parameter
  4919                          
  4920  a3bc b19e               	LDA	(des_2l),Y		; else make parameter = length
  4921  a3be aa                 	TAX				; copy to byte parameter copy
  4922  a3bf 98                 	TYA				; clear string start offset
  4923                          LAB_231C
  4924  a3c0 48                 	PHA				; save string start offset
  4925                          LAB_231D
  4926  a3c1 8a                 	TXA				; copy byte parameter (or string length if <)
  4927                          LAB_231E
  4928  a3c2 48                 	PHA				; save string length
  4929  a3c3 204ca1             	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4930                          					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  4931  a3c6 a59e               	LDA	des_2l		; get descriptor pointer low byte
  4932  a3c8 a49f               	LDY	des_2h		; get descriptor pointer high byte
  4933  a3ca 2054a3             	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4934                          					; returns with A = length, X=ut1_pl=pointer low byte,
  4935                          					; Y=ut1_ph=pointer high byte
  4936  a3cd 68                 	PLA				; get string length back
  4937  a3ce a8                 	TAY				; copy length to Y
  4938  a3cf 68                 	PLA				; get string start offset back
  4939  a3d0 18                 	CLC				; clear carry for add
  4940  a3d1 6571               	ADC	ut1_pl		; add start offset to string start pointer low byte
  4941  a3d3 8571               	STA	ut1_pl		; save string start pointer low byte
  4942  a3d5 9002               	BCC	LAB_2335		; branch if no overflow
  4943                          
  4944  a3d7 e672               	INC	ut1_ph		; else increment string start pointer high byte
  4945                          LAB_2335
  4946  a3d9 98                 	TYA				; copy length to A
  4947  a3da 2035a3             	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
  4948  a3dd 4c97a1             	JMP	LAB_RTST		; check for space on descriptor stack then put string
  4949                          					; address and length on descriptor stack and update stack
  4950                          					; pointers
  4951                          
  4952                          ; perform MID$()
  4953                          
  4954                          LAB_MIDS
  4955  a3e0 48                 	PHA				; push byte parameter
  4956  a3e1 a9ff               	LDA	#$FF			; set default length = 255
  4957  a3e3 85af               	STA	mids_l		; save default length
  4958  a3e5 20c200             	JSR	LAB_GBYT		; scan memory
  4959  a3e8 c929               	CMP	#')'			; compare with ")"
  4960  a3ea f006               	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
  4961                          
  4962  a3ec 20109c             	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
  4963  a3ef 209ea4             	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
  4964                          LAB_2358
  4965  a3f2 2009a4             	JSR	LAB_236F		; pull string data and byte parameter from stack
  4966                          					; return pointer in des_2l/h, byte in A (and X), Y=0
  4967  a3f5 ca                 	DEX				; decrement start index
  4968  a3f6 8a                 	TXA				; copy to A
  4969  a3f7 48                 	PHA				; save string start offset
  4970  a3f8 18                 	CLC				; clear carry for sub-1
  4971  a3f9 a200               	LDX	#$00			; clear output string length
  4972  a3fb f19e               	SBC	(des_2l),Y		; subtract string length
  4973  a3fd b0c2               	BCS	LAB_231D		; if start>string length go do null string
  4974                          
  4975  a3ff 49ff               	EOR	#$FF			; complement -length
  4976  a401 c5af               	CMP	mids_l		; compare byte parameter
  4977  a403 90bd               	BCC	LAB_231E		; if length>remaining string go do RIGHT$
  4978                          
  4979  a405 a5af               	LDA	mids_l		; get length byte
  4980  a407 b0b9               	BCS	LAB_231E		; go do string copy (branch always)
  4981                          
  4982                          ; pull string data and byte parameter from stack
  4983                          ; return pointer in des_2l/h, byte in A (and X), Y=0
  4984                          
  4985                          LAB_236F
  4986  a409 20019c             	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  4987  a40c 68                 	PLA				; pull return address low byte (return address)
  4988  a40d 85a2               	STA	Fnxjpl		; save functions jump vector low byte
  4989  a40f 68                 	PLA				; pull return address high byte (return address)
  4990  a410 85a3               	STA	Fnxjph		; save functions jump vector high byte
  4991  a412 68                 	PLA				; pull byte parameter
  4992  a413 aa                 	TAX				; copy byte parameter to X
  4993  a414 68                 	PLA				; pull string pointer low byte
  4994  a415 859e               	STA	des_2l		; save it
  4995  a417 68                 	PLA				; pull string pointer high byte
  4996  a418 859f               	STA	des_2h		; save it
  4997  a41a a000               	LDY	#$00			; clear index
  4998  a41c 8a                 	TXA				; copy byte parameter
  4999  a41d f079               	BEQ	LAB_23A8		; if null do function call error then warm start
  5000                          
  5001  a41f e6a2               	INC	Fnxjpl		; increment function jump vector low byte
  5002                          					; (JSR pushes return addr-1. this is all very nice
  5003                          					; but will go tits up if either call is on a page
  5004                          					; boundary!)
  5005  a421 6ca200             	JMP	(Fnxjpl)		; in effect, RTS
  5006                          
  5007                          ; perform LCASE$()
  5008                          
  5009                          LAB_LCASE
  5010  a424 204da3             	JSR	LAB_EVST		; evaluate string
  5011  a427 85ac               	STA	str_ln		; set string length
  5012  a429 a8                 	TAY				; copy length to Y
  5013  a42a f038               	BEQ	NoString		; branch if null string
  5014                          
  5015  a42c 204ca1             	JSR	LAB_MSSP		; make string space A bytes long A=length,
  5016                          					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  5017  a42f 86ad               	STX	str_pl		; save string pointer low byte
  5018  a431 84ae               	STY	str_ph		; save string pointer high byte
  5019  a433 a8                 	TAY				; get string length back
  5020                          
  5021                          LC_loop
  5022  a434 88                 	DEY				; decrement index
  5023  a435 b171               	LDA	(ut1_pl),Y		; get byte from string
  5024  a437 20349e             	JSR	LAB_1D82		; is character "A" to "Z"
  5025  a43a 9002               	BCC	NoUcase		; branch if not upper case alpha
  5026                          
  5027  a43c 0920               	ORA	#$20			; convert upper to lower case
  5028                          NoUcase
  5029  a43e 9183               	STA	(Sutill),Y		; save byte back to string
  5030  a440 98                 	TYA				; test index
  5031  a441 d0f1               	BNE	LC_loop		; loop if not all done
  5032                          
  5033  a443 f01f               	BEQ	NoString		; tidy up and exit, branch always
  5034                          
  5035                          ; perform UCASE$()
  5036                          
  5037                          LAB_UCASE
  5038  a445 204da3             	JSR	LAB_EVST		; evaluate string
  5039  a448 85ac               	STA	str_ln		; set string length
  5040  a44a a8                 	TAY				; copy length to Y
  5041  a44b f017               	BEQ	NoString		; branch if null string
  5042                          
  5043  a44d 204ca1             	JSR	LAB_MSSP		; make string space A bytes long A=length,
  5044                          					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  5045  a450 86ad               	STX	str_pl		; save string pointer low byte
  5046  a452 84ae               	STY	str_ph		; save string pointer high byte
  5047  a454 a8                 	TAY				; get string length back
  5048                          
  5049                          UC_loop
  5050  a455 88                 	DEY				; decrement index
  5051  a456 b171               	LDA	(ut1_pl),Y		; get byte from string
  5052  a458 20309e             	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
  5053  a45b 9002               	BCC	NoLcase		; branch if not alpha
  5054                          
  5055  a45d 29df               	AND	#$DF			; convert lower to upper case
  5056                          NoLcase
  5057  a45f 9183               	STA	(Sutill),Y		; save byte back to string
  5058  a461 98                 	TYA				; test index
  5059  a462 d0f1               	BNE	UC_loop		; loop if not all done
  5060                          
  5061                          NoString
  5062  a464 4c97a1             	JMP	LAB_RTST		; check for space on descriptor stack then put string
  5063                          					; address and length on descriptor stack and update stack
  5064                          					; pointers
  5065                          
  5066                          ; perform SADD()
  5067                          
  5068                          LAB_SADD
  5069  a467 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  5070  a46a 20bc9d             	JSR	LAB_GVAR		; get var address
  5071                          
  5072  a46d 20019c             	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
  5073  a470 20e49a             	JSR	LAB_CTST		; check if source is string, else do type mismatch
  5074                          
  5075  a473 a002               	LDY	#$02			; index to string pointer high byte
  5076  a475 b195               	LDA	(Cvaral),Y		; get string pointer high byte
  5077  a477 aa                 	TAX				; copy string pointer high byte to X
  5078  a478 88                 	DEY				; index to string pointer low byte
  5079  a479 b195               	LDA	(Cvaral),Y		; get string pointer low byte
  5080  a47b a8                 	TAY				; copy string pointer low byte to Y
  5081  a47c 8a                 	TXA				; copy string pointer high byte to A
  5082  a47d 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  5083                          
  5084                          ; perform LEN()
  5085                          
  5086                          LAB_LENS
  5087  a480 2086a4             	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  5088  a483 4c78a0             	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  5089                          
  5090                          ; evaluate string, get length in Y
  5091                          
  5092                          LAB_ESGL
  5093  a486 204da3             	JSR	LAB_EVST		; evaluate string
  5094  a489 a8                 	TAY				; copy length to Y
  5095  a48a 60                 	RTS
  5096                          
  5097                          ; perform ASC()
  5098                          
  5099                          LAB_ASC
  5100  a48b 2086a4             	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  5101  a48e f008               	BEQ	LAB_23A8		; if null do function call error then warm start
  5102                          
  5103  a490 a000               	LDY	#$00			; set index to first character
  5104  a492 b171               	LDA	(ut1_pl),Y		; get byte
  5105  a494 a8                 	TAY				; copy to Y
  5106  a495 4c78a0             	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  5107                          
  5108                          ; do function call error then warm start
  5109                          
  5110                          LAB_23A8
  5111  a498 4c3b9f             	JMP	LAB_FCER		; do function call error then warm start
  5112                          
  5113                          ; scan and get byte parameter
  5114                          
  5115                          LAB_SGBY
  5116  a49b 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  5117                          
  5118                          ; get byte parameter
  5119                          
  5120                          LAB_GTBY
  5121  a49e 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5122                          					; else do type mismatch
  5123                          
  5124                          ; evaluate byte expression, result in X
  5125                          
  5126                          LAB_EVBY
  5127  a4a1 20b49e             	JSR	LAB_EVPI		; evaluate integer expression (no check)
  5128                          
  5129  a4a4 a4ae               	LDY	FAC1_2		; get FAC1 mantissa2
  5130  a4a6 d0f0               	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
  5131                          
  5132  a4a8 a6af               	LDX	FAC1_3		; get FAC1 mantissa3
  5133  a4aa 4cc200             	JMP	LAB_GBYT		; scan memory and return
  5134                          
  5135                          ; perform VAL()
  5136                          
  5137                          LAB_VAL
  5138  a4ad 2086a4             	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  5139  a4b0 d003               	BNE	LAB_23C5		; branch if not null string
  5140                          
  5141                          					; string was null so set result = $00
  5142  a4b2 4c62a6             	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  5143                          
  5144                          LAB_23C5
  5145  a4b5 a6c3               	LDX	Bpntrl		; get BASIC execute pointer low byte
  5146  a4b7 a4c4               	LDY	Bpntrh		; get BASIC execute pointer high byte
  5147  a4b9 86ba               	STX	Btmpl			; save BASIC execute pointer low byte
  5148  a4bb 84bb               	STY	Btmph			; save BASIC execute pointer high byte
  5149  a4bd a671               	LDX	ut1_pl		; get string pointer low byte
  5150  a4bf 86c3               	STX	Bpntrl		; save as BASIC execute pointer low byte
  5151  a4c1 18                 	CLC				; clear carry
  5152  a4c2 6571               	ADC	ut1_pl		; add string length
  5153  a4c4 8573               	STA	ut2_pl		; save string end low byte
  5154  a4c6 a572               	LDA	ut1_ph		; get string pointer high byte
  5155  a4c8 85c4               	STA	Bpntrh		; save as BASIC execute pointer high byte
  5156  a4ca 6900               	ADC	#$00			; add carry to high byte
  5157  a4cc 8574               	STA	ut2_ph		; save string end high byte
  5158  a4ce a000               	LDY	#$00			; set index to $00
  5159  a4d0 b173               	LDA	(ut2_pl),Y		; get string end +1 byte
  5160  a4d2 48                 	PHA				; push it
  5161  a4d3 98                 	TYA				; clear A
  5162  a4d4 9173               	STA	(ut2_pl),Y		; terminate string with $00
  5163  a4d6 20c200             	JSR	LAB_GBYT		; scan memory
  5164  a4d9 20b8a9             	JSR	LAB_2887		; get FAC1 from string
  5165  a4dc 68                 	PLA				; restore string end +1 byte
  5166  a4dd a000               	LDY	#$00			; set index to zero
  5167  a4df 9173               	STA	(ut2_pl),Y		; put string end byte back
  5168                          
  5169                          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  5170                          
  5171                          LAB_23F3
  5172  a4e1 a6ba               	LDX	Btmpl			; get BASIC execute pointer low byte back
  5173  a4e3 a4bb               	LDY	Btmph			; get BASIC execute pointer high byte back
  5174  a4e5 86c3               	STX	Bpntrl		; save BASIC execute pointer low byte
  5175  a4e7 84c4               	STY	Bpntrh		; save BASIC execute pointer high byte
  5176  a4e9 60                 	RTS
  5177                          
  5178                          ; get two parameters for POKE or WAIT
  5179                          
  5180                          LAB_GADB
  5181  a4ea 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5182                          					; else do type mismatch
  5183  a4ed 2003a5             	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5184                          
  5185                          ; scan for "," and get byte, else do Syntax error then warm start
  5186                          
  5187                          LAB_SCGB
  5188  a4f0 20109c             	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
  5189  a4f3 a512               	LDA	Itemph		; save temporary integer high byte
  5190  a4f5 48                 	PHA				; on stack
  5191  a4f6 a511               	LDA	Itempl		; save temporary integer low byte
  5192  a4f8 48                 	PHA				; on stack
  5193  a4f9 209ea4             	JSR	LAB_GTBY		; get byte parameter
  5194  a4fc 68                 	PLA				; pull low byte
  5195  a4fd 8511               	STA	Itempl		; restore temporary integer low byte
  5196  a4ff 68                 	PLA				; pull high byte
  5197  a500 8512               	STA	Itemph		; restore temporary integer high byte
  5198  a502 60                 	RTS
  5199                          
  5200                          ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  5201                          ; -ve and converts it into a right truncated integer in Itempl and Itemph
  5202                          
  5203                          ; save unsigned 16 bit integer part of FAC1 in temporary integer
  5204                          
  5205                          LAB_F2FX
  5206  a503 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  5207  a505 c998               	CMP	#$98			; compare with exponent = 2^24
  5208  a507 b08f               	BCS	LAB_23A8		; if >= do function call error then warm start
  5209                          
  5210                          LAB_F2FU
  5211  a509 2062a9             	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5212  a50c a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  5213  a50e a4af               	LDY	FAC1_3		; get FAC1 mantissa3
  5214  a510 8411               	STY	Itempl		; save temporary integer low byte
  5215  a512 8512               	STA	Itemph		; save temporary integer high byte
  5216  a514 60                 	RTS
  5217                          
  5218                          ; perform PEEK()
  5219                          
  5220                          LAB_PEEK
  5221  a515 2003a5             	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5222  a518 a200               	LDX	#$00			; clear index
  5223  a51a a111               	LDA	(Itempl,X)		; get byte via temporary integer (addr)
  5224  a51c a8                 	TAY				; copy byte to Y
  5225  a51d 4c78a0             	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  5226                          
  5227                          ; perform POKE
  5228                          
  5229                          LAB_POKE
  5230  a520 20eaa4             	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5231  a523 8a                 	TXA				; copy byte argument to A
  5232  a524 a200               	LDX	#$00			; clear index
  5233  a526 8111               	STA	(Itempl,X)		; save byte via temporary integer (addr)
  5234  a528 60                 	RTS
  5235                          
  5236                          ; perform DEEK()
  5237                          
  5238                          LAB_DEEK
  5239  a529 2003a5             	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  5240  a52c a200               	LDX	#$00			; clear index
  5241  a52e a111               	LDA	(Itempl,X)		; PEEK low byte
  5242  a530 a8                 	TAY				; copy to Y
  5243  a531 e611               	INC	Itempl		; increment pointer low byte
  5244  a533 d002               	BNE	Deekh			; skip high increment if no rollover
  5245                          
  5246  a535 e612               	INC	Itemph		; increment pointer high byte
  5247                          Deekh
  5248  a537 a111               	LDA	(Itempl,X)		; PEEK high byte
  5249  a539 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  5250                          
  5251                          ; perform DOKE
  5252                          
  5253                          LAB_DOKE
  5254  a53c 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5255                          					; else do type mismatch
  5256  a53f 2003a5             	JSR	LAB_F2FX		; convert floating-to-fixed
  5257                          
  5258  a542 8497               	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
  5259  a544 8598               	STA	Frnxth		; save pointer high byte
  5260                          
  5261  a546 20109c             	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
  5262  a549 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5263                          					; else do type mismatch
  5264  a54c 2003a5             	JSR	LAB_F2FX		; convert floating-to-fixed
  5265                          
  5266  a54f 98                 	TYA				; copy value low byte (float to fixed returns word in AY)
  5267  a550 a200               	LDX	#$00			; clear index
  5268  a552 8197               	STA	(Frnxtl,X)		; POKE low byte
  5269  a554 e697               	INC	Frnxtl		; increment pointer low byte
  5270  a556 d002               	BNE	Dokeh			; skip high increment if no rollover
  5271                          
  5272  a558 e698               	INC	Frnxth		; increment pointer high byte
  5273                          Dokeh
  5274  a55a a512               	LDA	Itemph		; get value high byte
  5275  a55c 8197               	STA	(Frnxtl,X)		; POKE high byte
  5276  a55e 4cc200             	JMP	LAB_GBYT		; scan memory and return
  5277                          
  5278                          ; perform SWAP
  5279                          
  5280                          LAB_SWAP
  5281  a561 20bc9d             	JSR	LAB_GVAR		; get var1 address
  5282  a564 8597               	STA	Lvarpl		; save var1 address low byte
  5283  a566 8498               	STY	Lvarph		; save var1 address high byte
  5284  a568 a55f               	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
  5285  a56a 48                 	PHA				; save data type flag
  5286                          
  5287  a56b 20109c             	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
  5288  a56e 20bc9d             	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
  5289  a571 68                 	PLA				; pull var1 data type flag
  5290  a572 455f               	EOR	Dtypef		; compare with var2 data type
  5291  a574 1010               	BPL	SwapErr		; exit if not both the same type
  5292                          
  5293  a576 a003               	LDY	#$03			; four bytes to swap (either value or descriptor+1)
  5294                          SwapLp
  5295  a578 b197               	LDA	(Lvarpl),Y		; get byte from var1
  5296  a57a aa                 	TAX				; save var1 byte
  5297  a57b b195               	LDA	(Cvaral),Y		; get byte from var2
  5298  a57d 9197               	STA	(Lvarpl),Y		; save byte to var1
  5299  a57f 8a                 	TXA				; restore var1 byte
  5300  a580 9195               	STA	(Cvaral),Y		; save byte to var2
  5301  a582 88                 	DEY				; decrement index
  5302  a583 10f3               	BPL	SwapLp		; loop until done
  5303                          
  5304  a585 60                 	RTS
  5305                          
  5306                          SwapErr
  5307  a586 4cee9a             	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
  5308                          
  5309                          ; perform CALL
  5310                          
  5311                          LAB_CALL
  5312  a589 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  5313                          					; else do type mismatch
  5314  a58c 2003a5             	JSR	LAB_F2FX		; convert floating-to-fixed
  5315  a58f a9a5               	LDA	#>CallExit		; set return address high byte
  5316  a591 48                 	PHA				; put on stack
  5317  a592 a997               	LDA	#<CallExit-1	; set return address low byte
  5318  a594 48                 	PHA				; put on stack
  5319  a595 6c1100             	JMP	(Itempl)		; do indirect jump to user routine
  5320                          
  5321                          ; if the called routine exits correctly then it will return to here. this will then get
  5322                          ; the next byte for the interpreter and return
  5323                          
  5324                          CallExit
  5325  a598 4cc200             	JMP	LAB_GBYT		; scan memory and return
  5326                          
  5327                          ; perform WAIT
  5328                          
  5329                          LAB_WAIT
  5330  a59b 20eaa4             	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  5331  a59e 8697               	STX	Frnxtl		; save byte
  5332  a5a0 a200               	LDX	#$00			; clear mask
  5333  a5a2 20c200             	JSR	LAB_GBYT		; scan memory
  5334  a5a5 f003               	BEQ	LAB_2441		; skip if no third argument
  5335                          
  5336  a5a7 20f0a4             	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
  5337                          LAB_2441
  5338  a5aa 8698               	STX	Frnxth		; save EOR argument
  5339                          LAB_2445
  5340  a5ac b111               	LDA	(Itempl),Y		; get byte via temporary integer (addr)
  5341  a5ae 4598               	EOR	Frnxth		; EOR with second argument (mask)
  5342  a5b0 2597               	AND	Frnxtl		; AND with first argument (byte)
  5343  a5b2 f0f8               	BEQ	LAB_2445		; loop if result is zero
  5344                          
  5345                          LAB_244D
  5346  a5b4 60                 	RTS
  5347                          
  5348                          ; perform subtraction, FAC1 from (AY)
  5349                          
  5350                          LAB_2455
  5351  a5b5 209da7             	JSR	LAB_264D		; unpack memory (AY) into FAC2
  5352                          
  5353                          ; perform subtraction, FAC1 from FAC2
  5354                          
  5355                          LAB_SUBTRACT
  5356  a5b8 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  5357  a5ba 49ff               	EOR	#$FF			; complement it
  5358  a5bc 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  5359  a5be 45b7               	EOR	FAC2_s		; EOR with FAC2 sign (b7)
  5360  a5c0 85b8               	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
  5361  a5c2 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  5362  a5c4 4cd3a5             	JMP	LAB_ADD		; go add FAC2 to FAC1
  5363                          
  5364                          ; perform addition
  5365                          
  5366                          LAB_2467
  5367  a5c7 20eca6             	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
  5368  a5ca 904d               	BCC	LAB_24A8		;.go subtract mantissas
  5369                          
  5370                          ; add 0.5 to FAC1
  5371                          
  5372                          LAB_244E
  5373  a5cc a9ec               	LDA	#<LAB_2A96		; set 0.5 pointer low byte
  5374  a5ce a0b1               	LDY	#>LAB_2A96		; set 0.5 pointer high byte
  5375                          
  5376                          ; add (AY) to FAC1
  5377                          
  5378                          LAB_246C
  5379  a5d0 209da7             	JSR	LAB_264D		; unpack memory (AY) into FAC2
  5380                          
  5381                          ; add FAC2 to FAC1
  5382                          
  5383                          LAB_ADD
  5384  a5d3 d010               	BNE	LAB_2474		; branch if FAC1 was not zero
  5385                          
  5386                          ; copy FAC2 to FAC1
  5387                          
  5388                          LAB_279B
  5389  a5d5 a5b7               	LDA	FAC2_s		; get FAC2 sign (b7)
  5390                          
  5391                          ; save FAC1 sign and copy ABS(FAC2) to FAC1
  5392                          
  5393                          LAB_279D
  5394  a5d7 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  5395  a5d9 a204               	LDX	#$04			; 4 bytes to copy
  5396                          LAB_27A1
  5397  a5db b5b2               	LDA	FAC1_o,X		; get byte from FAC2,X
  5398  a5dd 95ab               	STA	FAC1_e-1,X		; save byte at FAC1,X
  5399  a5df ca                 	DEX				; decrement count
  5400  a5e0 d0f9               	BNE	LAB_27A1		; loop if not all done
  5401                          
  5402  a5e2 86b9               	STX	FAC1_r		; clear FAC1 rounding byte
  5403  a5e4 60                 	RTS
  5404                          
  5405                          					; FAC1 is non zero
  5406                          LAB_2474
  5407  a5e5 a6b9               	LDX	FAC1_r		; get FAC1 rounding byte
  5408  a5e7 86a3               	STX	FAC2_r		; save as FAC2 rounding byte
  5409  a5e9 a2b3               	LDX	#FAC2_e		; set index to FAC2 exponent addr
  5410  a5eb a5b3               	LDA	FAC2_e		; get FAC2 exponent
  5411                          LAB_247C
  5412  a5ed a8                 	TAY				; copy exponent
  5413  a5ee f0c4               	BEQ	LAB_244D		; exit if zero
  5414                          
  5415  a5f0 38                 	SEC				; set carry for subtract
  5416  a5f1 e5ac               	SBC	FAC1_e		; subtract FAC1 exponent
  5417  a5f3 f024               	BEQ	LAB_24A8		; branch if = (go add mantissa)
  5418                          
  5419  a5f5 9012               	BCC	LAB_2498		; branch if <
  5420                          
  5421                          					; FAC2>FAC1
  5422  a5f7 84ac               	STY	FAC1_e		; save FAC1 exponent
  5423  a5f9 a4b7               	LDY	FAC2_s		; get FAC2 sign (b7)
  5424  a5fb 84b0               	STY	FAC1_s		; save FAC1 sign (b7)
  5425  a5fd 49ff               	EOR	#$FF			; complement A
  5426  a5ff 6900               	ADC	#$00			; +1 (twos complement, carry is set)
  5427  a601 a000               	LDY	#$00			; clear Y
  5428  a603 84a3               	STY	FAC2_r		; clear FAC2 rounding byte
  5429  a605 a2ac               	LDX	#FAC1_e		; set index to FAC1 exponent addr
  5430  a607 d004               	BNE	LAB_249C		; branch always
  5431                          
  5432                          LAB_2498
  5433  a609 a000               	LDY	#$00			; clear Y
  5434  a60b 84b9               	STY	FAC1_r		; clear FAC1 rounding byte
  5435                          LAB_249C
  5436  a60d c9f9               	CMP	#$F9			; compare exponent diff with $F9
  5437  a60f 30b6               	BMI	LAB_2467		; branch if range $79-$F8
  5438                          
  5439  a611 a8                 	TAY				; copy exponent difference to Y
  5440  a612 a5b9               	LDA	FAC1_r		; get FAC1 rounding byte
  5441  a614 5601               	LSR	PLUS_1,X		; shift FAC? mantissa1
  5442  a616 2003a7             	JSR	LAB_2592		; shift FACX Y times right
  5443                          
  5444                          					; exponents are equal now do mantissa subtract
  5445                          LAB_24A8
  5446  a619 24b8               	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
  5447  a61b 104c               	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
  5448                          
  5449  a61d a0ac               	LDY	#FAC1_e		; set index to FAC1 exponent addr
  5450  a61f e0b3               	CPX	#FAC2_e		; compare X to FAC2 exponent addr
  5451  a621 f002               	BEQ	LAB_24B4		; branch if =
  5452                          
  5453  a623 a0b3               	LDY	#FAC2_e		; else set index to FAC2 exponent addr
  5454                          
  5455                          					; subtract smaller from bigger (take sign of bigger)
  5456                          LAB_24B4
  5457  a625 38                 	SEC				; set carry for subtract
  5458  a626 49ff               	EOR	#$FF			; ones complement A
  5459  a628 65a3               	ADC	FAC2_r		; add FAC2 rounding byte
  5460  a62a 85b9               	STA	FAC1_r		; save FAC1 rounding byte
  5461  a62c b90300             	LDA	PLUS_3,Y		; get FACY mantissa3
  5462  a62f f503               	SBC	PLUS_3,X		; subtract FACX mantissa3
  5463  a631 85af               	STA	FAC1_3		; save FAC1 mantissa3
  5464  a633 b90200             	LDA	PLUS_2,Y		; get FACY mantissa2
  5465  a636 f502               	SBC	PLUS_2,X		; subtract FACX mantissa2
  5466  a638 85ae               	STA	FAC1_2		; save FAC1 mantissa2
  5467  a63a b90100             	LDA	PLUS_1,Y		; get FACY mantissa1
  5468  a63d f501               	SBC	PLUS_1,X		; subtract FACX mantissa1
  5469  a63f 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  5470                          
  5471                          ; do ABS and normalise FAC1
  5472                          
  5473                          LAB_24D0
  5474  a641 b003               	BCS	LAB_24D5		; branch if number is +ve
  5475                          
  5476  a643 20a8a6             	JSR	LAB_2537		; negate FAC1
  5477                          
  5478                          ; normalise FAC1
  5479                          
  5480                          LAB_24D5
  5481  a646 a000               	LDY	#$00			; clear Y
  5482  a648 98                 	TYA				; clear A
  5483  a649 18                 	CLC				; clear carry for add
  5484                          LAB_24D9
  5485  a64a a6ad               	LDX	FAC1_1		; get FAC1 mantissa1
  5486  a64c d03e               	BNE	LAB_251B		; if not zero normalise FAC1
  5487                          
  5488  a64e a6ae               	LDX	FAC1_2		; get FAC1 mantissa2
  5489  a650 86ad               	STX	FAC1_1		; save FAC1 mantissa1
  5490  a652 a6af               	LDX	FAC1_3		; get FAC1 mantissa3
  5491  a654 86ae               	STX	FAC1_2		; save FAC1 mantissa2
  5492  a656 a6b9               	LDX	FAC1_r		; get FAC1 rounding byte
  5493  a658 86af               	STX	FAC1_3		; save FAC1 mantissa3
  5494  a65a 84b9               	STY	FAC1_r		; clear FAC1 rounding byte
  5495  a65c 6908               	ADC	#$08			; add x to exponent offset
  5496  a65e c918               	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
  5497  a660 d0e8               	BNE	LAB_24D9		; loop if not max
  5498                          
  5499                          ; clear FAC1 exponent and sign
  5500                          
  5501                          LAB_24F1
  5502  a662 a900               	LDA	#$00			; clear A
  5503                          LAB_24F3
  5504  a664 85ac               	STA	FAC1_e		; set FAC1 exponent
  5505                          
  5506                          ; save FAC1 sign
  5507                          
  5508                          LAB_24F5
  5509  a666 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  5510  a668 60                 	RTS
  5511                          
  5512                          ; add FAC2 mantissa to FAC1 mantissa
  5513                          
  5514                          LAB_24F8
  5515  a669 65a3               	ADC	FAC2_r		; add FAC2 rounding byte
  5516  a66b 85b9               	STA	FAC1_r		; save FAC1 rounding byte
  5517  a66d a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  5518  a66f 65b6               	ADC	FAC2_3		; add FAC2 mantissa3
  5519  a671 85af               	STA	FAC1_3		; save FAC1 mantissa3
  5520  a673 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  5521  a675 65b5               	ADC	FAC2_2		; add FAC2 mantissa2
  5522  a677 85ae               	STA	FAC1_2		; save FAC1 mantissa2
  5523  a679 a5ad               	LDA	FAC1_1		; get FAC1 mantissa1
  5524  a67b 65b4               	ADC	FAC2_1		; add FAC2 mantissa1
  5525  a67d 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  5526  a67f b01a               	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
  5527                          
  5528  a681 60                 	RTS				; else just exit
  5529                          
  5530                          LAB_2511
  5531  a682 6901               	ADC	#$01			; add 1 to exponent offset
  5532  a684 06b9               	ASL	FAC1_r		; shift FAC1 rounding byte
  5533  a686 26af               	ROL	FAC1_3		; shift FAC1 mantissa3
  5534  a688 26ae               	ROL	FAC1_2		; shift FAC1 mantissa2
  5535  a68a 26ad               	ROL	FAC1_1		; shift FAC1 mantissa1
  5536                          
  5537                          ; normalise FAC1
  5538                          
  5539                          LAB_251B
  5540  a68c 10f4               	BPL	LAB_2511		; loop if not normalised
  5541                          
  5542  a68e 38                 	SEC				; set carry for subtract
  5543  a68f e5ac               	SBC	FAC1_e		; subtract FAC1 exponent
  5544  a691 b0cf               	BCS	LAB_24F1		; branch if underflow (set result = $0)
  5545                          
  5546  a693 49ff               	EOR	#$FF			; complement exponent
  5547  a695 6901               	ADC	#$01			; +1 (twos complement)
  5548  a697 85ac               	STA	FAC1_e		; save FAC1 exponent
  5549                          
  5550                          ; test and normalise FAC1 for C=0/1
  5551                          
  5552                          LAB_2528
  5553  a699 900c               	BCC	LAB_2536		; exit if no overflow
  5554                          
  5555                          ; normalise FAC1 for C=1
  5556                          
  5557                          LAB_252A
  5558  a69b e6ac               	INC	FAC1_e		; increment FAC1 exponent
  5559  a69d f036               	BEQ	LAB_2564		; if zero do overflow error and warm start
  5560                          
  5561  a69f 66ad               	ROR	FAC1_1		; shift FAC1 mantissa1
  5562  a6a1 66ae               	ROR	FAC1_2		; shift FAC1 mantissa2
  5563  a6a3 66af               	ROR	FAC1_3		; shift FAC1 mantissa3
  5564  a6a5 66b9               	ROR	FAC1_r		; shift FAC1 rounding byte
  5565                          LAB_2536
  5566  a6a7 60                 	RTS
  5567                          
  5568                          ; negate FAC1
  5569                          
  5570                          LAB_2537
  5571  a6a8 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  5572  a6aa 49ff               	EOR	#$FF			; complement it
  5573  a6ac 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  5574                          
  5575                          ; twos complement FAC1 mantissa
  5576                          
  5577                          LAB_253D
  5578  a6ae a5ad               	LDA	FAC1_1		; get FAC1 mantissa1
  5579  a6b0 49ff               	EOR	#$FF			; complement it
  5580  a6b2 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  5581  a6b4 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  5582  a6b6 49ff               	EOR	#$FF			; complement it
  5583  a6b8 85ae               	STA	FAC1_2		; save FAC1 mantissa2
  5584  a6ba a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  5585  a6bc 49ff               	EOR	#$FF			; complement it
  5586  a6be 85af               	STA	FAC1_3		; save FAC1 mantissa3
  5587  a6c0 a5b9               	LDA	FAC1_r		; get FAC1 rounding byte
  5588  a6c2 49ff               	EOR	#$FF			; complement it
  5589  a6c4 85b9               	STA	FAC1_r		; save FAC1 rounding byte
  5590  a6c6 e6b9               	INC	FAC1_r		; increment FAC1 rounding byte
  5591  a6c8 d00a               	BNE	LAB_2563		; exit if no overflow
  5592                          
  5593                          ; increment FAC1 mantissa
  5594                          
  5595                          LAB_2559
  5596  a6ca e6af               	INC	FAC1_3		; increment FAC1 mantissa3
  5597  a6cc d006               	BNE	LAB_2563		; finished if no rollover
  5598                          
  5599  a6ce e6ae               	INC	FAC1_2		; increment FAC1 mantissa2
  5600  a6d0 d002               	BNE	LAB_2563		; finished if no rollover
  5601                          
  5602  a6d2 e6ad               	INC	FAC1_1		; increment FAC1 mantissa1
  5603                          LAB_2563
  5604  a6d4 60                 	RTS
  5605                          
  5606                          ; do overflow error (overflow exit)
  5607                          
  5608                          LAB_2564
  5609  a6d5 a20a               	LDX	#$0A			; error code $0A ("Overflow" error)
  5610  a6d7 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  5611                          
  5612                          ; shift FCAtemp << A+8 times
  5613                          
  5614                          LAB_2569
  5615  a6da a274               	LDX	#FACt_1-1		; set offset to FACtemp
  5616                          LAB_256B
  5617  a6dc b403               	LDY	PLUS_3,X		; get FACX mantissa3
  5618  a6de 84b9               	STY	FAC1_r		; save as FAC1 rounding byte
  5619  a6e0 b402               	LDY	PLUS_2,X		; get FACX mantissa2
  5620  a6e2 9403               	STY	PLUS_3,X		; save FACX mantissa3
  5621  a6e4 b401               	LDY	PLUS_1,X		; get FACX mantissa1
  5622  a6e6 9402               	STY	PLUS_2,X		; save FACX mantissa2
  5623  a6e8 a4b2               	LDY	FAC1_o		; get FAC1 overflow byte
  5624  a6ea 9401               	STY	PLUS_1,X		; save FACX mantissa1
  5625                          
  5626                          ; shift FACX -A times right (> 8 shifts)
  5627                          
  5628                          LAB_257B
  5629  a6ec 6908               	ADC	#$08			; add 8 to shift count
  5630  a6ee 30ec               	BMI	LAB_256B		; go do 8 shift if still -ve
  5631                          
  5632  a6f0 f0ea               	BEQ	LAB_256B		; go do 8 shift if zero
  5633                          
  5634  a6f2 e908               	SBC	#$08			; else subtract 8 again
  5635  a6f4 a8                 	TAY				; save count to Y
  5636  a6f5 a5b9               	LDA	FAC1_r		; get FAC1 rounding byte
  5637  a6f7 b012               	BCS	LAB_259A		;.
  5638                          
  5639                          LAB_2588
  5640  a6f9 1601               	ASL	PLUS_1,X		; shift FACX mantissa1
  5641  a6fb 9002               	BCC	LAB_258E		; branch if +ve
  5642                          
  5643  a6fd f601               	INC	PLUS_1,X		; this sets b7 eventually
  5644                          LAB_258E
  5645  a6ff 7601               	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
  5646  a701 7601               	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
  5647                          
  5648                          ; shift FACX Y times right
  5649                          
  5650                          LAB_2592
  5651  a703 7602               	ROR	PLUS_2,X		; shift FACX mantissa2
  5652  a705 7603               	ROR	PLUS_3,X		; shift FACX mantissa3
  5653  a707 6a                 	ROR				; shift FACX rounding byte
  5654  a708 c8                 	INY				; increment exponent diff
  5655  a709 d0ee               	BNE	LAB_2588		; branch if range adjust not complete
  5656                          
  5657                          LAB_259A
  5658  a70b 18                 	CLC				; just clear it
  5659  a70c 60                 	RTS
  5660                          
  5661                          ; perform LOG()
  5662                          
  5663                          LAB_LOG
  5664  a70d 20fba8             	JSR	LAB_27CA		; test sign and zero
  5665  a710 f002               	BEQ	LAB_25C4		; if zero do function call error then warm start
  5666                          
  5667  a712 1003               	BPL	LAB_25C7		; skip error if +ve
  5668                          
  5669                          LAB_25C4
  5670  a714 4c3b9f             	JMP	LAB_FCER		; do function call error then warm start (-ve)
  5671                          
  5672                          LAB_25C7
  5673  a717 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  5674  a719 e97f               	SBC	#$7F			; normalise it
  5675  a71b 48                 	PHA				; save it
  5676  a71c a980               	LDA	#$80			; set exponent to zero
  5677  a71e 85ac               	STA	FAC1_e		; save FAC1 exponent
  5678  a720 a96c               	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
  5679  a722 a0b1               	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
  5680  a724 20d0a5             	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
  5681  a727 a970               	LDA	#<LAB_25B1		; set root2 pointer low byte
  5682  a729 a0b1               	LDY	#>LAB_25B1		; set root2 pointer high byte
  5683  a72b 2013a8             	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5684  a72e a9e3               	LDA	#<LAB_259C		; set 1 pointer low byte
  5685  a730 a0b1               	LDY	#>LAB_259C		; set 1 pointer high byte
  5686  a732 20b5a5             	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5687  a735 a95f               	LDA	#<LAB_25A0		; set pointer low byte to counter
  5688  a737 a0b1               	LDY	#>LAB_25A0		; set pointer high byte to counter
  5689  a739 2063ac             	JSR	LAB_2B6E		; ^2 then series evaluation
  5690  a73c a974               	LDA	#<LAB_25B5		; set -0.5 pointer low byte
  5691  a73e a0b1               	LDY	#>LAB_25B5		; set -0.5 pointer high byte
  5692  a740 20d0a5             	JSR	LAB_246C		; add (AY) to FAC1
  5693  a743 68                 	PLA				; restore FAC1 exponent
  5694  a744 2057aa             	JSR	LAB_2912		; evaluate new ASCII digit
  5695  a747 a978               	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
  5696  a749 a0b1               	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
  5697                          
  5698                          ; do convert AY, FCA1*(AY)
  5699                          
  5700                          LAB_25FB
  5701  a74b 209da7             	JSR	LAB_264D		; unpack memory (AY) into FAC2
  5702                          LAB_MULTIPLY
  5703  a74e f04c               	BEQ	LAB_264C		; exit if zero
  5704                          
  5705  a750 20c3a7             	JSR	LAB_2673		; test and adjust accumulators
  5706  a753 a900               	LDA	#$00			; clear A
  5707  a755 8575               	STA	FACt_1		; clear temp mantissa1
  5708  a757 8576               	STA	FACt_2		; clear temp mantissa2
  5709  a759 8577               	STA	FACt_3		; clear temp mantissa3
  5710  a75b a5b9               	LDA	FAC1_r		; get FAC1 rounding byte
  5711  a75d 2072a7             	JSR	LAB_2622		; go do shift/add FAC2
  5712  a760 a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  5713  a762 2072a7             	JSR	LAB_2622		; go do shift/add FAC2
  5714  a765 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  5715  a767 2072a7             	JSR	LAB_2622		; go do shift/add FAC2
  5716  a76a a5ad               	LDA	FAC1_1		; get FAC1 mantissa1
  5717  a76c 2077a7             	JSR	LAB_2627		; go do shift/add FAC2
  5718  a76f 4c80a8             	JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5719                          
  5720                          LAB_2622
  5721  a772 d003               	BNE	LAB_2627		; branch if byte <> zero
  5722                          
  5723  a774 4cdaa6             	JMP	LAB_2569		; shift FCAtemp << A+8 times
  5724                          
  5725                          					; else do shift and add
  5726                          LAB_2627
  5727  a777 4a                 	LSR				; shift byte
  5728  a778 0980               	ORA	#$80			; set top bit (mark for 8 times)
  5729                          LAB_262A
  5730  a77a a8                 	TAY				; copy result
  5731  a77b 9013               	BCC	LAB_2640		; skip next if bit was zero
  5732                          
  5733  a77d 18                 	CLC				; clear carry for add
  5734  a77e a577               	LDA	FACt_3		; get temp mantissa3
  5735  a780 65b6               	ADC	FAC2_3		; add FAC2 mantissa3
  5736  a782 8577               	STA	FACt_3		; save temp mantissa3
  5737  a784 a576               	LDA	FACt_2		; get temp mantissa2
  5738  a786 65b5               	ADC	FAC2_2		; add FAC2 mantissa2
  5739  a788 8576               	STA	FACt_2		; save temp mantissa2
  5740  a78a a575               	LDA	FACt_1		; get temp mantissa1
  5741  a78c 65b4               	ADC	FAC2_1		; add FAC2 mantissa1
  5742  a78e 8575               	STA	FACt_1		; save temp mantissa1
  5743                          LAB_2640
  5744  a790 6675               	ROR	FACt_1		; shift temp mantissa1
  5745  a792 6676               	ROR	FACt_2		; shift temp mantissa2
  5746  a794 6677               	ROR	FACt_3		; shift temp mantissa3
  5747  a796 66b9               	ROR	FAC1_r		; shift temp rounding byte
  5748  a798 98                 	TYA				; get byte back
  5749  a799 4a                 	LSR				; shift byte
  5750  a79a d0de               	BNE	LAB_262A		; loop if all bits not done
  5751                          
  5752                          LAB_264C
  5753  a79c 60                 	RTS
  5754                          
  5755                          ; unpack memory (AY) into FAC2
  5756                          
  5757                          LAB_264D
  5758  a79d 8571               	STA	ut1_pl		; save pointer low byte
  5759  a79f 8472               	STY	ut1_ph		; save pointer high byte
  5760  a7a1 a003               	LDY	#$03			; 4 bytes to get (0-3)
  5761  a7a3 b171               	LDA	(ut1_pl),Y		; get mantissa3
  5762  a7a5 85b6               	STA	FAC2_3		; save FAC2 mantissa3
  5763  a7a7 88                 	DEY				; decrement index
  5764  a7a8 b171               	LDA	(ut1_pl),Y		; get mantissa2
  5765  a7aa 85b5               	STA	FAC2_2		; save FAC2 mantissa2
  5766  a7ac 88                 	DEY				; decrement index
  5767  a7ad b171               	LDA	(ut1_pl),Y		; get mantissa1+sign
  5768  a7af 85b7               	STA	FAC2_s		; save FAC2 sign (b7)
  5769  a7b1 45b0               	EOR	FAC1_s		; EOR with FAC1 sign (b7)
  5770  a7b3 85b8               	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
  5771  a7b5 a5b7               	LDA	FAC2_s		; recover FAC2 sign (b7)
  5772  a7b7 0980               	ORA	#$80			; set 1xxx xxx (set normal bit)
  5773  a7b9 85b4               	STA	FAC2_1		; save FAC2 mantissa1
  5774  a7bb 88                 	DEY				; decrement index
  5775  a7bc b171               	LDA	(ut1_pl),Y		; get exponent byte
  5776  a7be 85b3               	STA	FAC2_e		; save FAC2 exponent
  5777  a7c0 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  5778  a7c2 60                 	RTS
  5779                          
  5780                          ; test and adjust accumulators
  5781                          
  5782                          LAB_2673
  5783  a7c3 a5b3               	LDA	FAC2_e		; get FAC2 exponent
  5784                          LAB_2675
  5785  a7c5 f01d               	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
  5786                          
  5787  a7c7 18                 	CLC				; clear carry for add
  5788  a7c8 65ac               	ADC	FAC1_e		; add FAC1 exponent
  5789  a7ca 9004               	BCC	LAB_2680		; branch if sum of exponents <$0100
  5790                          
  5791  a7cc 3031               	BMI	LAB_269B		; do overflow error
  5792                          
  5793  a7ce 18                 	CLC				; clear carry for the add
  5794  a7cf 2c                 	!text	$2C			; makes next line BIT $1410
  5795                          LAB_2680
  5796  a7d0 1012               	BPL	LAB_2696		; if +ve go handle underflow
  5797                          
  5798  a7d2 6980               	ADC	#$80			; adjust exponent
  5799  a7d4 85ac               	STA	FAC1_e		; save FAC1 exponent
  5800  a7d6 d003               	BNE	LAB_268B		; branch if not zero
  5801                          
  5802  a7d8 4c66a6             	JMP	LAB_24F5		; save FAC1 sign and return
  5803                          
  5804                          LAB_268B
  5805  a7db a5b8               	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
  5806  a7dd 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  5807                          LAB_268F
  5808  a7df 60                 	RTS
  5809                          
  5810                          ; handle overflow and underflow
  5811                          
  5812                          LAB_2690
  5813  a7e0 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  5814  a7e2 101b               	BPL	LAB_269B		; do overflow error
  5815                          
  5816                          					; handle underflow
  5817                          LAB_2696
  5818  a7e4 68                 	PLA				; pop return address low byte
  5819  a7e5 68                 	PLA				; pop return address high byte
  5820  a7e6 4c62a6             	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  5821                          
  5822                          ; multiply by 10
  5823                          
  5824                          LAB_269E
  5825  a7e9 20dca8             	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5826  a7ec aa                 	TAX				; copy exponent (set the flags)
  5827  a7ed f0f0               	BEQ	LAB_268F		; exit if zero
  5828                          
  5829  a7ef 18                 	CLC				; clear carry for add
  5830  a7f0 6902               	ADC	#$02			; add two to exponent (*4)
  5831  a7f2 b00b               	BCS	LAB_269B		; do overflow error if > $FF
  5832                          
  5833  a7f4 a200               	LDX	#$00			; clear byte
  5834  a7f6 86b8               	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
  5835  a7f8 20eda5             	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
  5836  a7fb e6ac               	INC	FAC1_e		; increment FAC1 exponent (*10)
  5837  a7fd d0e0               	BNE	LAB_268F		; if non zero just do RTS
  5838                          
  5839                          LAB_269B
  5840  a7ff 4cd5a6             	JMP	LAB_2564		; do overflow error and warm start
  5841                          
  5842                          ; divide by 10
  5843                          
  5844                          LAB_26B9
  5845  a802 20dca8             	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5846  a805 a9f4               	LDA	#<LAB_26B5		; set pointer to 10d low addr
  5847  a807 a0b1               	LDY	#>LAB_26B5		; set pointer to 10d high addr
  5848  a809 a200               	LDX	#$00			; clear sign
  5849                          
  5850                          ; divide by (AY) (X=sign)
  5851                          
  5852                          LAB_26C2
  5853  a80b 86b8               	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
  5854  a80d 208fa8             	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  5855  a810 4c16a8             	JMP	LAB_DIVIDE		; do FAC2/FAC1
  5856                          
  5857                          					; Perform divide-by
  5858                          ; convert AY and do (AY)/FAC1
  5859                          
  5860                          LAB_26CA
  5861  a813 209da7             	JSR	LAB_264D		; unpack memory (AY) into FAC2
  5862                          
  5863                          					; Perform divide-into
  5864                          LAB_DIVIDE
  5865  a816 f063               	BEQ	LAB_2737		; if zero go do /0 error
  5866                          
  5867  a818 20eba8             	JSR	LAB_27BA		; round FAC1
  5868  a81b a900               	LDA	#$00			; clear A
  5869  a81d 38                 	SEC				; set carry for subtract
  5870  a81e e5ac               	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
  5871  a820 85ac               	STA	FAC1_e		; save FAC1 exponent
  5872  a822 20c3a7             	JSR	LAB_2673		; test and adjust accumulators
  5873  a825 e6ac               	INC	FAC1_e		; increment FAC1 exponent
  5874  a827 f0d6               	BEQ	LAB_269B		; if zero do overflow error
  5875                          
  5876  a829 a2ff               	LDX	#$FF			; set index for pre increment
  5877  a82b a901               	LDA	#$01			; set bit to flag byte save
  5878                          LAB_26E4
  5879  a82d a4b4               	LDY	FAC2_1		; get FAC2 mantissa1
  5880  a82f c4ad               	CPY	FAC1_1		; compare FAC1 mantissa1
  5881  a831 d00a               	BNE	LAB_26F4		; branch if <>
  5882                          
  5883  a833 a4b5               	LDY	FAC2_2		; get FAC2 mantissa2
  5884  a835 c4ae               	CPY	FAC1_2		; compare FAC1 mantissa2
  5885  a837 d004               	BNE	LAB_26F4		; branch if <>
  5886                          
  5887  a839 a4b6               	LDY	FAC2_3		; get FAC2 mantissa3
  5888  a83b c4af               	CPY	FAC1_3		; compare FAC1 mantissa3
  5889                          LAB_26F4
  5890  a83d 08                 	PHP				; save FAC2-FAC1 compare status
  5891  a83e 2a                 	ROL				; shift the result byte
  5892  a83f 900e               	BCC	LAB_2702		; if no carry skip the byte save
  5893                          
  5894  a841 a001               	LDY	#$01			; set bit to flag byte save
  5895  a843 e8                 	INX				; else increment the index to FACt
  5896  a844 e002               	CPX	#$02			; compare with the index to FACt_3
  5897  a846 3004               	BMI	LAB_2701		; if not last byte just go save it
  5898                          
  5899  a848 d028               	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
  5900                          					; return
  5901                          
  5902  a84a a040               	LDY	#$40			; set bit to flag byte save for the rounding byte
  5903                          LAB_2701
  5904  a84c 9575               	STA	FACt_1,X		; write result byte to FACt_1 + index
  5905  a84e 98                 	TYA				; copy the next save byte flag
  5906                          LAB_2702
  5907  a84f 28                 	PLP				; restore FAC2-FAC1 compare status
  5908  a850 9014               	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
  5909                          
  5910  a852 a8                 	TAY				; save FAC2-FAC1 compare status
  5911  a853 a5b6               	LDA	FAC2_3		; get FAC2 mantissa3
  5912  a855 e5af               	SBC	FAC1_3		; subtract FAC1 mantissa3
  5913  a857 85b6               	STA	FAC2_3		; save FAC2 mantissa3
  5914  a859 a5b5               	LDA	FAC2_2		; get FAC2 mantissa2
  5915  a85b e5ae               	SBC	FAC1_2		; subtract FAC1 mantissa2
  5916  a85d 85b5               	STA	FAC2_2		; save FAC2 mantissa2
  5917  a85f a5b4               	LDA	FAC2_1		; get FAC2 mantissa1
  5918  a861 e5ad               	SBC	FAC1_1		; subtract FAC1 mantissa1
  5919  a863 85b4               	STA	FAC2_1		; save FAC2 mantissa1
  5920  a865 98                 	TYA				; restore FAC2-FAC1 compare status
  5921                          
  5922                          					; FAC2 = FAC2*2
  5923                          LAB_2704
  5924  a866 06b6               	ASL	FAC2_3		; shift FAC2 mantissa3
  5925  a868 26b5               	ROL	FAC2_2		; shift FAC2 mantissa2
  5926  a86a 26b4               	ROL	FAC2_1		; shift FAC2 mantissa1
  5927  a86c b0cf               	BCS	LAB_26F4		; loop with no compare
  5928                          
  5929  a86e 30bd               	BMI	LAB_26E4		; loop with compare
  5930                          
  5931  a870 10cb               	BPL	LAB_26F4		; loop always with no compare
  5932                          
  5933                          ; do A<<6, save as FAC1 rounding byte, normalise and return
  5934                          
  5935                          LAB_272B
  5936  a872 4a                 	LSR				; shift b1 - b0 ..
  5937  a873 6a                 	ROR				; ..
  5938  a874 6a                 	ROR				; .. to b7 - b6
  5939  a875 85b9               	STA	FAC1_r		; save FAC1 rounding byte
  5940  a877 28                 	PLP				; dump FAC2-FAC1 compare status
  5941  a878 4c80a8             	JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5942                          
  5943                          ; do "Divide by zero" error
  5944                          
  5945                          LAB_2737
  5946  a87b a214               	LDX	#$14			; error code $14 ("Divide by zero" error)
  5947  a87d 4c4791             	JMP	LAB_XERR		; do error #X, then warm start
  5948                          
  5949                          ; copy temp to FAC1 and normalise
  5950                          
  5951                          LAB_273C
  5952  a880 a575               	LDA	FACt_1		; get temp mantissa1
  5953  a882 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  5954  a884 a576               	LDA	FACt_2		; get temp mantissa2
  5955  a886 85ae               	STA	FAC1_2		; save FAC1 mantissa2
  5956  a888 a577               	LDA	FACt_3		; get temp mantissa3
  5957  a88a 85af               	STA	FAC1_3		; save FAC1 mantissa3
  5958  a88c 4c46a6             	JMP	LAB_24D5		; normalise FAC1 and return
  5959                          
  5960                          ; unpack memory (AY) into FAC1
  5961                          
  5962                          LAB_UFAC
  5963  a88f 8571               	STA	ut1_pl		; save pointer low byte
  5964  a891 8472               	STY	ut1_ph		; save pointer high byte
  5965  a893 a003               	LDY	#$03			; 4 bytes to do
  5966  a895 b171               	LDA	(ut1_pl),Y		; get last byte
  5967  a897 85af               	STA	FAC1_3		; save FAC1 mantissa3
  5968  a899 88                 	DEY				; decrement index
  5969  a89a b171               	LDA	(ut1_pl),Y		; get last-1 byte
  5970  a89c 85ae               	STA	FAC1_2		; save FAC1 mantissa2
  5971  a89e 88                 	DEY				; decrement index
  5972  a89f b171               	LDA	(ut1_pl),Y		; get second byte
  5973  a8a1 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  5974  a8a3 0980               	ORA	#$80			; set 1xxx xxxx (add normal bit)
  5975  a8a5 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  5976  a8a7 88                 	DEY				; decrement index
  5977  a8a8 b171               	LDA	(ut1_pl),Y		; get first byte (exponent)
  5978  a8aa 85ac               	STA	FAC1_e		; save FAC1 exponent
  5979  a8ac 84b9               	STY	FAC1_r		; clear FAC1 rounding byte
  5980  a8ae 60                 	RTS
  5981                          
  5982                          ; pack FAC1 into Adatal
  5983                          
  5984                          LAB_276E
  5985  a8af a2a4               	LDX	#<Adatal		; set pointer low byte
  5986                          LAB_2770
  5987  a8b1 a000               	LDY	#>Adatal		; set pointer high byte
  5988  a8b3 f004               	BEQ	LAB_2778		; pack FAC1 into (XY) and return
  5989                          
  5990                          ; pack FAC1 into (Lvarpl)
  5991                          
  5992                          LAB_PFAC
  5993  a8b5 a697               	LDX	Lvarpl		; get destination pointer low byte
  5994  a8b7 a498               	LDY	Lvarph		; get destination pointer high byte
  5995                          
  5996                          ; pack FAC1 into (XY)
  5997                          
  5998                          LAB_2778
  5999  a8b9 20eba8             	JSR	LAB_27BA		; round FAC1
  6000  a8bc 8671               	STX	ut1_pl		; save pointer low byte
  6001  a8be 8472               	STY	ut1_ph		; save pointer high byte
  6002  a8c0 a003               	LDY	#$03			; set index
  6003  a8c2 a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  6004  a8c4 9171               	STA	(ut1_pl),Y		; store in destination
  6005  a8c6 88                 	DEY				; decrement index
  6006  a8c7 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  6007  a8c9 9171               	STA	(ut1_pl),Y		; store in destination
  6008  a8cb 88                 	DEY				; decrement index
  6009  a8cc a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6010  a8ce 097f               	ORA	#$7F			; set bits x111 1111
  6011  a8d0 25ad               	AND	FAC1_1		; AND in FAC1 mantissa1
  6012  a8d2 9171               	STA	(ut1_pl),Y		; store in destination
  6013  a8d4 88                 	DEY				; decrement index
  6014  a8d5 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6015  a8d7 9171               	STA	(ut1_pl),Y		; store in destination
  6016  a8d9 84b9               	STY	FAC1_r		; clear FAC1 rounding byte
  6017  a8db 60                 	RTS
  6018                          
  6019                          ; round and copy FAC1 to FAC2
  6020                          
  6021                          LAB_27AB
  6022  a8dc 20eba8             	JSR	LAB_27BA		; round FAC1
  6023                          
  6024                          ; copy FAC1 to FAC2
  6025                          
  6026                          LAB_27AE
  6027  a8df a205               	LDX	#$05			; 5 bytes to copy
  6028                          LAB_27B0
  6029  a8e1 b5ab               	LDA	FAC1_e-1,X		; get byte from FAC1,X
  6030  a8e3 95b2               	STA	FAC1_o,X		; save byte at FAC2,X
  6031  a8e5 ca                 	DEX				; decrement count
  6032  a8e6 d0f9               	BNE	LAB_27B0		; loop if not all done
  6033                          
  6034  a8e8 86b9               	STX	FAC1_r		; clear FAC1 rounding byte
  6035                          LAB_27B9
  6036  a8ea 60                 	RTS
  6037                          
  6038                          ; round FAC1
  6039                          
  6040                          LAB_27BA
  6041  a8eb a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6042  a8ed f0fb               	BEQ	LAB_27B9		; exit if zero
  6043                          
  6044  a8ef 06b9               	ASL	FAC1_r		; shift FAC1 rounding byte
  6045  a8f1 90f7               	BCC	LAB_27B9		; exit if no overflow
  6046                          
  6047                          ; round FAC1 (no check)
  6048                          
  6049                          LAB_27C2
  6050  a8f3 20caa6             	JSR	LAB_2559		; increment FAC1 mantissa
  6051  a8f6 d0f2               	BNE	LAB_27B9		; branch if no overflow
  6052                          
  6053  a8f8 4c9ba6             	JMP	LAB_252A		; normalise FAC1 for C=1 and return
  6054                          
  6055                          ; get FAC1 sign
  6056                          ; return A=FF,C=1/-ve A=01,C=0/+ve
  6057                          
  6058                          LAB_27CA
  6059  a8fb a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6060  a8fd f009               	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
  6061                          
  6062                          ; return A=FF,C=1/-ve A=01,C=0/+ve
  6063                          ; no = 0 check
  6064                          
  6065                          LAB_27CE
  6066  a8ff a5b0               	LDA	FAC1_s		; else get FAC1 sign (b7)
  6067                          
  6068                          ; return A=FF,C=1/-ve A=01,C=0/+ve
  6069                          ; no = 0 check, sign in A
  6070                          
  6071                          LAB_27D0
  6072  a901 2a                 	ROL				; move sign bit to carry
  6073  a902 a9ff               	LDA	#$FF			; set byte for -ve result
  6074  a904 b002               	BCS	LAB_27D7		; return if sign was set (-ve)
  6075                          
  6076  a906 a901               	LDA	#$01			; else set byte for +ve result
  6077                          LAB_27D7
  6078  a908 60                 	RTS
  6079                          
  6080                          ; perform SGN()
  6081                          
  6082                          LAB_SGN
  6083  a909 20fba8             	JSR	LAB_27CA		; get FAC1 sign
  6084                          					; return A=$FF/-ve A=$01/+ve
  6085                          ; save A as integer byte
  6086                          
  6087                          LAB_27DB
  6088  a90c 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  6089  a90e a900               	LDA	#$00			; clear A
  6090  a910 85ae               	STA	FAC1_2		; clear FAC1 mantissa2
  6091  a912 a288               	LDX	#$88			; set exponent
  6092                          
  6093                          ; set exp=X, clearFAC1 mantissa3 and normalise
  6094                          
  6095                          LAB_27E3
  6096  a914 a5ad               	LDA	FAC1_1		; get FAC1 mantissa1
  6097  a916 49ff               	EOR	#$FF			; complement it
  6098  a918 2a                 	ROL				; sign bit into carry
  6099                          
  6100                          ; set exp=X, clearFAC1 mantissa3 and normalise
  6101                          
  6102                          LAB_STFA
  6103  a919 a900               	LDA	#$00			; clear A
  6104  a91b 85af               	STA	FAC1_3		; clear FAC1 mantissa3
  6105  a91d 86ac               	STX	FAC1_e		; set FAC1 exponent
  6106  a91f 85b9               	STA	FAC1_r		; clear FAC1 rounding byte
  6107  a921 85b0               	STA	FAC1_s		; clear FAC1 sign (b7)
  6108  a923 4c41a6             	JMP	LAB_24D0		; do ABS and normalise FAC1
  6109                          
  6110                          ; perform ABS()
  6111                          
  6112                          LAB_ABS
  6113  a926 46b0               	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
  6114  a928 60                 	RTS
  6115                          
  6116                          ; compare FAC1 with (AY)
  6117                          ; returns A=$00 if FAC1 = (AY)
  6118                          ; returns A=$01 if FAC1 > (AY)
  6119                          ; returns A=$FF if FAC1 < (AY)
  6120                          
  6121                          LAB_27F8
  6122  a929 8573               	STA	ut2_pl		; save pointer low byte
  6123                          LAB_27FA
  6124  a92b 8474               	STY	ut2_ph		; save pointer high byte
  6125  a92d a000               	LDY	#$00			; clear index
  6126  a92f b173               	LDA	(ut2_pl),Y		; get exponent
  6127  a931 c8                 	INY				; increment index
  6128  a932 aa                 	TAX				; copy (AY) exponent to X
  6129  a933 f0c6               	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
  6130                          					; A=FF,C=1/-ve A=01,C=0/+ve
  6131                          
  6132  a935 b173               	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  6133  a937 45b0               	EOR	FAC1_s		; EOR FAC1 sign (b7)
  6134  a939 30c4               	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
  6135                          					; A=01,C=0/+ve and return
  6136                          
  6137  a93b e4ac               	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
  6138  a93d d01a               	BNE	LAB_2828		; branch if different
  6139                          
  6140  a93f b173               	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
  6141  a941 0980               	ORA	#$80			; normalise top bit
  6142  a943 c5ad               	CMP	FAC1_1		; compare with FAC1 mantissa1
  6143  a945 d012               	BNE	LAB_2828		; branch if different
  6144                          
  6145  a947 c8                 	INY				; increment index
  6146  a948 b173               	LDA	(ut2_pl),Y		; get mantissa2
  6147  a94a c5ae               	CMP	FAC1_2		; compare with FAC1 mantissa2
  6148  a94c d00b               	BNE	LAB_2828		; branch if different
  6149                          
  6150  a94e c8                 	INY				; increment index
  6151  a94f a97f               	LDA	#$7F			; set for 1/2 value rounding byte
  6152  a951 c5b9               	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
  6153  a953 b173               	LDA	(ut2_pl),Y		; get mantissa3
  6154  a955 e5af               	SBC	FAC1_3		; subtract FAC1 mantissa3
  6155  a957 f028               	BEQ	LAB_2850		; exit if mantissa3 equal
  6156                          
  6157                          ; gets here if number <> FAC1
  6158                          
  6159                          LAB_2828
  6160  a959 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6161  a95b 9002               	BCC	LAB_282E		; branch if FAC1 > (AY)
  6162                          
  6163  a95d 49ff               	EOR	#$FF			; else toggle FAC1 sign
  6164                          LAB_282E
  6165  a95f 4c01a9             	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
  6166                          
  6167                          ; convert FAC1 floating-to-fixed
  6168                          
  6169                          LAB_2831
  6170  a962 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6171  a964 f04a               	BEQ	LAB_287F		; if zero go clear FAC1 and return
  6172                          
  6173  a966 38                 	SEC				; set carry for subtract
  6174  a967 e998               	SBC	#$98			; subtract maximum integer range exponent
  6175  a969 24b0               	BIT	FAC1_s		; test FAC1 sign (b7)
  6176  a96b 1009               	BPL	LAB_2845		; branch if FAC1 +ve
  6177                          
  6178                          					; FAC1 was -ve
  6179  a96d aa                 	TAX				; copy subtracted exponent
  6180  a96e a9ff               	LDA	#$FF			; overflow for -ve number
  6181  a970 85b2               	STA	FAC1_o		; set FAC1 overflow byte
  6182  a972 20aea6             	JSR	LAB_253D		; twos complement FAC1 mantissa
  6183  a975 8a                 	TXA				; restore subtracted exponent
  6184                          LAB_2845
  6185  a976 a2ac               	LDX	#FAC1_e		; set index to FAC1
  6186  a978 c9f9               	CMP	#$F9			; compare exponent result
  6187  a97a 1006               	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
  6188                          
  6189  a97c 20eca6             	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
  6190  a97f 84b2               	STY	FAC1_o		; clear FAC1 overflow byte
  6191                          LAB_2850
  6192  a981 60                 	RTS
  6193                          
  6194                          ; shift FAC1 A times right
  6195                          
  6196                          LAB_2851
  6197  a982 a8                 	TAY				; copy shift count
  6198  a983 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6199  a985 2980               	AND	#$80			; mask sign bit only (x000 0000)
  6200  a987 46ad               	LSR	FAC1_1		; shift FAC1 mantissa1
  6201  a989 05ad               	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
  6202  a98b 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  6203  a98d 2003a7             	JSR	LAB_2592		; shift FAC1 Y times right
  6204  a990 84b2               	STY	FAC1_o		; clear FAC1 overflow byte
  6205  a992 60                 	RTS
  6206                          
  6207                          ; perform INT()
  6208                          
  6209                          LAB_INT
  6210  a993 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6211  a995 c998               	CMP	#$98			; compare with max int
  6212  a997 b01e               	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
  6213                          
  6214  a999 2062a9             	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  6215  a99c 84b9               	STY	FAC1_r		; save FAC1 rounding byte
  6216  a99e a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6217  a9a0 84b0               	STY	FAC1_s		; save FAC1 sign (b7)
  6218  a9a2 4980               	EOR	#$80			; toggle FAC1 sign
  6219  a9a4 2a                 	ROL				; shift into carry
  6220  a9a5 a998               	LDA	#$98			; set new exponent
  6221  a9a7 85ac               	STA	FAC1_e		; save FAC1 exponent
  6222  a9a9 a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  6223  a9ab 855b               	STA	Temp3			; save for EXP() function
  6224  a9ad 4c41a6             	JMP	LAB_24D0		; do ABS and normalise FAC1
  6225                          
  6226                          ; clear FAC1 and return
  6227                          
  6228                          LAB_287F
  6229  a9b0 85ad               	STA	FAC1_1		; clear FAC1 mantissa1
  6230  a9b2 85ae               	STA	FAC1_2		; clear FAC1 mantissa2
  6231  a9b4 85af               	STA	FAC1_3		; clear FAC1 mantissa3
  6232  a9b6 a8                 	TAY				; clear Y
  6233                          LAB_2886
  6234  a9b7 60                 	RTS
  6235                          
  6236                          ; get FAC1 from string
  6237                          ; this routine now handles hex and binary values from strings
  6238                          ; starting with "$" and "%" respectively
  6239                          
  6240                          LAB_2887
  6241  a9b8 a000               	LDY	#$00			; clear Y
  6242  a9ba 845f               	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
  6243  a9bc a209               	LDX	#$09			; set index
  6244                          LAB_288B
  6245  a9be 94a8               	STY	numexp,X		; clear byte
  6246  a9c0 ca                 	DEX				; decrement index
  6247  a9c1 10fb               	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
  6248                          
  6249  a9c3 907f               	BCC	LAB_28FE		; branch if 1st character numeric
  6250                          
  6251                          ; get FAC1 from string .. first character wasn't numeric
  6252                          
  6253  a9c5 c92d               	CMP	#'-'			; else compare with "-"
  6254  a9c7 d004               	BNE	LAB_289A		; branch if not "-"
  6255                          
  6256  a9c9 86b1               	STX	negnum		; set flag for -ve number (X = $FF)
  6257  a9cb f004               	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
  6258                          
  6259                          ; get FAC1 from string .. first character wasn't numeric or -
  6260                          
  6261                          LAB_289A
  6262  a9cd c92b               	CMP	#'+'			; else compare with "+"
  6263  a9cf d005               	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
  6264                          
  6265                          ; was "+" or "-" to start, so get next character
  6266                          
  6267                          LAB_289C
  6268  a9d1 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  6269  a9d4 906e               	BCC	LAB_28FE		; branch if numeric character
  6270                          
  6271                          ; code here for hex and binary numbers
  6272                          
  6273                          LAB_289D
  6274  a9d6 c924               	CMP	#'$'			; else compare with "$"
  6275  a9d8 d003               	BNE	LAB_NHEX		; branch if not "$"
  6276                          
  6277  a9da 4c80ae             	JMP	LAB_CHEX		; branch if "$"
  6278                          
  6279                          LAB_NHEX
  6280  a9dd c925               	CMP	#'%'			; else compare with "%"
  6281  a9df d008               	BNE	LAB_28A3		; branch if not "%" (continue original code)
  6282                          
  6283  a9e1 4caeae             	JMP	LAB_CBIN		; branch if "%"
  6284                          
  6285                          LAB_289E
  6286  a9e4 20bc00             	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
  6287                          LAB_28A1
  6288  a9e7 905b               	BCC	LAB_28FE		; branch if numeric character
  6289                          
  6290                          ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6291                          
  6292                          LAB_28A3
  6293  a9e9 c92e               	CMP	#'.'			; else compare with "."
  6294  a9eb f02e               	BEQ	LAB_28D5		; branch if "."
  6295                          
  6296                          ; get FAC1 from string .. character wasn't numeric, -, + or .
  6297                          
  6298  a9ed c945               	CMP	#'E'			; else compare with "E"
  6299  a9ef d030               	BNE	LAB_28DB		; branch if not "E"
  6300                          
  6301                          					; was "E" so evaluate exponential part
  6302  a9f1 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  6303  a9f4 9017               	BCC	LAB_28C7		; branch if numeric character
  6304                          
  6305  a9f6 c9b7               	CMP	#TK_MINUS		; else compare with token for -
  6306  a9f8 f00e               	BEQ	LAB_28C2		; branch if token for -
  6307                          
  6308  a9fa c92d               	CMP	#'-'			; else compare with "-"
  6309  a9fc f00a               	BEQ	LAB_28C2		; branch if "-"
  6310                          
  6311  a9fe c9b6               	CMP	#TK_PLUS		; else compare with token for +
  6312  aa00 f008               	BEQ	LAB_28C4		; branch if token for +
  6313                          
  6314  aa02 c92b               	CMP	#'+'			; else compare with "+"
  6315  aa04 f004               	BEQ	LAB_28C4		; branch if "+"
  6316                          
  6317  aa06 d007               	BNE	LAB_28C9		; branch always
  6318                          
  6319                          LAB_28C2
  6320  aa08 66ab               	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
  6321                          LAB_28C4
  6322  aa0a 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  6323                          LAB_28C7
  6324  aa0d 905b               	BCC	LAB_2925		; branch if numeric character
  6325                          
  6326                          LAB_28C9
  6327  aa0f 24ab               	BIT	expneg		; test exponent -ve flag
  6328  aa11 100e               	BPL	LAB_28DB		; if +ve go evaluate exponent
  6329                          
  6330                          					; else do exponent = -exponent 
  6331  aa13 a900               	LDA	#$00			; clear result
  6332  aa15 38                 	SEC				; set carry for subtract
  6333  aa16 e5a9               	SBC	expcnt		; subtract exponent byte
  6334  aa18 4c23aa             	JMP	LAB_28DD		; go evaluate exponent
  6335                          
  6336                          LAB_28D5
  6337  aa1b 66aa               	ROR	numdpf		; set decimal point flag
  6338  aa1d 24aa               	BIT	numdpf		; test decimal point flag
  6339  aa1f 50c3               	BVC	LAB_289E		; branch if only one decimal point so far
  6340                          
  6341                          					; evaluate exponent
  6342                          LAB_28DB
  6343  aa21 a5a9               	LDA	expcnt		; get exponent count byte
  6344                          LAB_28DD
  6345  aa23 38                 	SEC				; set carry for subtract
  6346  aa24 e5a8               	SBC	numexp		; subtract numerator exponent
  6347  aa26 85a9               	STA	expcnt		; save exponent count byte
  6348  aa28 f012               	BEQ	LAB_28F6		; branch if no adjustment
  6349                          
  6350  aa2a 1009               	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
  6351                          
  6352                          					; else go do FAC1/10^(0-expcnt)
  6353                          LAB_28E6
  6354  aa2c 2002a8             	JSR	LAB_26B9		; divide by 10
  6355  aa2f e6a9               	INC	expcnt		; increment exponent count byte
  6356  aa31 d0f9               	BNE	LAB_28E6		; loop until all done
  6357                          
  6358  aa33 f007               	BEQ	LAB_28F6		; branch always
  6359                          
  6360                          LAB_28EF
  6361  aa35 20e9a7             	JSR	LAB_269E		; multiply by 10
  6362  aa38 c6a9               	DEC	expcnt		; decrement exponent count byte
  6363  aa3a d0f9               	BNE	LAB_28EF		; loop until all done
  6364                          
  6365                          LAB_28F6
  6366  aa3c a5b1               	LDA	negnum		; get -ve flag
  6367  aa3e 3001               	BMI	LAB_28FB		; if -ve do - FAC1 and return
  6368                          
  6369  aa40 60                 	RTS
  6370                          
  6371                          ; do - FAC1 and return
  6372                          
  6373                          LAB_28FB
  6374  aa41 4c06ac             	JMP	LAB_GTHAN		; do - FAC1 and return
  6375                          
  6376                          ; do unsigned FAC1*10+number
  6377                          
  6378                          LAB_28FE
  6379  aa44 48                 	PHA				; save character
  6380  aa45 24aa               	BIT	numdpf		; test decimal point flag
  6381  aa47 1002               	BPL	LAB_2905		; skip exponent increment if not set
  6382                          
  6383  aa49 e6a8               	INC	numexp		; else increment number exponent
  6384                          LAB_2905
  6385  aa4b 20e9a7             	JSR	LAB_269E		; multiply FAC1 by 10
  6386  aa4e 68                 	PLA				; restore character
  6387  aa4f 290f               	AND	#$0F			; convert to binary
  6388  aa51 2057aa             	JSR	LAB_2912		; evaluate new ASCII digit
  6389  aa54 4ce4a9             	JMP	LAB_289E		; go do next character
  6390                          
  6391                          ; evaluate new ASCII digit
  6392                          
  6393                          LAB_2912
  6394  aa57 48                 	PHA				; save digit
  6395  aa58 20dca8             	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6396  aa5b 68                 	PLA				; restore digit
  6397  aa5c 200ca9             	JSR	LAB_27DB		; save A as integer byte
  6398  aa5f a5b7               	LDA	FAC2_s		; get FAC2 sign (b7)
  6399  aa61 45b0               	EOR	FAC1_s		; toggle with FAC1 sign (b7)
  6400  aa63 85b8               	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
  6401  aa65 a6ac               	LDX	FAC1_e		; get FAC1 exponent
  6402  aa67 4cd3a5             	JMP	LAB_ADD		; add FAC2 to FAC1 and return
  6403                          
  6404                          ; evaluate next character of exponential part of number
  6405                          
  6406                          LAB_2925
  6407  aa6a a5a9               	LDA	expcnt		; get exponent count byte
  6408  aa6c c90a               	CMP	#$0A			; compare with 10 decimal
  6409  aa6e 9009               	BCC	LAB_2934		; branch if less
  6410                          
  6411  aa70 a964               	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
  6412  aa72 24ab               	BIT	expneg		; test exponent -ve flag
  6413  aa74 300e               	BMI	LAB_2942		; branch if -ve
  6414                          
  6415  aa76 4cd5a6             	JMP	LAB_2564		; else do overflow error
  6416                          
  6417                          LAB_2934
  6418  aa79 0a                 	ASL				; * 2
  6419  aa7a 0a                 	ASL				; * 4
  6420  aa7b 65a9               	ADC	expcnt		; * 5
  6421  aa7d 0a                 	ASL				; * 10
  6422  aa7e a000               	LDY	#$00			; set index
  6423  aa80 71c3               	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
  6424  aa82 e92f               	SBC	#'0'-1		; convert character to binary
  6425                          LAB_2942
  6426  aa84 85a9               	STA	expcnt		; save exponent count byte
  6427  aa86 4c0aaa             	JMP	LAB_28C4		; go get next character
  6428                          
  6429                          ; print " in line [LINE #]"
  6430                          
  6431                          LAB_2953
  6432  aa89 a902               	LDA	#<LAB_LMSG		; point to " in line " message low byte
  6433  aa8b a0b8               	LDY	#>LAB_LMSG		; point to " in line " message high byte
  6434  aa8d 20e598             	JSR	LAB_18C3		; print null terminated string from memory
  6435                          
  6436                          					; print Basic line #
  6437  aa90 a588               	LDA	Clineh		; get current line high byte
  6438  aa92 a687               	LDX	Clinel		; get current line low byte
  6439                          
  6440                          ; print XA as unsigned integer
  6441                          
  6442                          LAB_295E
  6443  aa94 85ad               	STA	FAC1_1		; save low byte as FAC1 mantissa1
  6444  aa96 86ae               	STX	FAC1_2		; save high byte as FAC1 mantissa2
  6445  aa98 a290               	LDX	#$90			; set exponent to 16d bits
  6446  aa9a 38                 	SEC				; set integer is +ve flag
  6447  aa9b 2019a9             	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
  6448  aa9e a000               	LDY	#$00			; clear index
  6449  aaa0 98                 	TYA				; clear A
  6450  aaa1 20b4aa             	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
  6451  aaa4 4ce598             	JMP	LAB_18C3		; print null terminated string from memory and return
  6452                          
  6453                          ; convert FAC1 to ASCII string result in (AY)
  6454                          ; not any more, moved scratchpad to page 0
  6455                          
  6456                          LAB_296E
  6457  aaa7 a001               	LDY	#$01			; set index = 1
  6458  aaa9 a920               	LDA	#$20			; character = " " (assume +ve)
  6459  aaab 24b0               	BIT	FAC1_s		; test FAC1 sign (b7)
  6460  aaad 1002               	BPL	LAB_2978		; branch if +ve
  6461                          
  6462  aaaf a92d               	LDA	#$2D			; else character = "-"
  6463                          LAB_2978
  6464  aab1 99e200             	STA	Decss,Y		; save leading character (" " or "-")
  6465                          LAB_297B
  6466  aab4 85b0               	STA	FAC1_s		; clear FAC1 sign (b7)
  6467  aab6 84ba               	STY	Sendl			; save index
  6468  aab8 c8                 	INY				; increment index
  6469  aab9 a6ac               	LDX	FAC1_e		; get FAC1 exponent
  6470  aabb d005               	BNE	LAB_2989		; branch if FAC1<>0
  6471                          
  6472                          					; exponent was $00 so FAC1 is 0
  6473  aabd a930               	LDA	#'0'			; set character = "0"
  6474  aabf 4cc0ab             	JMP	LAB_2A89		; save last character, [EOT] and exit
  6475                          
  6476                          					; FAC1 is some non zero value
  6477                          LAB_2989
  6478  aac2 a900               	LDA	#$00			; clear (number exponent count)
  6479  aac4 e081               	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
  6480                          
  6481  aac6 b009               	BCS	LAB_299A		; branch if FAC1=>1
  6482                          
  6483                          					; FAC1<1
  6484  aac8 a984               	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
  6485  aaca a0b1               	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
  6486  aacc 204ba7             	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6487  aacf a9fa               	LDA	#$FA			; set number exponent count (-6)
  6488                          LAB_299A
  6489  aad1 85a8               	STA	numexp		; save number exponent count
  6490                          LAB_299C
  6491  aad3 a980               	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
  6492  aad5 a0b1               	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
  6493  aad7 2029a9             	JSR	LAB_27F8		; compare FAC1 with (AY)
  6494  aada f01e               	BEQ	LAB_29C3		; exit if FAC1 = (AY)
  6495                          
  6496  aadc 1012               	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
  6497                          
  6498                          					; FAC1 < (AY)
  6499                          LAB_29A7
  6500  aade a97c               	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
  6501  aae0 a0b1               	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
  6502  aae2 2029a9             	JSR	LAB_27F8		; compare FAC1 with (AY)
  6503  aae5 f002               	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
  6504                          
  6505  aae7 100e               	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
  6506                          
  6507                          					; FAC1 <= (AY)
  6508                          LAB_29B2
  6509  aae9 20e9a7             	JSR	LAB_269E		; multiply by 10
  6510  aaec c6a8               	DEC	numexp		; decrement number exponent count
  6511  aaee d0ee               	BNE	LAB_29A7		; go test again (branch always)
  6512                          
  6513                          LAB_29B9
  6514  aaf0 2002a8             	JSR	LAB_26B9		; divide by 10
  6515  aaf3 e6a8               	INC	numexp		; increment number exponent count
  6516  aaf5 d0dc               	BNE	LAB_299C		; go test again (branch always)
  6517                          
  6518                          ; now we have just the digits to do
  6519                          
  6520                          LAB_29C0
  6521  aaf7 20cca5             	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
  6522                          LAB_29C3
  6523  aafa 2062a9             	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  6524  aafd a201               	LDX	#$01			; set default digits before dp = 1
  6525  aaff a5a8               	LDA	numexp		; get number exponent count
  6526  ab01 18                 	CLC				; clear carry for add
  6527  ab02 6907               	ADC	#$07			; up to 6 digits before point
  6528  ab04 3009               	BMI	LAB_29D8		; if -ve then 1 digit before dp
  6529                          
  6530  ab06 c908               	CMP	#$08			; A>=8 if n>=1E6
  6531  ab08 b006               	BCS	LAB_29D9		; branch if >= $08
  6532                          
  6533                          					; carry is clear
  6534  ab0a 69ff               	ADC	#$FF			; take 1 from digit count
  6535  ab0c aa                 	TAX				; copy to A
  6536  ab0d a902               	LDA	#$02			;.set exponent adjust
  6537                          LAB_29D8
  6538  ab0f 38                 	SEC				; set carry for subtract
  6539                          LAB_29D9
  6540  ab10 e902               	SBC	#$02			; -2
  6541  ab12 85a9               	STA	expcnt		;.save exponent adjust
  6542  ab14 86a8               	STX	numexp		; save digits before dp count
  6543  ab16 8a                 	TXA				; copy to A
  6544  ab17 f002               	BEQ	LAB_29E4		; branch if no digits before dp
  6545                          
  6546  ab19 1013               	BPL	LAB_29F7		; branch if digits before dp
  6547                          
  6548                          LAB_29E4
  6549  ab1b a4ba               	LDY	Sendl			; get output string index
  6550  ab1d a92e               	LDA	#$2E			; character "."
  6551  ab1f c8                 	INY				; increment index
  6552  ab20 99e200             	STA	Decss,Y		; save to output string
  6553  ab23 8a                 	TXA				;.
  6554  ab24 f006               	BEQ	LAB_29F5		;.
  6555                          
  6556  ab26 a930               	LDA	#'0'			; character "0"
  6557  ab28 c8                 	INY				; increment index
  6558  ab29 99e200             	STA	Decss,Y		; save to output string
  6559                          LAB_29F5
  6560  ab2c 84ba               	STY	Sendl			; save output string index
  6561                          LAB_29F7
  6562  ab2e a000               	LDY	#$00			; clear index (point to 100,000)
  6563  ab30 a280               	LDX	#$80			; 
  6564                          LAB_29FB
  6565  ab32 a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  6566  ab34 18                 	CLC				; clear carry for add
  6567  ab35 79fab1             	ADC	LAB_2A9C,Y		; add -ve LSB
  6568  ab38 85af               	STA	FAC1_3		; save FAC1 mantissa3
  6569  ab3a a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  6570  ab3c 79f9b1             	ADC	LAB_2A9B,Y		; add -ve NMSB
  6571  ab3f 85ae               	STA	FAC1_2		; save FAC1 mantissa2
  6572  ab41 a5ad               	LDA	FAC1_1		; get FAC1 mantissa1
  6573  ab43 79f8b1             	ADC	LAB_2A9A,Y		; add -ve MSB
  6574  ab46 85ad               	STA	FAC1_1		; save FAC1 mantissa1
  6575  ab48 e8                 	INX				; 
  6576  ab49 b004               	BCS	LAB_2A18		; 
  6577                          
  6578  ab4b 10e5               	BPL	LAB_29FB		; not -ve so try again
  6579                          
  6580  ab4d 3002               	BMI	LAB_2A1A		; 
  6581                          
  6582                          LAB_2A18
  6583  ab4f 30e1               	BMI	LAB_29FB		; 
  6584                          
  6585                          LAB_2A1A
  6586  ab51 8a                 	TXA				; 
  6587  ab52 9004               	BCC	LAB_2A21		; 
  6588                          
  6589  ab54 49ff               	EOR	#$FF			; 
  6590  ab56 690a               	ADC	#$0A			; 
  6591                          LAB_2A21
  6592  ab58 692f               	ADC	#'0'-1		; add "0"-1 to result
  6593  ab5a c8                 	INY				; increment index ..
  6594  ab5b c8                 	INY				; .. to next less ..
  6595  ab5c c8                 	INY				; .. power of ten
  6596  ab5d 8495               	STY	Cvaral		; save as current var address low byte
  6597  ab5f a4ba               	LDY	Sendl			; get output string index
  6598  ab61 c8                 	INY				; increment output string index
  6599  ab62 aa                 	TAX				; copy character to X
  6600  ab63 297f               	AND	#$7F			; mask out top bit
  6601  ab65 99e200             	STA	Decss,Y		; save to output string
  6602  ab68 c6a8               	DEC	numexp		; decrement # of characters before the dp
  6603  ab6a d006               	BNE	LAB_2A3B		; branch if still characters to do
  6604                          
  6605                          					; else output the point
  6606  ab6c a92e               	LDA	#$2E			; character "."
  6607  ab6e c8                 	INY				; increment output string index
  6608  ab6f 99e200             	STA	Decss,Y		; save to output string
  6609                          LAB_2A3B
  6610  ab72 84ba               	STY	Sendl			; save output string index
  6611  ab74 a495               	LDY	Cvaral		; get current var address low byte
  6612  ab76 8a                 	TXA				; get character back
  6613  ab77 49ff               	EOR	#$FF			; 
  6614  ab79 2980               	AND	#$80			; 
  6615  ab7b aa                 	TAX				; 
  6616  ab7c c012               	CPY	#$12			; compare index with max
  6617  ab7e d0b2               	BNE	LAB_29FB		; loop if not max
  6618                          
  6619                          					; now remove trailing zeroes
  6620  ab80 a4ba               	LDY	Sendl			; get output string index
  6621                          LAB_2A4B
  6622  ab82 b9e200             	LDA	Decss,Y		; get character from output string
  6623  ab85 88                 	DEY				; decrement output string index
  6624  ab86 c930               	CMP	#'0'			; compare with "0"
  6625  ab88 f0f8               	BEQ	LAB_2A4B		; loop until non "0" character found
  6626                          
  6627  ab8a c92e               	CMP	#'.'			; compare with "."
  6628  ab8c f001               	BEQ	LAB_2A58		; branch if was dp
  6629                          
  6630                          					; restore last character
  6631  ab8e c8                 	INY				; increment output string index
  6632                          LAB_2A58
  6633  ab8f a92b               	LDA	#$2B			; character "+"
  6634  ab91 a6a9               	LDX	expcnt		; get exponent count
  6635  ab93 f02e               	BEQ	LAB_2A8C		; if zero go set null terminator and exit
  6636                          
  6637                          					; exponent isn't zero so write exponent
  6638  ab95 1008               	BPL	LAB_2A68		; branch if exponent count +ve
  6639                          
  6640  ab97 a900               	LDA	#$00			; clear A
  6641  ab99 38                 	SEC				; set carry for subtract
  6642  ab9a e5a9               	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
  6643  ab9c aa                 	TAX				; copy exponent count to X
  6644  ab9d a92d               	LDA	#'-'			; character "-"
  6645                          LAB_2A68
  6646  ab9f 99e400             	STA	Decss+2,Y		; save to output string
  6647  aba2 a945               	LDA	#$45			; character "E"
  6648  aba4 99e300             	STA	Decss+1,Y		; save exponent sign to output string
  6649  aba7 8a                 	TXA				; get exponent count back
  6650  aba8 a22f               	LDX	#'0'-1		; one less than "0" character
  6651  abaa 38                 	SEC				; set carry for subtract
  6652                          LAB_2A74
  6653  abab e8                 	INX				; increment 10's character
  6654  abac e90a               	SBC	#$0A			;.subtract 10 from exponent count
  6655  abae b0fb               	BCS	LAB_2A74		; loop while still >= 0
  6656                          
  6657  abb0 693a               	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
  6658  abb2 99e600             	STA	Decss+4,Y		; save to output string
  6659  abb5 8a                 	TXA				; copy 10's character
  6660  abb6 99e500             	STA	Decss+3,Y		; save to output string
  6661  abb9 a900               	LDA	#$00			; set null terminator
  6662  abbb 99e700             	STA	Decss+5,Y		; save to output string
  6663  abbe f008               	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
  6664                          
  6665                          					; save last character, [EOT] and exit
  6666                          LAB_2A89
  6667  abc0 99e200             	STA	Decss,Y		; save last character to output string
  6668                          
  6669                          					; set null terminator and exit
  6670                          LAB_2A8C
  6671  abc3 a900               	LDA	#$00			; set null terminator
  6672  abc5 99e300             	STA	Decss+1,Y		; save after last character
  6673                          
  6674                          					; set string pointer (AY) and exit
  6675                          LAB_2A91
  6676  abc8 a9e3               	LDA	#<Decssp1		; set result string low pointer
  6677  abca a000               	LDY	#>Decssp1		; set result string high pointer
  6678  abcc 60                 	RTS
  6679                          
  6680                          ; perform power function
  6681                          
  6682                          LAB_POWER
  6683  abcd f042               	BEQ	LAB_EXP		; go do  EXP()
  6684                          
  6685  abcf a5b3               	LDA	FAC2_e		; get FAC2 exponent
  6686  abd1 d003               	BNE	LAB_2ABF		; branch if FAC2<>0
  6687                          
  6688  abd3 4c64a6             	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
  6689                          
  6690                          LAB_2ABF
  6691  abd6 a29c               	LDX	#<func_l		; set destination pointer low byte
  6692  abd8 a000               	LDY	#>func_l		; set destination pointer high byte
  6693  abda 20b9a8             	JSR	LAB_2778		; pack FAC1 into (XY)
  6694  abdd a5b7               	LDA	FAC2_s		; get FAC2 sign (b7)
  6695  abdf 100f               	BPL	LAB_2AD9		; branch if FAC2>0
  6696                          
  6697                          					; else FAC2 is -ve and can only be raised to an
  6698                          					; integer power which gives an x +j0 result
  6699  abe1 2093a9             	JSR	LAB_INT		; perform INT
  6700  abe4 a99c               	LDA	#<func_l		; set source pointer low byte
  6701  abe6 a000               	LDY	#>func_l		; set source pointer high byte
  6702  abe8 2029a9             	JSR	LAB_27F8		; compare FAC1 with (AY)
  6703  abeb d003               	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
  6704                          					; this will leave FAC1 -ve and cause a Function Call
  6705                          					; error when LOG() is called
  6706                          
  6707  abed 98                 	TYA				; clear sign b7
  6708  abee a45b               	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
  6709                          					; for possible later negation, b0
  6710                          LAB_2AD9
  6711  abf0 20d7a5             	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
  6712  abf3 98                 	TYA				; copy sign back ..
  6713  abf4 48                 	PHA				; .. and save it
  6714  abf5 200da7             	JSR	LAB_LOG		; do LOG(n)
  6715  abf8 a99c               	LDA	#<garb_l		; set pointer low byte
  6716  abfa a000               	LDY	#>garb_l		; set pointer high byte
  6717  abfc 204ba7             	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
  6718  abff 2011ac             	JSR	LAB_EXP		; go do EXP(n)
  6719  ac02 68                 	PLA				; pull sign from stack
  6720  ac03 4a                 	LSR				; b0 is to be tested, shift to Cb
  6721  ac04 900a               	BCC	LAB_2AF9		; if no bit then exit
  6722                          
  6723                          					; Perform negation
  6724                          ; do - FAC1
  6725                          
  6726                          LAB_GTHAN
  6727  ac06 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6728  ac08 f006               	BEQ	LAB_2AF9		; exit if FAC1_e = $00
  6729                          
  6730  ac0a a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6731  ac0c 49ff               	EOR	#$FF			; complement it
  6732  ac0e 85b0               	STA	FAC1_s		; save FAC1 sign (b7)
  6733                          LAB_2AF9
  6734  ac10 60                 	RTS
  6735                          
  6736                          ; perform EXP()	(x^e)
  6737                          
  6738                          LAB_EXP
  6739  ac11 a988               	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
  6740  ac13 a0b1               	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
  6741  ac15 204ba7             	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6742  ac18 a5b9               	LDA	FAC1_r		; get FAC1 rounding byte
  6743  ac1a 6950               	ADC	#$50			; +$50/$100
  6744  ac1c 9003               	BCC	LAB_2B2B		; skip rounding if no carry
  6745                          
  6746  ac1e 20f3a8             	JSR	LAB_27C2		; round FAC1 (no check)
  6747                          LAB_2B2B
  6748  ac21 85a3               	STA	FAC2_r		; save FAC2 rounding byte
  6749  ac23 20dfa8             	JSR	LAB_27AE		; copy FAC1 to FAC2
  6750  ac26 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6751  ac28 c988               	CMP	#$88			; compare with EXP limit (256d)
  6752  ac2a 9003               	BCC	LAB_2B39		; branch if less
  6753                          
  6754                          LAB_2B36
  6755  ac2c 20e0a7             	JSR	LAB_2690		; handle overflow and underflow
  6756                          LAB_2B39
  6757  ac2f 2093a9             	JSR	LAB_INT		; perform INT
  6758  ac32 a55b               	LDA	Temp3			; get mantissa 3 from INT() function
  6759  ac34 18                 	CLC				; clear carry for add
  6760  ac35 6981               	ADC	#$81			; normalise +1
  6761  ac37 f0f3               	BEQ	LAB_2B36		; if $00 go handle overflow
  6762                          
  6763  ac39 38                 	SEC				; set carry for subtract
  6764  ac3a e901               	SBC	#$01			; now correct for exponent
  6765  ac3c 48                 	PHA				; save FAC2 exponent
  6766                          
  6767                          					; swap FAC1 and FAC2
  6768  ac3d a204               	LDX	#$04			; 4 bytes to do
  6769                          LAB_2B49
  6770  ac3f b5b3               	LDA	FAC2_e,X		; get FAC2,X
  6771  ac41 b4ac               	LDY	FAC1_e,X		; get FAC1,X
  6772  ac43 95ac               	STA	FAC1_e,X		; save FAC1,X
  6773  ac45 94b3               	STY	FAC2_e,X		; save FAC2,X
  6774  ac47 ca                 	DEX				; decrement count/index
  6775  ac48 10f5               	BPL	LAB_2B49		; loop if not all done
  6776                          
  6777  ac4a a5a3               	LDA	FAC2_r		; get FAC2 rounding byte
  6778  ac4c 85b9               	STA	FAC1_r		; save as FAC1 rounding byte
  6779  ac4e 20b8a5             	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
  6780  ac51 2006ac             	JSR	LAB_GTHAN		; do - FAC1
  6781  ac54 a98c               	LDA	#<LAB_2AFE		; set counter pointer low byte
  6782  ac56 a0b1               	LDY	#>LAB_2AFE		; set counter pointer high byte
  6783  ac58 2079ac             	JSR	LAB_2B84		; go do series evaluation
  6784  ac5b a900               	LDA	#$00			; clear A
  6785  ac5d 85b8               	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
  6786  ac5f 68                 	PLA				;.get saved FAC2 exponent
  6787  ac60 4cc5a7             	JMP	LAB_2675		; test and adjust accumulators and return
  6788                          
  6789                          ; ^2 then series evaluation
  6790                          
  6791                          LAB_2B6E
  6792  ac63 85ba               	STA	Cptrl			; save count pointer low byte
  6793  ac65 84bb               	STY	Cptrh			; save count pointer high byte
  6794  ac67 20afa8             	JSR	LAB_276E		; pack FAC1 into Adatal
  6795  ac6a a9a4               	LDA	#<Adatal		; set pointer low byte (Y already $00)
  6796  ac6c 204ba7             	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6797  ac6f 207dac             	JSR	LAB_2B88		; go do series evaluation
  6798  ac72 a9a4               	LDA	#<Adatal		; pointer to original # low byte
  6799  ac74 a000               	LDY	#>Adatal		; pointer to original # high byte
  6800  ac76 4c4ba7             	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
  6801                          
  6802                          ; series evaluation
  6803                          
  6804                          LAB_2B84
  6805  ac79 85ba               	STA	Cptrl			; save count pointer low byte
  6806  ac7b 84bb               	STY	Cptrh			; save count pointer high byte
  6807                          LAB_2B88
  6808  ac7d a2a8               	LDX	#<numexp		; set pointer low byte
  6809  ac7f 20b1a8             	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
  6810  ac82 b1ba               	LDA	(Cptrl),Y		; get constants count
  6811  ac84 85b1               	STA	numcon		; save constants count
  6812  ac86 a4ba               	LDY	Cptrl			; get count pointer low byte
  6813  ac88 c8                 	INY				; increment it (now constants pointer)
  6814  ac89 98                 	TYA				; copy it
  6815  ac8a d002               	BNE	LAB_2B97		; skip next if no overflow
  6816                          
  6817  ac8c e6bb               	INC	Cptrh			; else increment high byte
  6818                          LAB_2B97
  6819  ac8e 85ba               	STA	Cptrl			; save low byte
  6820  ac90 a4bb               	LDY	Cptrh			; get high byte
  6821                          LAB_2B9B
  6822  ac92 204ba7             	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6823  ac95 a5ba               	LDA	Cptrl			; get constants pointer low byte
  6824  ac97 a4bb               	LDY	Cptrh			; get constants pointer high byte
  6825  ac99 18                 	CLC				; clear carry for add
  6826  ac9a 6904               	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
  6827  ac9c 9001               	BCC	LAB_2BA8		; skip next if no overflow
  6828                          
  6829  ac9e c8                 	INY				; increment high byte
  6830                          LAB_2BA8
  6831  ac9f 85ba               	STA	Cptrl			; save pointer low byte
  6832  aca1 84bb               	STY	Cptrh			; save pointer high byte
  6833  aca3 20d0a5             	JSR	LAB_246C		; add (AY) to FAC1
  6834  aca6 a9a8               	LDA	#<numexp		; set pointer low byte to partial @ numexp
  6835  aca8 a000               	LDY	#>numexp		; set pointer high byte to partial @ numexp
  6836  acaa c6b1               	DEC	numcon		; decrement constants count
  6837  acac d0e4               	BNE	LAB_2B9B		; loop until all done
  6838                          
  6839  acae 60                 	RTS
  6840                          
  6841                          ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6842                          ; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6843                          ; the Galois method and a sample of 65536 bytes produced gives the following values.
  6844                          
  6845                          ; Entropy = 7.997442 bits per byte
  6846                          ; Optimum compression would reduce these 65536 bytes by 0 percent
  6847                          
  6848                          ; Chi square distribution for 65536 samples is 232.01, and
  6849                          ; randomly would exceed this value 75.00 percent of the time
  6850                          
  6851                          ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6852                          ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6853                          ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6854                          
  6855                          LAB_RND
  6856  acaf a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6857  acb1 f007               	BEQ	NextPRN		; do next random # if zero
  6858                          
  6859                          					; else get seed into random number store
  6860  acb3 a2d8               	LDX	#Rbyte4		; set PRNG pointer low byte
  6861  acb5 a000               	LDY	#$00			; set PRNG pointer high byte
  6862  acb7 20b9a8             	JSR	LAB_2778		; pack FAC1 into (XY)
  6863                          NextPRN
  6864  acba a2af               	LDX	#$AF			; set EOR byte
  6865  acbc a013               	LDY	#$13			; do this nineteen times
  6866                          LoopPRN
  6867  acbe 06d9               	ASL	Rbyte1		; shift PRNG most significant byte
  6868  acc0 26da               	ROL	Rbyte2		; shift PRNG middle byte
  6869  acc2 26db               	ROL	Rbyte3		; shift PRNG least significant byte
  6870  acc4 26d8               	ROL	Rbyte4		; shift PRNG extra byte
  6871  acc6 9005               	BCC	Ninc1			; branch if bit 32 clear
  6872                          
  6873  acc8 8a                 	TXA				; set EOR byte
  6874  acc9 45d9               	EOR	Rbyte1		; EOR PRNG extra byte
  6875  accb 85d9               	STA	Rbyte1		; save new PRNG extra byte
  6876                          Ninc1
  6877  accd 88                 	DEY				; decrement loop count
  6878  acce d0ee               	BNE	LoopPRN		; loop if not all done
  6879                          
  6880  acd0 a202               	LDX	#$02			; three bytes to copy
  6881                          CopyPRNG
  6882  acd2 b5d9               	LDA	Rbyte1,X		; get PRNG byte
  6883  acd4 95ad               	STA	FAC1_1,X		; save FAC1 byte
  6884  acd6 ca                 	DEX
  6885  acd7 10f9               	BPL	CopyPRNG		; loop if not complete
  6886                          
  6887  acd9 a980               	LDA	#$80			; set the exponent
  6888  acdb 85ac               	STA	FAC1_e		; save FAC1 exponent
  6889                          
  6890  acdd 0a                 	ASL				; clear A
  6891  acde 85b0               	STA	FAC1_s		; save FAC1 sign
  6892                          
  6893  ace0 4c46a6             	JMP	LAB_24D5		; normalise FAC1 and return
  6894                          
  6895                          ; perform COS()
  6896                          
  6897                          LAB_COS
  6898  ace3 a9a9               	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6899  ace5 a0b1               	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6900  ace7 20d0a5             	JSR	LAB_246C		; add (AY) to FAC1
  6901                          
  6902                          ; perform SIN()
  6903                          
  6904                          LAB_SIN
  6905  acea 20dca8             	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6906  aced a9be               	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  6907  acef a0b1               	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  6908  acf1 a6b7               	LDX	FAC2_s		; get FAC2 sign (b7)
  6909  acf3 200ba8             	JSR	LAB_26C2		; divide by (AY) (X=sign)
  6910  acf6 20dca8             	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6911  acf9 2093a9             	JSR	LAB_INT		; perform INT
  6912  acfc a900               	LDA	#$00			; clear byte
  6913  acfe 85b8               	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
  6914  ad00 20b8a5             	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
  6915  ad03 a9f0               	LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6916  ad05 a0b1               	LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6917  ad07 20b5a5             	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6918  ad0a a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6919  ad0c 48                 	PHA				; save FAC1 sign
  6920  ad0d 100d               	BPL	LAB_2C35		; branch if +ve
  6921                          
  6922                          					; FAC1 sign was -ve
  6923  ad0f 20cca5             	JSR	LAB_244E		; add 0.5 to FAC1
  6924  ad12 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6925  ad14 3009               	BMI	LAB_2C38		; branch if -ve
  6926                          
  6927  ad16 a563               	LDA	Cflag			; get comparison evaluation flag
  6928  ad18 49ff               	EOR	#$FF			; toggle flag
  6929  ad1a 8563               	STA	Cflag			; save comparison evaluation flag
  6930                          LAB_2C35
  6931  ad1c 2006ac             	JSR	LAB_GTHAN		; do - FAC1
  6932                          LAB_2C38
  6933  ad1f a9f0               	LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6934  ad21 a0b1               	LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6935  ad23 20d0a5             	JSR	LAB_246C		; add (AY) to FAC1
  6936  ad26 68                 	PLA				; restore FAC1 sign
  6937  ad27 1003               	BPL	LAB_2C45		; branch if was +ve
  6938                          
  6939                          					; else correct FAC1
  6940  ad29 2006ac             	JSR	LAB_GTHAN		; do - FAC1
  6941                          LAB_2C45
  6942  ad2c a9ad               	LDA	#<LAB_2C84		; set pointer low byte to counter
  6943  ad2e a0b1               	LDY	#>LAB_2C84		; set pointer high byte to counter
  6944  ad30 4c63ac             	JMP	LAB_2B6E		; ^2 then series evaluation and return
  6945                          
  6946                          ; perform TAN()
  6947                          
  6948                          LAB_TAN
  6949  ad33 20afa8             	JSR	LAB_276E		; pack FAC1 into Adatal
  6950  ad36 a900               	LDA	#$00			; clear byte
  6951  ad38 8563               	STA	Cflag			; clear comparison evaluation flag
  6952  ad3a 20eaac             	JSR	LAB_SIN		; go do SIN(n)
  6953  ad3d a29c               	LDX	#<func_l		; set sin(n) pointer low byte
  6954  ad3f a000               	LDY	#>func_l		; set sin(n) pointer high byte
  6955  ad41 20b9a8             	JSR	LAB_2778		; pack FAC1 into (XY)
  6956  ad44 a9a4               	LDA	#<Adatal		; set n pointer low addr
  6957  ad46 a000               	LDY	#>Adatal		; set n pointer high addr
  6958  ad48 208fa8             	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  6959  ad4b a900               	LDA	#$00			; clear byte
  6960  ad4d 85b0               	STA	FAC1_s		; clear FAC1 sign (b7)
  6961  ad4f a563               	LDA	Cflag			; get comparison evaluation flag
  6962  ad51 205bad             	JSR	LAB_2C74		; save flag and go do series evaluation
  6963                          
  6964  ad54 a99c               	LDA	#<func_l		; set sin(n) pointer low byte
  6965  ad56 a000               	LDY	#>func_l		; set sin(n) pointer high byte
  6966  ad58 4c13a8             	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
  6967                          
  6968                          LAB_2C74
  6969  ad5b 48                 	PHA				; save comparison evaluation flag
  6970  ad5c 4c1cad             	JMP	LAB_2C35		; go do series evaluation
  6971                          
  6972                          ; perform USR()
  6973                          
  6974                          LAB_USR
  6975  ad5f 200a00             	JSR	Usrjmp		; call user code
  6976  ad62 4c019c             	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
  6977                          
  6978                          ; perform ATN()
  6979                          
  6980                          LAB_ATN
  6981  ad65 a5b0               	LDA	FAC1_s		; get FAC1 sign (b7)
  6982  ad67 48                 	PHA				; save sign
  6983  ad68 1003               	BPL	LAB_2CA1		; branch if +ve
  6984                          
  6985  ad6a 2006ac             	JSR	LAB_GTHAN		; else do - FAC1
  6986                          LAB_2CA1
  6987  ad6d a5ac               	LDA	FAC1_e		; get FAC1 exponent
  6988  ad6f 48                 	PHA				; push exponent
  6989  ad70 c981               	CMP	#$81			; compare with 1
  6990  ad72 9007               	BCC	LAB_2CAF		; branch if FAC1<1
  6991                          
  6992  ad74 a9e3               	LDA	#<LAB_259C		; set 1 pointer low byte
  6993  ad76 a0b1               	LDY	#>LAB_259C		; set 1 pointer high byte
  6994  ad78 2013a8             	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
  6995                          LAB_2CAF
  6996  ad7b a9c2               	LDA	#<LAB_2CC9		; set pointer low byte to counter
  6997  ad7d a0b1               	LDY	#>LAB_2CC9		; set pointer high byte to counter
  6998  ad7f 2063ac             	JSR	LAB_2B6E		; ^2 then series evaluation
  6999  ad82 68                 	PLA				; restore old FAC1 exponent
  7000  ad83 c981               	CMP	#$81			; compare with 1
  7001  ad85 9007               	BCC	LAB_2CC2		; branch if FAC1<1
  7002                          
  7003  ad87 a9a9               	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  7004  ad89 a0b1               	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  7005  ad8b 20b5a5             	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  7006                          LAB_2CC2
  7007  ad8e 68                 	PLA				; restore FAC1 sign
  7008  ad8f 1016               	BPL	LAB_2D04		; exit if was +ve
  7009                          
  7010  ad91 4c06ac             	JMP	LAB_GTHAN		; else do - FAC1 and return
  7011                          
  7012                          ; perform BITSET
  7013                          
  7014                          LAB_BITSET
  7015  ad94 20eaa4             	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  7016  ad97 e008               	CPX	#$08			; only 0 to 7 are allowed
  7017  ad99 b020               	BCS	FCError		; branch if > 7
  7018                          
  7019  ad9b a900               	LDA	#$00			; clear A
  7020  ad9d 38                 	SEC				; set the carry
  7021                          S_Bits
  7022  ad9e 2a                 	ROL				; shift bit
  7023  ad9f ca                 	DEX				; decrement bit number
  7024  ada0 10fc               	BPL	S_Bits		; loop if still +ve
  7025                          
  7026  ada2 e8                 	INX				; make X = $00
  7027  ada3 0111               	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
  7028  ada5 8111               	STA	(Itempl,X)		; save byte via temporary integer (addr)
  7029                          LAB_2D04
  7030  ada7 60                 	RTS
  7031                          
  7032                          ; perform BITCLR
  7033                          
  7034                          LAB_BITCLR
  7035  ada8 20eaa4             	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  7036  adab e008               	CPX	#$08			; only 0 to 7 are allowed
  7037  adad b00c               	BCS	FCError		; branch if > 7
  7038                          
  7039  adaf a9ff               	LDA	#$FF			; set A
  7040                          S_Bitc
  7041  adb1 2a                 	ROL				; shift bit
  7042  adb2 ca                 	DEX				; decrement bit number
  7043  adb3 10fc               	BPL	S_Bitc		; loop if still +ve
  7044                          
  7045  adb5 e8                 	INX				; make X = $00
  7046  adb6 2111               	AND	(Itempl,X)		; and with byte via temporary integer (addr)
  7047  adb8 8111               	STA	(Itempl,X)		; save byte via temporary integer (addr)
  7048  adba 60                 	RTS
  7049                          
  7050                          FCError
  7051  adbb 4c3b9f             	JMP	LAB_FCER		; do function call error then warm start
  7052                          
  7053                          ; perform BITTST()
  7054                          
  7055                          LAB_BTST
  7056  adbe 20bc00             	JSR	LAB_IGBY		; increment BASIC pointer
  7057  adc1 20eaa4             	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  7058  adc4 e008               	CPX	#$08			; only 0 to 7 are allowed
  7059  adc6 b0f3               	BCS	FCError		; branch if > 7
  7060                          
  7061  adc8 20c200             	JSR	LAB_GBYT		; get next BASIC byte
  7062  adcb c929               	CMP	#')'			; is next character ")"
  7063  adcd f003               	BEQ	TST_OK		; if ")" go do rest of function
  7064                          
  7065  adcf 4c149c             	JMP	LAB_SNER		; do syntax error then warm start
  7066                          
  7067                          TST_OK
  7068  add2 20bc00             	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
  7069  add5 a900               	LDA	#$00			; clear A
  7070  add7 38                 	SEC				; set the carry
  7071                          T_Bits
  7072  add8 2a                 	ROL				; shift bit
  7073  add9 ca                 	DEX				; decrement bit number
  7074  adda 10fc               	BPL	T_Bits		; loop if still +ve
  7075                          
  7076  addc e8                 	INX				; make X = $00
  7077  addd 2111               	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
  7078  addf f002               	BEQ	LAB_NOTT		; branch if zero (already correct)
  7079                          
  7080  ade1 a9ff               	LDA	#$FF			; set for -1 result
  7081                          LAB_NOTT
  7082  ade3 4c0ca9             	JMP	LAB_27DB		; go do SGN tail
  7083                          
  7084                          ; perform BIN$()
  7085                          
  7086                          LAB_BINS
  7087  ade6 e019               	CPX	#$19			; max + 1
  7088  ade8 b048               	BCS	BinFErr		; exit if too big ( > or = )
  7089                          
  7090  adea 8678               	STX	TempB			; save # of characters ($00 = leading zero remove)
  7091  adec a918               	LDA	#$18			; need A byte long space
  7092  adee 204ca1             	JSR	LAB_MSSP		; make string space A bytes long
  7093  adf1 a017               	LDY	#$17			; set index
  7094  adf3 a218               	LDX	#$18			; character count
  7095                          NextB1
  7096  adf5 4611               	LSR	nums_1		; shift highest byte
  7097  adf7 6612               	ROR	nums_2		; shift middle byte
  7098  adf9 6613               	ROR	nums_3		; shift lowest byte bit 0 to carry
  7099  adfb 8a                 	TXA				; load with "0"/2
  7100  adfc 2a                 	ROL				; shift in carry
  7101  adfd 91ad               	STA	(str_pl),Y		; save to temp string + index
  7102  adff 88                 	DEY				; decrement index
  7103  ae00 10f3               	BPL	NextB1		; loop if not done
  7104                          
  7105  ae02 a578               	LDA	TempB			; get # of characters
  7106  ae04 f00a               	BEQ	EndBHS		; branch if truncate
  7107                          
  7108  ae06 aa                 	TAX				; copy length to X
  7109  ae07 38                 	SEC				; set carry for add !
  7110  ae08 49ff               	EOR	#$FF			; 1's complement
  7111  ae0a 6918               	ADC	#$18			; add 24d
  7112  ae0c f01c               	BEQ	GoPr2			; if zero print whole string
  7113                          
  7114  ae0e d00f               	BNE	GoPr1			; else go make output string
  7115                          	
  7116                          ; this is the exit code and is also used by HEX$()
  7117                          ; truncate string to remove leading "0"s
  7118                          
  7119                          EndBHS
  7120  ae10 a8                 	TAY				; clear index (A=0, X=length here)
  7121                          NextB2
  7122  ae11 b1ad               	LDA	(str_pl),Y		; get character from string
  7123  ae13 c930               	CMP	#'0'			; compare with "0"
  7124  ae15 d007               	BNE	GoPr			; if not "0" then go print string from here
  7125                          
  7126  ae17 ca                 	DEX				; decrement character count
  7127  ae18 f003               	BEQ	GoPr3			; if zero then end of string so go print it
  7128                          
  7129  ae1a c8                 	INY				; else increment index
  7130  ae1b 10f4               	BPL	NextB2		; loop always
  7131                          
  7132                          ; make fixed length output string - ignore overflows!
  7133                          
  7134                          GoPr3
  7135  ae1d e8                 	INX				; need at least 1 character
  7136                          GoPr
  7137  ae1e 98                 	TYA				; copy result
  7138                          GoPr1
  7139  ae1f 18                 	CLC				; clear carry for add
  7140  ae20 65ad               	ADC	str_pl		; add low address
  7141  ae22 85ad               	STA	str_pl		; save low address
  7142  ae24 a900               	LDA	#$00			; do high byte
  7143  ae26 65ae               	ADC	str_ph		; add high address
  7144  ae28 85ae               	STA	str_ph		; save high address
  7145                          GoPr2
  7146  ae2a 86ac               	STX	str_ln		; X holds string length
  7147  ae2c 20bc00             	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
  7148  ae2f 4c97a1             	JMP	LAB_RTST		; check for space on descriptor stack then put address
  7149                          					; and length on descriptor stack and update stack pointers
  7150                          
  7151                          BinFErr
  7152  ae32 4c3b9f             	JMP	LAB_FCER		; do function call error then warm start
  7153                          
  7154                          ; perform HEX$()
  7155                          
  7156                          LAB_HEXS
  7157  ae35 e007               	CPX	#$07			; max + 1
  7158  ae37 b0f9               	BCS	BinFErr		; exit if too big ( > or = )
  7159                          
  7160  ae39 8678               	STX	TempB			; save # of characters
  7161                          
  7162  ae3b a906               	LDA	#$06			; need 6 bytes for string
  7163  ae3d 204ca1             	JSR	LAB_MSSP		; make string space A bytes long
  7164  ae40 a005               	LDY	#$05			; set string index
  7165                          
  7166  ae42 f8                 	SED				; need decimal mode for nibble convert
  7167  ae43 a513               	LDA	nums_3		; get lowest byte
  7168  ae45 2063ae             	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  7169  ae48 a512               	LDA	nums_2		; get middle byte
  7170  ae4a 2063ae             	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  7171  ae4d a511               	LDA	nums_1		; get highest byte
  7172  ae4f 2063ae             	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  7173  ae52 d8                 	CLD				; back to binary
  7174                          
  7175  ae53 a206               	LDX	#$06			; character count
  7176  ae55 a578               	LDA	TempB			; get # of characters
  7177  ae57 f0b7               	BEQ	EndBHS		; branch if truncate
  7178                          
  7179  ae59 aa                 	TAX				; copy length to X
  7180  ae5a 38                 	SEC				; set carry for add !
  7181  ae5b 49ff               	EOR	#$FF			; 1's complement
  7182  ae5d 6906               	ADC	#$06			; add 6d
  7183  ae5f f0c9               	BEQ	GoPr2			; if zero print whole string
  7184                          
  7185  ae61 d0bc               	BNE	GoPr1			; else go make output string (branch always)
  7186                          
  7187                          ; convert A to ASCII hex byte and output .. note set decimal mode before calling
  7188                          
  7189                          LAB_A2HX
  7190  ae63 aa                 	TAX				; save byte
  7191  ae64 290f               	AND	#$0F			; mask off top bits
  7192  ae66 206eae             	JSR	LAB_AL2X		; convert low nibble to ASCII and output
  7193  ae69 8a                 	TXA				; get byte back
  7194  ae6a 4a                 	LSR				; /2	shift high nibble to low nibble
  7195  ae6b 4a                 	LSR				; /4
  7196  ae6c 4a                 	LSR				; /8
  7197  ae6d 4a                 	LSR				; /16
  7198                          LAB_AL2X
  7199  ae6e c90a               	CMP	#$0A			; set carry for +1 if >9
  7200  ae70 6930               	ADC	#'0'			; add ASCII "0"
  7201  ae72 91ad               	STA	(str_pl),Y		; save to temp string
  7202  ae74 88                 	DEY				; decrement counter
  7203  ae75 60                 	RTS
  7204                          
  7205                          LAB_NLTO
  7206  ae76 85ac               	STA	FAC1_e		; save FAC1 exponent
  7207  ae78 a900               	LDA	#$00			; clear sign compare
  7208                          LAB_MLTE
  7209  ae7a 85b8               	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
  7210  ae7c 8a                 	TXA				; restore character
  7211  ae7d 2057aa             	JSR	LAB_2912		; evaluate new ASCII digit
  7212                          
  7213                          ; gets here if the first character was "$" for hex
  7214                          ; get hex number
  7215                          
  7216                          LAB_CHEX
  7217  ae80 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  7218  ae83 900a               	BCC	LAB_ISHN		; branch if numeric character
  7219                          
  7220  ae85 0920               	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
  7221  ae87 e961               	SBC	#'a'			; subtract "a" (carry set here)
  7222  ae89 c906               	CMP	#$06			; compare normalised with $06 (max+1)
  7223  ae8b b02a               	BCS	LAB_EXCH		; exit if >"f" or <"0"
  7224                          
  7225  ae8d 690a               	ADC	#$0A			; convert to nibble
  7226                          LAB_ISHN
  7227  ae8f 290f               	AND	#$0F			; convert to binary
  7228  ae91 aa                 	TAX				; save nibble
  7229  ae92 a5ac               	LDA	FAC1_e		; get FAC1 exponent
  7230  ae94 f0e4               	BEQ	LAB_MLTE		; skip multiply if zero
  7231                          
  7232  ae96 6904               	ADC	#$04			; add four to exponent (*16 - carry clear here)
  7233  ae98 90dc               	BCC	LAB_NLTO		; if no overflow do evaluate digit
  7234                          
  7235                          LAB_MLTO
  7236  ae9a 4cd5a6             	JMP	LAB_2564		; do overflow error and warm start
  7237                          
  7238                          LAB_NXCH
  7239  ae9d aa                 	TAX				; save bit
  7240  ae9e a5ac               	LDA	FAC1_e		; get FAC1 exponent
  7241  aea0 f006               	BEQ	LAB_MLBT		; skip multiply if zero
  7242                          
  7243  aea2 e6ac               	INC	FAC1_e		; increment FAC1 exponent (*2)
  7244  aea4 f0f4               	BEQ	LAB_MLTO		; do overflow error if = $00
  7245                          
  7246  aea6 a900               	LDA	#$00			; clear sign compare
  7247                          LAB_MLBT
  7248  aea8 85b8               	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
  7249  aeaa 8a                 	TXA				; restore bit
  7250  aeab 2057aa             	JSR	LAB_2912		; evaluate new ASCII digit
  7251                          
  7252                          ; gets here if the first character was  "%" for binary
  7253                          ; get binary number
  7254                          
  7255                          LAB_CBIN
  7256  aeae 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  7257  aeb1 4930               	EOR	#'0'			; convert "0" to 0 etc.
  7258  aeb3 c902               	CMP	#$02			; compare with max+1
  7259  aeb5 90e6               	BCC	LAB_NXCH		; branch exit if < 2
  7260                          
  7261                          LAB_EXCH
  7262  aeb7 4c3caa             	JMP	LAB_28F6		; evaluate -ve flag and return
  7263                          
  7264                          ; ctrl-c check routine. includes limited "life" byte save for INGET routine
  7265                          ; now also the code that checks to see if an interrupt has occurred
  7266                          
  7267                          CTRLC
  7268  aeba ad0003             	LDA	ccflag		; get [CTRL-C] check flag
  7269  aebd d018               	BNE	LAB_FBA2		; exit if inhibited
  7270                          
  7271  aebf 20fcb0             	JSR	V_INPT		; scan input device
  7272  aec2 900b               	BCC	LAB_FBA0		; exit if buffer empty
  7273                          
  7274  aec4 8d0103             	STA	ccbyte		; save received byte
  7275  aec7 a220               	LDX	#$20			; "life" timer for bytes
  7276  aec9 8e0203             	STX	ccnull		; set countdown
  7277  aecc 4c2e95             	JMP	LAB_1636		; return to BASIC
  7278                          
  7279                          LAB_FBA0
  7280  aecf ae0203             	LDX	ccnull		; get countdown byte
  7281  aed2 f003               	BEQ	LAB_FBA2		; exit if finished
  7282                          
  7283  aed4 ce0203             	DEC	ccnull		; else decrement countdown
  7284                          LAB_FBA2
  7285  aed7 a2dc               	LDX	#NmiBase		; set pointer to NMI values
  7286  aed9 20e2ae             	JSR	LAB_CKIN		; go check interrupt
  7287  aedc a2df               	LDX	#IrqBase		; set pointer to IRQ values
  7288  aede 20e2ae             	JSR	LAB_CKIN		; go check interrupt
  7289                          LAB_CRTS
  7290  aee1 60                 	RTS
  7291                          
  7292                          ; check whichever interrupt is indexed by X
  7293                          
  7294                          LAB_CKIN
  7295  aee2 b500               	LDA	PLUS_0,X		; get interrupt flag byte
  7296  aee4 10fb               	BPL	LAB_CRTS		; branch if interrupt not enabled
  7297                          
  7298                          ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
  7299                          ; automatically enable the interrupt when we exit
  7300                          
  7301  aee6 0a                 	ASL				; move happened bit to setup bit
  7302  aee7 2940               	AND	#$40			; mask happened bits
  7303  aee9 f0f6               	BEQ	LAB_CRTS		; if no interrupt then exit
  7304                          
  7305  aeeb 9500               	STA	PLUS_0,X		; save interrupt flag byte
  7306                          
  7307  aeed 8a                 	TXA				; copy index ..
  7308  aeee a8                 	TAY				; .. to Y
  7309                          
  7310  aeef 68                 	PLA				; dump return address low byte, call from CTRL-C
  7311  aef0 68                 	PLA				; dump return address high byte
  7312                          
  7313  aef1 a905               	LDA	#$05			; need 5 bytes for GOSUB
  7314  aef3 200e91             	JSR	LAB_1212		; check room on stack for A bytes
  7315  aef6 a5c4               	LDA	Bpntrh		; get BASIC execute pointer high byte
  7316  aef8 48                 	PHA				; push on stack
  7317  aef9 a5c3               	LDA	Bpntrl		; get BASIC execute pointer low byte
  7318  aefb 48                 	PHA				; push on stack
  7319  aefc a588               	LDA	Clineh		; get current line high byte
  7320  aefe 48                 	PHA				; push on stack
  7321  aeff a587               	LDA	Clinel		; get current line low byte
  7322  af01 48                 	PHA				; push on stack
  7323  af02 a98d               	LDA	#TK_GOSUB		; token for GOSUB
  7324  af04 48                 	PHA				; push on stack
  7325                          
  7326  af05 b90100             	LDA	PLUS_1,Y		; get interrupt code pointer low byte
  7327  af08 85c3               	STA	Bpntrl		; save as BASIC execute pointer low byte
  7328  af0a b90200             	LDA	PLUS_2,Y		; get interrupt code pointer high byte
  7329  af0d 85c4               	STA	Bpntrh		; save as BASIC execute pointer high byte
  7330                          
  7331  af0f 4cd394             	JMP	LAB_15C2		; go do interpreter inner loop
  7332                          					; can't RTS, we used the stack! the RTS from the ctrl-c
  7333                          					; check will be taken when the RETIRQ/RETNMI/RETURN is
  7334                          					; executed at the end of the subroutine
  7335                          
  7336                          ; get byte from input device, no waiting
  7337                          ; returns with carry set if byte in A
  7338                          
  7339                          INGET
  7340  af12 20fcb0             	JSR	V_INPT		; call scan input device
  7341  af15 b009               	BCS	LAB_FB95		; if byte go reset timer
  7342                          
  7343  af17 ad0203             	LDA	ccnull		; get countdown
  7344  af1a f009               	BEQ	LAB_FB96		; exit if empty
  7345                          
  7346  af1c ad0103             	LDA	ccbyte		; get last received byte
  7347  af1f 38                 	SEC				; flag we got a byte
  7348                          LAB_FB95
  7349  af20 a200               	LDX	#$00			; clear X
  7350  af22 8e0203             	STX	ccnull		; clear timer because we got a byte
  7351                          LAB_FB96
  7352  af25 60                 	RTS
  7353                          
  7354                          ; these routines only enable the interrupts if the set-up flag is set
  7355                          ; if not they have no effect
  7356                          
  7357                          ; perform IRQ {ON|OFF|CLEAR}
  7358                          
  7359                          LAB_IRQ
  7360  af26 a2df               	LDX	#IrqBase		; set pointer to IRQ values
  7361  af28 2c                 	!text	$2C			; make next line BIT abs.
  7362                          
  7363                          ; perform NMI {ON|OFF|CLEAR}
  7364                          
  7365                          LAB_NMI
  7366  af29 a2dc               	LDX	#NmiBase		; set pointer to NMI values
  7367  af2b c993               	CMP	#TK_ON		; compare with token for ON
  7368  af2d f011               	BEQ	LAB_INON		; go turn on interrupt
  7369                          
  7370  af2f c9b5               	CMP	#TK_OFF		; compare with token for OFF
  7371  af31 f007               	BEQ	LAB_IOFF		; go turn off interrupt
  7372                          
  7373  af33 49a2               	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
  7374  af35 f00e               	BEQ	LAB_INEX		; go clear interrupt flags and return
  7375                          
  7376  af37 4c149c             	JMP	LAB_SNER		; do syntax error then warm start
  7377                          
  7378                          LAB_IOFF
  7379  af3a a97f               	LDA	#$7F			; clear A
  7380  af3c 3500               	AND	PLUS_0,X		; AND with interrupt setup flag
  7381  af3e 1005               	BPL	LAB_INEX		; go clear interrupt enabled flag and return
  7382                          
  7383                          LAB_INON
  7384  af40 b500               	LDA	PLUS_0,X		; get interrupt setup flag
  7385  af42 0a                 	ASL				; Shift bit to enabled flag
  7386  af43 1500               	ORA	PLUS_0,X		; OR with flag byte
  7387                          LAB_INEX
  7388  af45 9500               	STA	PLUS_0,X		; save interrupt flag byte
  7389  af47 4cbc00             	JMP	LAB_IGBY		; update BASIC execute pointer and return
  7390                          
  7391                          ; these routines set up the pointers and flags for the interrupt routines
  7392                          ; note that the interrupts are also enabled by these commands
  7393                          
  7394                          ; perform ON IRQ
  7395                          
  7396                          LAB_SIRQ
  7397  af4a 58                 	CLI				; enable interrupts
  7398  af4b a2df               	LDX	#IrqBase		; set pointer to IRQ values
  7399  af4d 2c                 	!text	$2C			; make next line BIT abs.
  7400                          
  7401                          ; perform ON NMI
  7402                          
  7403                          LAB_SNMI
  7404  af4e a2dc               	LDX	#NmiBase		; set pointer to NMI values
  7405                          
  7406  af50 8678               	STX	TempB			; save interrupt pointer
  7407  af52 20bc00             	JSR	LAB_IGBY		; increment and scan memory (past token)
  7408  af55 206c97             	JSR	LAB_GFPN		; get fixed-point number into temp integer
  7409  af58 a579               	LDA	Smeml			; get start of mem low byte
  7410  af5a a67a               	LDX	Smemh			; get start of mem high byte
  7411  af5c 203f93             	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  7412  af5f b003               	BCS	LAB_LFND		; if carry set go set-up interrupt
  7413                          
  7414  af61 4c8996             	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
  7415                          
  7416                          LAB_LFND
  7417  af64 a678               	LDX	TempB			; get interrupt pointer
  7418  af66 a5aa               	LDA	Baslnl		; get pointer low byte
  7419  af68 e901               	SBC	#$01			; -1 (carry already set for subtract)
  7420  af6a 9501               	STA	PLUS_1,X		; save as interrupt pointer low byte
  7421  af6c a5ab               	LDA	Baslnh		; get pointer high byte
  7422  af6e e900               	SBC	#$00			; subtract carry
  7423  af70 9502               	STA	PLUS_2,X		; save as interrupt pointer high byte
  7424                          
  7425  af72 a9c0               	LDA	#$C0			; set interrupt enabled/setup bits
  7426  af74 9500               	STA	PLUS_0,X		; set interrupt flags
  7427                          LAB_IRTS
  7428  af76 60                 	RTS
  7429                          
  7430                          ; return from IRQ service, restores the enabled flag.
  7431                          
  7432                          ; perform RETIRQ
  7433                          
  7434                          LAB_RETIRQ
  7435  af77 d0fd               	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
  7436                          
  7437  af79 a5df               	LDA	IrqBase		; get interrupt flags
  7438  af7b 0a                 	ASL				; copy setup to enabled (b7)
  7439  af7c 05df               	ORA	IrqBase		; OR in setup flag
  7440  af7e 85df               	STA	IrqBase		; save enabled flag
  7441  af80 4c9096             	JMP	LAB_16E8		; go do rest of RETURN
  7442                          
  7443                          ; return from NMI service, restores the enabled flag.
  7444                          
  7445                          ; perform RETNMI
  7446                          
  7447                          LAB_RETNMI
  7448  af83 d0f1               	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
  7449                          
  7450  af85 a5dc               	LDA	NmiBase		; get set-up flag
  7451  af87 0a                 	ASL				; copy setup to enabled (b7)
  7452  af88 05dc               	ORA	NmiBase		; OR in setup flag
  7453  af8a 85dc               	STA	NmiBase		; save enabled flag
  7454  af8c 4c9096             	JMP	LAB_16E8		; go do rest of RETURN
  7455                          
  7456                          ; MAX() MIN() pre process
  7457                          
  7458                          LAB_MMPP
  7459  af8f 20fb9a             	JSR	LAB_EVEZ		; process expression
  7460  af92 4ce29a             	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
  7461                          
  7462                          ; perform MAX()
  7463                          
  7464                          LAB_MAX
  7465  af95 20c3af             	JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7466                          					; pull FAC2 and compare with FAC1
  7467  af98 10fb               	BPL	LAB_MAX		; branch if no swap to do
  7468                          
  7469  af9a a5b4               	LDA	FAC2_1		; get FAC2 mantissa1
  7470  af9c 0980               	ORA	#$80			; set top bit (clear sign from compare)
  7471  af9e 85b4               	STA	FAC2_1		; save FAC2 mantissa1
  7472  afa0 20d5a5             	JSR	LAB_279B		; copy FAC2 to FAC1
  7473  afa3 f0f0               	BEQ	LAB_MAX		; go do next (branch always)
  7474                          
  7475                          ; perform MIN()
  7476                          
  7477                          LAB_MIN
  7478  afa5 20c3af             	JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7479                          					; pull FAC2 and compare with FAC1
  7480  afa8 30fb               	BMI	LAB_MIN		; branch if no swap to do
  7481                          
  7482  afaa f0f9               	BEQ	LAB_MIN		; branch if no swap to do
  7483                          
  7484  afac a5b4               	LDA	FAC2_1		; get FAC2 mantissa1
  7485  afae 0980               	ORA	#$80			; set top bit (clear sign from compare)
  7486  afb0 85b4               	STA	FAC2_1		; save FAC2 mantissa1
  7487  afb2 20d5a5             	JSR	LAB_279B		; copy FAC2 to FAC1
  7488  afb5 f0ee               	BEQ	LAB_MIN		; go do next (branch always)
  7489                          
  7490                          ; exit routine. don't bother returning to the loop code
  7491                          ; check for correct exit, else so syntax error
  7492                          
  7493                          LAB_MMEC
  7494  afb7 c929               	CMP	#')'			; is it end of function?
  7495  afb9 d005               	BNE	LAB_MMSE		; if not do MAX MIN syntax error
  7496                          
  7497  afbb 68                 	PLA				; dump return address low byte
  7498  afbc 68                 	PLA				; dump return address high byte
  7499  afbd 4cbc00             	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
  7500                          
  7501                          LAB_MMSE
  7502  afc0 4c149c             	JMP	LAB_SNER		; do syntax error then warm start
  7503                          
  7504                          ; check for next, evaluate and return or exit
  7505                          ; this is the routine that does most of the work
  7506                          
  7507                          LAB_PHFA
  7508  afc3 20c200             	JSR	LAB_GBYT		; get next BASIC byte
  7509  afc6 c92c               	CMP	#','			; is there more ?
  7510  afc8 d0ed               	BNE	LAB_MMEC		; if not go do end check
  7511                          
  7512                          					; push FAC1
  7513  afca 20eba8             	JSR	LAB_27BA		; round FAC1
  7514  afcd a5b0               	LDA	FAC1_s		; get FAC1 sign
  7515  afcf 097f               	ORA	#$7F			; set all non sign bits
  7516  afd1 25ad               	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
  7517  afd3 48                 	PHA				; push on stack
  7518  afd4 a5ae               	LDA	FAC1_2		; get FAC1 mantissa2
  7519  afd6 48                 	PHA				; push on stack
  7520  afd7 a5af               	LDA	FAC1_3		; get FAC1 mantissa3
  7521  afd9 48                 	PHA				; push on stack
  7522  afda a5ac               	LDA	FAC1_e		; get FAC1 exponent
  7523  afdc 48                 	PHA				; push on stack
  7524                          
  7525  afdd 20bc00             	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
  7526  afe0 20df9a             	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7527                          					; else do type mismatch
  7528                          
  7529                          					; pop FAC2 (MAX/MIN expression so far)
  7530  afe3 68                 	PLA				; pop exponent
  7531  afe4 85b3               	STA	FAC2_e		; save FAC2 exponent
  7532  afe6 68                 	PLA				; pop mantissa3
  7533  afe7 85b6               	STA	FAC2_3		; save FAC2 mantissa3
  7534  afe9 68                 	PLA				; pop mantissa1
  7535  afea 85b5               	STA	FAC2_2		; save FAC2 mantissa2
  7536  afec 68                 	PLA				; pop sign/mantissa1
  7537  afed 85b4               	STA	FAC2_1		; save FAC2 sign/mantissa1
  7538  afef 85b7               	STA	FAC2_s		; save FAC2 sign
  7539                          
  7540                          					; compare FAC1 with (packed) FAC2
  7541  aff1 a9b3               	LDA	#<FAC2_e		; set pointer low byte to FAC2
  7542  aff3 a000               	LDY	#>FAC2_e		; set pointer high byte to FAC2
  7543  aff5 4c29a9             	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
  7544                          					; returns A=$00 if FAC1 = (AY)
  7545                          					; returns A=$01 if FAC1 > (AY)
  7546                          					; returns A=$FF if FAC1 < (AY)
  7547                          
  7548                          ; perform WIDTH
  7549                          
  7550                          LAB_WDTH
  7551  aff8 c92c               	CMP	#','			; is next byte ","
  7552  affa f01b               	BEQ	LAB_TBSZ		; if so do tab size
  7553                          
  7554  affc 209ea4             	JSR	LAB_GTBY		; get byte parameter
  7555  afff 8a                 	TXA				; copy width to A
  7556  b000 f00a               	BEQ	LAB_NSTT		; branch if set for infinite line
  7557                          
  7558  b002 e010               	CPX	#$10			; else make min width = 16d
  7559  b004 9045               	BCC	TabErr		; if less do function call error and exit
  7560                          
  7561                          ; this next compare ensures that we can't exit WIDTH via an error leaving the
  7562                          ; tab size greater than the line length.
  7563                          
  7564  b006 e464               	CPX	TabSiz		; compare with tab size
  7565  b008 b002               	BCS	LAB_NSTT		; branch if >= tab size
  7566                          
  7567  b00a 8664               	STX	TabSiz		; else make tab size = terminal width
  7568                          LAB_NSTT
  7569  b00c 860f               	STX	TWidth		; set the terminal width
  7570  b00e 20c200             	JSR	LAB_GBYT		; get BASIC byte back
  7571  b011 f01a               	BEQ	WExit			; exit if no following
  7572                          
  7573  b013 c92c               	CMP	#','			; else is it ","
  7574  b015 d0a9               	BNE	LAB_MMSE		; if not do syntax error
  7575                          
  7576                          LAB_TBSZ
  7577  b017 209ba4             	JSR	LAB_SGBY		; scan and get byte parameter
  7578  b01a 8a                 	TXA				; copy TAB size
  7579  b01b 302e               	BMI	TabErr		; if >127 do function call error and exit
  7580                          
  7581  b01d e001               	CPX	#$01			; compare with min-1
  7582  b01f 902a               	BCC	TabErr		; if <=1 do function call error and exit
  7583                          
  7584  b021 a50f               	LDA	TWidth		; set flags for width
  7585  b023 f006               	BEQ	LAB_SVTB		; skip check if infinite line
  7586                          
  7587  b025 e40f               	CPX	TWidth		; compare TAB with width
  7588  b027 f002               	BEQ	LAB_SVTB		; ok if =
  7589                          
  7590  b029 b020               	BCS	TabErr		; branch if too big
  7591                          
  7592                          LAB_SVTB
  7593  b02b 8664               	STX	TabSiz		; save TAB size
  7594                          
  7595                          ; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7596                          ; position on a line that still has at least one whole tab width between it
  7597                          ; and the end of the line.
  7598                          
  7599                          WExit
  7600  b02d a50f               	LDA	TWidth		; get width
  7601  b02f f006               	BEQ	LAB_SULP		; branch if infinite line
  7602                          
  7603  b031 c564               	CMP	TabSiz		; compare with tab size
  7604  b033 b003               	BCS	LAB_WDLP		; branch if >= tab size
  7605                          
  7606  b035 8564               	STA	TabSiz		; else make tab size = terminal width
  7607                          LAB_SULP
  7608  b037 38                 	SEC				; set carry for subtract
  7609                          LAB_WDLP
  7610  b038 e564               	SBC	TabSiz		; subtract tab size
  7611  b03a b0fc               	BCS	LAB_WDLP		; loop while no borrow
  7612                          
  7613  b03c 6564               	ADC	TabSiz		; add tab size back
  7614  b03e 18                 	CLC				; clear carry for add
  7615  b03f 6564               	ADC	TabSiz		; add tab size back again
  7616  b041 8510               	STA	Iclim			; save for now
  7617  b043 a50f               	LDA	TWidth		; get width back
  7618  b045 38                 	SEC				; set carry for subtract
  7619  b046 e510               	SBC	Iclim			; subtract remainder
  7620  b048 8510               	STA	Iclim			; save tab column limit
  7621                          LAB_NOSQ
  7622  b04a 60                 	RTS
  7623                          
  7624                          TabErr
  7625  b04b 4c3b9f             	JMP	LAB_FCER		; do function call error then warm start
  7626                          
  7627                          ; perform SQR()
  7628                          
  7629                          LAB_SQR
  7630  b04e a5b0               	LDA	FAC1_s		; get FAC1 sign
  7631  b050 30f9               	BMI	TabErr		; if -ve do function call error
  7632                          
  7633  b052 a5ac               	LDA	FAC1_e		; get exponent
  7634  b054 f0f4               	BEQ	LAB_NOSQ		; if zero just return
  7635                          
  7636                          					; else do root
  7637  b056 20dca8             	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  7638  b059 a900               	LDA	#$00			; clear A
  7639                          
  7640  b05b 8577               	STA	FACt_3		; clear remainder
  7641  b05d 8576               	STA	FACt_2		; ..
  7642  b05f 8575               	STA	FACt_1		; ..
  7643  b061 8578               	STA	TempB			; ..
  7644                          
  7645  b063 85af               	STA	FAC1_3		; clear root
  7646  b065 85ae               	STA	FAC1_2		; ..
  7647  b067 85ad               	STA	FAC1_1		; ..
  7648                          
  7649  b069 a218               	LDX	#$18			; 24 pairs of bits to do
  7650  b06b a5b3               	LDA	FAC2_e		; get exponent
  7651  b06d 4a                 	LSR				; check odd/even
  7652  b06e b00e               	BCS	LAB_SQE2		; if odd only 1 shift first time
  7653                          
  7654                          LAB_SQE1
  7655  b070 06b6               	ASL	FAC2_3		; shift highest bit of number ..
  7656  b072 26b5               	ROL	FAC2_2		; ..
  7657  b074 26b4               	ROL	FAC2_1		; ..
  7658  b076 2677               	ROL	FACt_3		; .. into remainder
  7659  b078 2676               	ROL	FACt_2		; ..
  7660  b07a 2675               	ROL	FACt_1		; ..
  7661  b07c 2678               	ROL	TempB			; .. never overflows
  7662                          LAB_SQE2
  7663  b07e 06b6               	ASL	FAC2_3		; shift highest bit of number ..
  7664  b080 26b5               	ROL	FAC2_2		; ..
  7665  b082 26b4               	ROL	FAC2_1		; ..
  7666  b084 2677               	ROL	FACt_3		; .. into remainder
  7667  b086 2676               	ROL	FACt_2		; ..
  7668  b088 2675               	ROL	FACt_1		; ..
  7669  b08a 2678               	ROL	TempB			; .. never overflows
  7670                          
  7671  b08c 06af               	ASL	FAC1_3		; root = root * 2
  7672  b08e 26ae               	ROL	FAC1_2		; ..
  7673  b090 26ad               	ROL	FAC1_1		; .. never overflows
  7674                          
  7675  b092 a5af               	LDA	FAC1_3		; get root low byte
  7676  b094 2a                 	ROL				; *2
  7677  b095 855b               	STA	Temp3			; save partial low byte
  7678  b097 a5ae               	LDA	FAC1_2		; get root low mid byte
  7679  b099 2a                 	ROL				; *2
  7680  b09a 855c               	STA	Temp3+1		; save partial low mid byte
  7681  b09c a5ad               	LDA	FAC1_1		; get root high mid byte
  7682  b09e 2a                 	ROL				; *2
  7683  b09f 855d               	STA	Temp3+2		; save partial high mid byte
  7684  b0a1 a900               	LDA	#$00			; get root high byte (always $00)
  7685  b0a3 2a                 	ROL				; *2
  7686  b0a4 855e               	STA	Temp3+3		; save partial high byte
  7687                          
  7688                          					; carry clear for subtract +1
  7689  b0a6 a577               	LDA	FACt_3		; get remainder low byte
  7690  b0a8 e55b               	SBC	Temp3			; subtract partial low byte
  7691  b0aa 855b               	STA	Temp3			; save partial low byte
  7692                          
  7693  b0ac a576               	LDA	FACt_2		; get remainder low mid byte
  7694  b0ae e55c               	SBC	Temp3+1		; subtract partial low mid byte
  7695  b0b0 855c               	STA	Temp3+1		; save partial low mid byte
  7696                          
  7697  b0b2 a575               	LDA	FACt_1		; get remainder high mid byte
  7698  b0b4 e55d               	SBC	Temp3+2		; subtract partial high mid byte
  7699  b0b6 a8                 	TAY				; copy partial high mid byte
  7700                          
  7701  b0b7 a578               	LDA	TempB			; get remainder high byte
  7702  b0b9 e55e               	SBC	Temp3+3		; subtract partial high byte
  7703  b0bb 900e               	BCC	LAB_SQNS		; skip sub if remainder smaller
  7704                          
  7705  b0bd 8578               	STA	TempB			; save remainder high byte
  7706                          
  7707  b0bf 8475               	STY	FACt_1		; save remainder high mid byte
  7708                          
  7709  b0c1 a55c               	LDA	Temp3+1		; get remainder low mid byte
  7710  b0c3 8576               	STA	FACt_2		; save remainder low mid byte
  7711                          
  7712  b0c5 a55b               	LDA	Temp3			; get partial low byte
  7713  b0c7 8577               	STA	FACt_3		; save remainder low byte
  7714                          
  7715  b0c9 e6af               	INC	FAC1_3		; increment root low byte (never any rollover)
  7716                          LAB_SQNS
  7717  b0cb ca                 	DEX				; decrement bit pair count
  7718  b0cc d0a2               	BNE	LAB_SQE1		; loop if not all done
  7719                          
  7720  b0ce 38                 	SEC				; set carry for subtract
  7721  b0cf a5b3               	LDA	FAC2_e		; get exponent
  7722  b0d1 e980               	SBC	#$80			; normalise
  7723  b0d3 6a                 	ROR				; /2 and re-bias to $80
  7724  b0d4 6900               	ADC	#$00			; add bit zero back in (allow for half shift)
  7725  b0d6 85ac               	STA	FAC1_e		; save it
  7726  b0d8 4c46a6             	JMP	LAB_24D5		; normalise FAC1 and return
  7727                          
  7728                          ; perform VARPTR()
  7729                          
  7730                          LAB_VARPTR
  7731  b0db 20bc00             	JSR	LAB_IGBY		; increment and scan memory
  7732  b0de 20bc9d             	JSR	LAB_GVAR		; get var address
  7733  b0e1 20019c             	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  7734  b0e4 a495               	LDY	Cvaral		; get var address low byte
  7735  b0e6 a596               	LDA	Cvarah		; get var address high byte
  7736  b0e8 4c6ba0             	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  7737                          
  7738                          ; perform PI
  7739                          
  7740                          LAB_PI
  7741  b0eb a9be               	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7742  b0ed a0b1               	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7743  b0ef 208fa8             	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  7744  b0f2 c6ac               	DEC	FAC1_e		; make result = PI
  7745  b0f4 60                 	RTS
  7746                          
  7747                          ; perform TWOPI
  7748                          
  7749                          LAB_TWOPI
  7750  b0f5 a9be               	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7751  b0f7 a0b1               	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7752  b0f9 4c8fa8             	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
  7753                          
  7754                          ; system dependant i/o vectors
  7755                          ; these are in RAM and are set by the monitor at start-up
  7756                          
  7757                          V_INPT
  7758  b0fc 6c0503             	JMP	(VEC_IN)		; non halting scan input device
  7759                          V_OUTP
  7760  b0ff 6c0703             	JMP	(VEC_OUT)		; send byte to output device
  7761                          V_LOAD
  7762  b102 6c0903             	JMP	(VEC_LD)		; load BASIC program
  7763                          V_SAVE
  7764  b105 6c0b03             	JMP	(VEC_SV)		; save BASIC program
  7765                          
  7766                          ; The rest are tables messages and code for RAM
  7767                          
  7768                          ; the rest of the code is tables and BASIC start-up code
  7769                          
  7770                          PG2_TABS
  7771  b108 00                 	!text	$00			; ctrl-c flag		-	$00 = enabled
  7772  b109 00                 	!text	$00			; ctrl-c byte		-	GET needs this
  7773  b10a 00                 	!text	$00			; ctrl-c byte timeout	-	GET needs this
  7774  b10b baae               	!word	CTRLC			; ctrl c check vector
  7775                          ;	!word	xxxx			; non halting key input	-	monitor to set this
  7776                          ;	!word	xxxx			; output vector		-	monitor to set this
  7777                          ;	!word	xxxx			; load vector		-	monitor to set this
  7778                          ;	!word	xxxx			; save vector		-	monitor to set this
  7779                          PG2_TABE
  7780                          
  7781                          ; character get subroutine for zero page
  7782                          
  7783                          ; For a 1.8432MHz 6502 including the JSR and RTS
  7784                          ; fastest (>=":")	=  29 cycles =  15.7uS
  7785                          ; slowest (<":")	=  40 cycles =  21.7uS
  7786                          ; space skip	= +21 cycles = +11.4uS
  7787                          ; inc across page	=  +4 cycles =  +2.2uS
  7788                          
  7789                          ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
  7790                          ; block is copied to it's destination, any non zero page address will do at assembly
  7791                          ; time, to assemble a three byte instruction.
  7792                          
  7793                          ; page 0 initialisation table from $BC
  7794                          ; increment and scan memory
  7795                          
  7796                          LAB_2CEE
  7797  b10d e6c3               	INC	Bpntrl		; increment BASIC execute pointer low byte
  7798  b10f d002               	BNE	LAB_2CF4		; branch if no carry
  7799                          					; else
  7800  b111 e6c4               	INC	Bpntrh		; increment BASIC execute pointer high byte
  7801                          
  7802                          ; page 0 initialisation table from $C2
  7803                          ; scan memory
  7804                          
  7805                          LAB_2CF4
  7806  b113 adffff             	LDA	$FFFF			; get byte to scan (addr set by call routine)
  7807  b116 c9ac               	CMP	#TK_ELSE		; compare with the token for ELSE
  7808  b118 f00e               	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
  7809                          
  7810  b11a c93a               	CMP	#':'			; compare with ":"
  7811  b11c b00a               	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
  7812                          
  7813  b11e c920               	CMP	#' '			; compare with " "
  7814  b120 f0eb               	BEQ	LAB_2CEE		; if " " go do next
  7815                          
  7816  b122 38                 	SEC				; set carry for SBC
  7817  b123 e930               	SBC	#'0'			; subtract "0"
  7818  b125 38                 	SEC				; set carry for SBC
  7819  b126 e9d0               	SBC	#$D0			; subtract -"0"
  7820                          					; clear carry if byte = "0"-"9"
  7821                          LAB_2D05
  7822  b128 60                 	RTS
  7823                          
  7824                          ; page zero initialisation table $00-$12 inclusive
  7825                          
  7826                          StrTab
  7827  b129 4c                 	!text	$4C			; JMP opcode
  7828  b12a 0390               	!word LAB_COLD		; initial warm start vector (cold start)
  7829                          
  7830  b12c 00                 	!text	$00			; these bytes are not used by BASIC
  7831  b12d 0000               	!word	$0000			; 
  7832  b12f 0000               	!word	$0000			; 
  7833  b131 0000               	!word	$0000			; 
  7834                          
  7835  b133 4c                 	!text	$4C			; JMP opcode
  7836  b134 3b9f               	!word	LAB_FCER		; initial user function vector ("Function call" error)
  7837  b136 00                 	!text	$00			; default NULL count
  7838  b137 00                 	!text	$00			; clear terminal position
  7839  b138 00                 	!text	$00			; default terminal width byte
  7840  b139 f2                 	!text	$F2			; default limit for TAB = 14
  7841  b13a 0004               	!word	Ram_base		; start of user RAM
  7842                          EndTab
  7843                          
  7844                          LAB_MSZM
  7845  b13c 0d0a4d656d6f7279...	!text	$0D,$0A,"Memory size ",$00
  7846                          
  7847                          LAB_SMSG
  7848  b14b 200a0a2a20484243...	!text	" ",$0A,$0A,"* HBC-56 BASIC *",$00
  7849                          
  7850                          ; numeric constants and series
  7851                          
  7852                          					; constants and series for LOG(n)
  7853                          LAB_25A0
  7854  b15f 02                 	!text	$02			; counter
  7855  b160 80195662           	!text	$80,$19,$56,$62	; 0.59898
  7856  b164 807622f3           	!text	$80,$76,$22,$F3	; 0.96147
  7857                          ;##	!text	$80,$76,$22,$F1	; 0.96147
  7858  b168 8238aa40           	!text	$82,$38,$AA,$40	; 2.88539
  7859                          ;##	!text	$82,$38,$AA,$45	; 2.88539
  7860                          
  7861                          LAB_25AD
  7862  b16c 803504f3           	!text	$80,$35,$04,$F3	; 0.70711	1/root 2
  7863                          LAB_25B1
  7864  b170 813504f3           	!text	$81,$35,$04,$F3	; 1.41421	root 2
  7865                          LAB_25B5
  7866  b174 80800000           	!text	$80,$80,$00,$00	; -0.5
  7867                          LAB_25B9
  7868  b178 80317218           	!text	$80,$31,$72,$18	; 0.69315	LOG(2)
  7869                          
  7870                          					; numeric PRINT constants
  7871                          LAB_2947
  7872  b17c 91434ff8           	!text	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
  7873                          LAB_294B
  7874  b180 947423f7           	!text	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
  7875                          LAB_294F
  7876  b184 94742400           	!text	$94,$74,$24,$00	; 1000000
  7877                          
  7878                          					; EXP(n) constants and series
  7879                          LAB_2AFA
  7880  b188 8138aa3b           	!text	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
  7881                          LAB_2AFE
  7882  b18c 06                 	!text	$06			; counter
  7883  b18d 7463908c           	!text	$74,$63,$90,$8C	; 2.17023e-4
  7884  b191 77230cab           	!text	$77,$23,$0C,$AB	; 0.00124
  7885  b195 7a1e9400           	!text	$7A,$1E,$94,$00	; 0.00968
  7886  b199 7c634280           	!text	$7C,$63,$42,$80	; 0.05548
  7887  b19d 7e75fed0           	!text	$7E,$75,$FE,$D0	; 0.24023
  7888  b1a1 80317215           	!text	$80,$31,$72,$15	; 0.69315
  7889  b1a5 81000000           	!text	$81,$00,$00,$00	; 1.00000
  7890                          
  7891                          ;##	!text	$07			; counter
  7892                          ;##	!text	$74,$94,$2E,$40	; -1/7! (-1/5040)
  7893                          ;##	!text	$77,$2E,$4F,$70	;  1/6! ( 1/720)
  7894                          ;##	!text	$7A,$88,$02,$6E	; -1/5! (-1/120)
  7895                          ;##	!text	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
  7896                          ;##	!text	$7E,$AA,$AA,$50	; -1/3! (-1/6)
  7897                          ;##	!text	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
  7898                          ;##	!text	$81,$80,$00,$00	; -1/1! (-1/1)
  7899                          ;##	!text	$81,$00,$00,$00	;  1/0! ( 1/1)
  7900                          
  7901                          					; trigonometric constants and series
  7902                          LAB_2C78
  7903  b1a9 81490fdb           	!text	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
  7904                          LAB_2C84
  7905  b1ad 04                 	!text	$04			; counter
  7906  b1ae 861ed7fb           	!text	$86,$1E,$D7,$FB	; 39.7109
  7907                          ;##	!text	$86,$1E,$D7,$BA	; 39.7109
  7908  b1b2 87992665           	!text	$87,$99,$26,$65	;-76.575
  7909                          ;##	!text	$87,$99,$26,$64	;-76.575
  7910  b1b6 87233458           	!text	$87,$23,$34,$58	; 81.6022
  7911  b1ba 86a55de1           	!text	$86,$A5,$5D,$E1	;-41.3417
  7912                          ;##	!text	$86,$A5,$5D,$E0	;-41.3417
  7913                          LAB_2C7C
  7914  b1be 83490fdb           	!text	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
  7915                          ;##	!text	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
  7916                          
  7917                          LAB_2CC9
  7918  b1c2 08                 	!text	$08			; counter
  7919  b1c3 783ac537           	!text	$78,$3A,$C5,$37	; 0.00285
  7920  b1c7 7b83a25c           	!text	$7B,$83,$A2,$5C	;-0.0160686
  7921  b1cb 7c2edd4d           	!text	$7C,$2E,$DD,$4D	; 0.0426915
  7922  b1cf 7d99b01e           	!text	$7D,$99,$B0,$1E	;-0.0750429
  7923  b1d3 7d59ed24           	!text	$7D,$59,$ED,$24	; 0.106409
  7924  b1d7 7e917200           	!text	$7E,$91,$72,$00	;-0.142036
  7925  b1db 7e4cb973           	!text	$7E,$4C,$B9,$73	; 0.199926
  7926  b1df 7faaaa53           	!text	$7F,$AA,$AA,$53	;-0.333331
  7927                          
  7928                          ;##	!text	$08			; counter
  7929                          ;##	!text	$78,$3B,$D7,$4A	; 1/17
  7930                          ;##	!text	$7B,$84,$6E,$02	;-1/15
  7931                          ;##	!text	$7C,$2F,$C1,$FE	; 1/13
  7932                          ;##	!text	$7D,$9A,$31,$74	;-1/11
  7933                          ;##	!text	$7D,$5A,$3D,$84	; 1/9
  7934                          ;##	!text	$7E,$91,$7F,$C8	;-1/7
  7935                          ;##	!text	$7E,$4C,$BB,$E4	; 1/5
  7936                          ;##	!text	$7F,$AA,$AA,$6C	;-1/3
  7937                          
  7938                          LAB_1D96	= *+1			; $00,$00 used for undefined variables
  7939                          LAB_259C
  7940  b1e3 81000000           	!text	$81,$00,$00,$00	; 1.000000, used for INC
  7941                          LAB_2AFD
  7942  b1e7 81800000           	!text	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
  7943                          
  7944                          					; misc constants
  7945                          LAB_1DF7
  7946  b1eb 90                 	!text	$90			;-32768 (uses first three bytes from 0.5)
  7947                          LAB_2A96
  7948  b1ec 80000000           	!text	$80,$00,$00,$00	; 0.5
  7949                          LAB_2C80
  7950  b1f0 7f000000           	!text	$7F,$00,$00,$00	; 0.25
  7951                          LAB_26B5
  7952  b1f4 84200000           	!text	$84,$20,$00,$00	; 10.0000 divide by 10 constant
  7953                          
  7954                          ; This table is used in converting numbers to ASCII.
  7955                          
  7956                          LAB_2A9A
  7957                          LAB_2A9B = LAB_2A9A+1
  7958                          LAB_2A9C = LAB_2A9B+1
  7959  b1f8 fe7960             	!text	$FE,$79,$60		; -100000
  7960  b1fb 002710             	!text	$00,$27,$10		; 10000
  7961  b1fe fffc18             	!text	$FF,$FC,$18		; -1000
  7962  b201 000064             	!text	$00,$00,$64		; 100
  7963  b204 fffff6             	!text	$FF,$FF,$F6		; -10
  7964  b207 000001             	!text	$00,$00,$01		; 1
  7965                          
  7966                          LAB_CTBL
  7967  b20a 3195               	!word	LAB_END-1		; END
  7968  b20c 6e94               	!word	LAB_FOR-1		; FOR
  7969  b20e 769a               	!word	LAB_NEXT-1		; NEXT
  7970  b210 a296               	!word	LAB_DATA-1		; DATA
  7971  b212 5899               	!word	LAB_INPUT-1		; INPUT
  7972  b214 709d               	!word	LAB_DIM-1		; DIM
  7973  b216 7899               	!word	LAB_READ-1		; READ
  7974  b218 ca97               	!word	LAB_LET-1		; LET
  7975  b21a 9c97               	!word	LAB_DEC-1		; DEC			new command
  7976  b21c 0196               	!word	LAB_GOTO-1		; GOTO
  7977  b21e c095               	!word	LAB_RUN-1		; RUN
  7978  b220 d096               	!word	LAB_IF-1		; IF
  7979  b222 5895               	!word	LAB_RESTORE-1	; RESTORE		modified command
  7980  b224 e495               	!word	LAB_GOSUB-1		; GOSUB
  7981  b226 76af               	!word	LAB_RETIRQ-1	; RETIRQ		new command
  7982  b228 82af               	!word	LAB_RETNMI-1	; RETNMI		new command
  7983  b22a 8d96               	!word	LAB_RETURN-1	; RETURN
  7984  b22c 3497               	!word	LAB_REM-1		; REM
  7985  b22e 2f95               	!word	LAB_STOP-1		; STOP
  7986  b230 3d97               	!word	LAB_ON-1		; ON			modified command
  7987  b232 9695               	!word	LAB_NULL-1		; NULL		modified command
  7988  b234 9f97               	!word	LAB_INC-1		; INC			new command
  7989  b236 9aa5               	!word	LAB_WAIT-1		; WAIT
  7990  b238 01b1               	!word	V_LOAD-1		; LOAD
  7991  b23a 04b1               	!word	V_SAVE-1		; SAVE
  7992  b23c 85a0               	!word	LAB_DEF-1		; DEF
  7993  b23e 1fa5               	!word	LAB_POKE-1		; POKE
  7994  b240 3ba5               	!word	LAB_DOKE-1		; DOKE		new command
  7995  b242 88a5               	!word	LAB_CALL-1		; CALL		new command
  7996  b244 ca95               	!word	LAB_DO-1		; DO			new command
  7997  b246 3396               	!word	LAB_LOOP-1		; LOOP		new command
  7998  b248 6b98               	!word	LAB_PRINT-1		; PRINT
  7999  b24a 9c95               	!word	LAB_CONT-1		; CONT
  8000  b24c b993               	!word	LAB_LIST-1		; LIST
  8001  b24e b693               	!word	LAB_CLEAR-1		; CLEAR
  8002  b250 6493               	!word	LAB_NEW-1		; NEW
  8003  b252 f7af               	!word	LAB_WDTH-1		; WIDTH		new command
  8004  b254 3a98               	!word	LAB_GET-1		; GET			new command
  8005  b256 60a5               	!word	LAB_SWAP-1		; SWAP		new command
  8006  b258 93ad               	!word	LAB_BITSET-1	; BITSET		new command
  8007  b25a a7ad               	!word	LAB_BITCLR-1	; BITCLR		new command
  8008  b25c 25af               	!word	LAB_IRQ-1		; IRQ			new command
  8009  b25e 28af               	!word	LAB_NMI-1		; NMI			new command
  8010                          
  8011                          ; function pre process routine table
  8012                          
  8013                          LAB_FTPL
  8014                          LAB_FTPM	= LAB_FTPL+$01
  8015  b260 769c               	!word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
  8016  b262 769c               	!word	LAB_PPFN-1		; INT(n)		"
  8017  b264 769c               	!word	LAB_PPFN-1		; ABS(n)		"
  8018  b266 fa9a               	!word	LAB_EVEZ-1		; USR(x)	process any expression
  8019  b268 fd9b               	!word	LAB_1BF7-1		; FRE(x)		"
  8020  b26a fd9b               	!word	LAB_1BF7-1		; POS(x)		"
  8021  b26c 769c               	!word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
  8022  b26e 769c               	!word	LAB_PPFN-1		; RND(n)		"
  8023  b270 769c               	!word	LAB_PPFN-1		; LOG(n)		"
  8024  b272 769c               	!word	LAB_PPFN-1		; EXP(n)		"
  8025  b274 769c               	!word	LAB_PPFN-1		; COS(n)		"
  8026  b276 769c               	!word	LAB_PPFN-1		; SIN(n)		"
  8027  b278 769c               	!word	LAB_PPFN-1		; TAN(n)		"
  8028  b27a 769c               	!word	LAB_PPFN-1		; ATN(n)		"
  8029  b27c 769c               	!word	LAB_PPFN-1		; PEEK(n)		"
  8030  b27e 769c               	!word	LAB_PPFN-1		; DEEK(n)		"
  8031  b280 0000               	!word	$0000			; SADD()	none
  8032  b282 709c               	!word	LAB_PPFS-1		; LEN($)	process string expression in ()
  8033  b284 769c               	!word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
  8034  b286 709c               	!word	LAB_PPFS-1		; VAL($)	process string expression in ()
  8035  b288 709c               	!word	LAB_PPFS-1		; ASC($)		"
  8036  b28a 709c               	!word	LAB_PPFS-1		; UCASE$($)		"
  8037  b28c 709c               	!word	LAB_PPFS-1		; LCASE$($)		"
  8038  b28e 769c               	!word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
  8039  b290 9d9c               	!word	LAB_BHSS-1		; HEX$(n)		"
  8040  b292 9d9c               	!word	LAB_BHSS-1		; BIN$(n)		"
  8041  b294 0000               	!word	$0000			; BITTST()	none
  8042  b296 8eaf               	!word	LAB_MMPP-1		; MAX()	process numeric expression
  8043  b298 8eaf               	!word	LAB_MMPP-1		; MIN()		"
  8044  b29a 7c9c               	!word	LAB_PPBI-1		; PI		advance pointer
  8045  b29c 7c9c               	!word	LAB_PPBI-1		; TWOPI		"
  8046  b29e 0000               	!word	$0000			; VARPTR()	none
  8047  b2a0 819c               	!word	LAB_LRMS-1		; LEFT$()	process string expression
  8048  b2a2 819c               	!word	LAB_LRMS-1		; RIGHT$()		"
  8049  b2a4 819c               	!word	LAB_LRMS-1		; MID$()		"
  8050                          
  8051                          ; action addresses for functions
  8052                          
  8053                          LAB_FTBL
  8054                          LAB_FTBM	= LAB_FTBL+$01
  8055  b2a6 08a9               	!word	LAB_SGN-1		; SGN()
  8056  b2a8 92a9               	!word	LAB_INT-1		; INT()
  8057  b2aa 25a9               	!word	LAB_ABS-1		; ABS()
  8058  b2ac 5ead               	!word	LAB_USR-1		; USR()
  8059  b2ae 56a0               	!word	LAB_FRE-1		; FRE()
  8060  b2b0 75a0               	!word	LAB_POS-1		; POS()
  8061  b2b2 4db0               	!word	LAB_SQR-1		; SQR()
  8062  b2b4 aeac               	!word	LAB_RND-1		; RND()		modified function
  8063  b2b6 0ca7               	!word	LAB_LOG-1		; LOG()
  8064  b2b8 10ac               	!word	LAB_EXP-1		; EXP()
  8065  b2ba e2ac               	!word	LAB_COS-1		; COS()
  8066  b2bc e9ac               	!word	LAB_SIN-1		; SIN()
  8067  b2be 32ad               	!word	LAB_TAN-1		; TAN()
  8068  b2c0 64ad               	!word	LAB_ATN-1		; ATN()
  8069  b2c2 14a5               	!word	LAB_PEEK-1		; PEEK()
  8070  b2c4 28a5               	!word	LAB_DEEK-1		; DEEK()		new function
  8071  b2c6 66a4               	!word	LAB_SADD-1		; SADD()		new function
  8072  b2c8 7fa4               	!word	LAB_LENS-1		; LEN()
  8073  b2ca 37a1               	!word	LAB_STRS-1		; STR$()
  8074  b2cc aca4               	!word	LAB_VAL-1		; VAL()
  8075  b2ce 8aa4               	!word	LAB_ASC-1		; ASC()
  8076  b2d0 44a4               	!word	LAB_UCASE-1		; UCASE$()		new function
  8077  b2d2 23a4               	!word	LAB_LCASE-1		; LCASE$()		new function
  8078  b2d4 95a3               	!word	LAB_CHRS-1		; CHR$()
  8079  b2d6 34ae               	!word	LAB_HEXS-1		; HEX$()		new function
  8080  b2d8 e5ad               	!word	LAB_BINS-1		; BIN$()		new function
  8081  b2da bdad               	!word	LAB_BTST-1		; BITTST()		new function
  8082  b2dc 94af               	!word	LAB_MAX-1		; MAX()		new function
  8083  b2de a4af               	!word	LAB_MIN-1		; MIN()		new function
  8084  b2e0 eab0               	!word	LAB_PI-1		; PI			new function
  8085  b2e2 f4b0               	!word	LAB_TWOPI-1		; TWOPI		new function
  8086  b2e4 dab0               	!word	LAB_VARPTR-1	; VARPTR()		new function
  8087  b2e6 a7a3               	!word	LAB_LEFT-1		; LEFT$()
  8088  b2e8 b0a3               	!word	LAB_RIGHT-1		; RIGHT$()
  8089  b2ea dfa3               	!word	LAB_MIDS-1		; MID$()
  8090                          
  8091                          ; hierarchy and action addresses for operator
  8092                          
  8093                          LAB_OPPT
  8094  b2ec 79                 	!text	$79			; +
  8095  b2ed d2a5               	!word	LAB_ADD-1
  8096  b2ef 79                 	!text	$79			; -
  8097  b2f0 b7a5               	!word	LAB_SUBTRACT-1
  8098  b2f2 7b                 	!text	$7B			; *
  8099  b2f3 4da7               	!word	LAB_MULTIPLY-1
  8100  b2f5 7b                 	!text	$7B			; /
  8101  b2f6 15a8               	!word	LAB_DIVIDE-1
  8102  b2f8 7f                 	!text	$7F			; ^
  8103  b2f9 ccab               	!word	LAB_POWER-1
  8104  b2fb 50                 	!text	$50			; AND
  8105  b2fc e69c               	!word	LAB_AND-1
  8106  b2fe 46                 	!text	$46			; EOR			new operator
  8107  b2ff cc9c               	!word	LAB_EOR-1
  8108  b301 46                 	!text	$46			; OR
  8109  b302 d99c               	!word	LAB_OR-1
  8110  b304 56                 	!text	$56			; >>			new operator
  8111  b305 929d               	!word	LAB_RSHIFT-1
  8112  b307 56                 	!text	$56			; <<			new operator
  8113  b308 7a9d               	!word	LAB_LSHIFT-1
  8114  b30a 7d                 	!text	$7D			; >
  8115  b30b 05ac               	!word	LAB_GTHAN-1
  8116  b30d 5a                 	!text	$5A			; =
  8117  b30e 289c               	!word	LAB_EQUAL-1
  8118  b310 64                 	!text	$64			; <
  8119  b311 079d               	!word	LAB_LTHAN-1
  8120                          
  8121                          ; keywords start with ..
  8122                          ; this is the first character table and must be in alphabetic order
  8123                          
  8124                          TAB_1STC
  8125  b313 2a                 	!text	"*"
  8126  b314 2b                 	!text	"+"
  8127  b315 2d                 	!text	"-"
  8128  b316 2f                 	!text	"/"
  8129  b317 3c                 	!text	"<"
  8130  b318 3d                 	!text	"="
  8131  b319 3e                 	!text	">"
  8132  b31a 3f                 	!text	"?"
  8133  b31b 41                 	!text	"A"
  8134  b31c 42                 	!text	"B"
  8135  b31d 43                 	!text	"C"
  8136  b31e 44                 	!text	"D"
  8137  b31f 45                 	!text	"E"
  8138  b320 46                 	!text	"F"
  8139  b321 47                 	!text	"G"
  8140  b322 48                 	!text	"H"
  8141  b323 49                 	!text	"I"
  8142  b324 4c                 	!text	"L"
  8143  b325 4d                 	!text	"M"
  8144  b326 4e                 	!text	"N"
  8145  b327 4f                 	!text	"O"
  8146  b328 50                 	!text	"P"
  8147  b329 52                 	!text	"R"
  8148  b32a 53                 	!text	"S"
  8149  b32b 54                 	!text	"T"
  8150  b32c 55                 	!text	"U"
  8151  b32d 56                 	!text	"V"
  8152  b32e 57                 	!text	"W"
  8153  b32f 5e                 	!text	"^"
  8154  b330 00                 	!text	$00			; table terminator
  8155                          
  8156                          ; pointers to keyword tables
  8157                          
  8158                          TAB_CHRT
  8159  b331 6bb3               	!word	TAB_STAR		; table for "*"
  8160  b333 6db3               	!word	TAB_PLUS		; table for "+"
  8161  b335 6fb3               	!word	TAB_MNUS		; table for "-"
  8162  b337 71b3               	!word	TAB_SLAS		; table for "/"
  8163  b339 73b3               	!word	TAB_LESS		; table for "<"
  8164  b33b 77b3               	!word	TAB_EQUL		; table for "="
  8165  b33d 79b3               	!word	TAB_MORE		; table for ">"
  8166  b33f 7db3               	!word	TAB_QEST		; table for "?"
  8167  b341 7fb3               	!word	TAB_ASCA		; table for "A"
  8168  b343 8fb3               	!word	TAB_ASCB		; table for "B"
  8169  b345 a8b3               	!word	TAB_ASCC		; table for "C"
  8170  b347 bfb3               	!word	TAB_ASCD		; table for "D"
  8171  b349 d8b3               	!word	TAB_ASCE		; table for "E"
  8172  b34b e7b3               	!word	TAB_ASCF		; table for "F"
  8173  b34d f1b3               	!word	TAB_ASCG		; table for "G"
  8174  b34f feb3               	!word	TAB_ASCH		; table for "H"
  8175  b351 04b4               	!word	TAB_ASCI		; table for "I"
  8176  b353 16b4               	!word	TAB_ASCL		; table for "L"
  8177  b355 3bb4               	!word	TAB_ASCM		; table for "M"
  8178  b357 49b4               	!word	TAB_ASCN		; table for "N"
  8179  b359 5bb4               	!word	TAB_ASCO		; table for "O"
  8180  b35b 63b4               	!word	TAB_ASCP		; table for "P"
  8181  b35d 78b4               	!word	TAB_ASCR		; table for "R"
  8182  b35f a7b4               	!word	TAB_ASCS		; table for "S"
  8183  b361 d2b4               	!word	TAB_ASCT		; table for "T"
  8184  b363 e6b4               	!word	TAB_ASCU		; table for "U"
  8185  b365 f7b4               	!word	TAB_ASCV		; table for "V"
  8186  b367 03b5               	!word	TAB_ASCW		; table for "W"
  8187  b369 12b5               	!word	TAB_POWR		; table for "^"
  8188                          
  8189                          ; tables for each start character, note if a longer keyword with the same start
  8190                          ; letters as a shorter one exists then it must come first, else the list is in
  8191                          ; alphabetical order as follows ..
  8192                          
  8193                          ; [keyword,token
  8194                          ; [keyword,token]]
  8195                          ; end marker (#$00)
  8196                          
  8197                          TAB_STAR
  8198  b36b b800               	!text TK_MUL,$00		; *
  8199                          TAB_PLUS
  8200  b36d b600               	!text TK_PLUS,$00		; +
  8201                          TAB_MNUS
  8202  b36f b700               	!text TK_MINUS,$00	; -
  8203                          TAB_SLAS
  8204  b371 b900               	!text TK_DIV,$00		; /
  8205                          TAB_LESS
  8206                          LBB_LSHIFT
  8207  b373 3cbf               	!text	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
  8208  b375 c2                 	!text TK_LT			; <
  8209  b376 00                 	!text	$00
  8210                          TAB_EQUL
  8211  b377 c100               	!text TK_EQUAL,$00	; =
  8212                          TAB_MORE
  8213                          LBB_RSHIFT
  8214  b379 3ebe               	!text	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
  8215  b37b c0                 	!text TK_GT			; >
  8216  b37c 00                 	!text	$00
  8217                          TAB_QEST
  8218  b37d 9f00               	!text TK_PRINT,$00	; ?
  8219                          TAB_ASCA
  8220                          LBB_ABS
  8221  b37f 425328c5           	!text	"BS(",TK_ABS	; ABS(
  8222                          LBB_AND
  8223  b383 4e44bb             	!text	"ND",TK_AND		; AND
  8224                          LBB_ASC
  8225  b386 534328d7           	!text	"SC(",TK_ASC	; ASC(
  8226                          LBB_ATN
  8227  b38a 544e28d0           	!text	"TN(",TK_ATN	; ATN(
  8228  b38e 00                 	!text	$00
  8229                          TAB_ASCB
  8230                          LBB_BINS
  8231  b38f 494e2428dc         	!text	"IN$(",TK_BINS	; BIN$(
  8232                          LBB_BITCLR
  8233  b394 4954434c52a8       	!text	"ITCLR",TK_BITCLR	; BITCLR
  8234                          LBB_BITSET
  8235  b39a 4954534554a7       	!text	"ITSET",TK_BITSET	; BITSET
  8236                          LBB_BITTST
  8237  b3a0 495454535428dd     	!text	"ITTST(",TK_BITTST
  8238                          					; BITTST(
  8239  b3a7 00                 	!text	$00
  8240                          TAB_ASCC
  8241                          LBB_CALL
  8242  b3a8 414c4c9c           	!text	"ALL",TK_CALL	; CALL
  8243                          LBB_CHRS
  8244  b3ac 48522428da         	!text	"HR$(",TK_CHRS	; CHR$(
  8245                          LBB_CLEAR
  8246  b3b1 4c454152a2         	!text	"LEAR",TK_CLEAR	; CLEAR
  8247                          LBB_CONT
  8248  b3b6 4f4e54a0           	!text	"ONT",TK_CONT	; CONT
  8249                          LBB_COS
  8250  b3ba 4f5328cd           	!text	"OS(",TK_COS	; COS(
  8251  b3be 00                 	!text	$00
  8252                          TAB_ASCD
  8253                          LBB_DATA
  8254  b3bf 41544183           	!text	"ATA",TK_DATA	; DATA
  8255                          LBB_DEC
  8256  b3c3 454388             	!text	"EC",TK_DEC		; DEC
  8257                          LBB_DEEK
  8258  b3c6 45454b28d2         	!text	"EEK(",TK_DEEK	; DEEK(
  8259                          LBB_DEF
  8260  b3cb 454699             	!text	"EF",TK_DEF		; DEF
  8261                          LBB_DIM
  8262  b3ce 494d85             	!text	"IM",TK_DIM		; DIM
  8263                          LBB_DOKE
  8264  b3d1 4f4b459b           	!text	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
  8265                          LBB_DO
  8266  b3d5 4f9d               	!text	"O",TK_DO		; DO
  8267  b3d7 00                 	!text	$00
  8268                          TAB_ASCE
  8269                          LBB_ELSE
  8270  b3d8 4c5345ac           	!text	"LSE",TK_ELSE	; ELSE
  8271                          LBB_END
  8272  b3dc 4e4480             	!text	"ND",TK_END		; END
  8273                          LBB_EOR
  8274  b3df 4f52bc             	!text	"OR",TK_EOR		; EOR
  8275                          LBB_EXP
  8276  b3e2 585028cc           	!text	"XP(",TK_EXP	; EXP(
  8277  b3e6 00                 	!text	$00
  8278                          TAB_ASCF
  8279                          LBB_FN
  8280  b3e7 4eae               	!text	"N",TK_FN		; FN
  8281                          LBB_FOR
  8282  b3e9 4f5281             	!text	"OR",TK_FOR		; FOR
  8283                          LBB_FRE
  8284  b3ec 524528c7           	!text	"RE(",TK_FRE	; FRE(
  8285  b3f0 00                 	!text	$00
  8286                          TAB_ASCG
  8287                          LBB_GET
  8288  b3f1 4554a5             	!text	"ET",TK_GET		; GET
  8289                          LBB_GOSUB
  8290  b3f4 4f5355428d         	!text	"OSUB",TK_GOSUB	; GOSUB
  8291                          LBB_GOTO
  8292  b3f9 4f544f89           	!text	"OTO",TK_GOTO	; GOTO
  8293  b3fd 00                 	!text	$00
  8294                          TAB_ASCH
  8295                          LBB_HEXS
  8296  b3fe 45582428db         	!text	"EX$(",TK_HEXS	; HEX$(
  8297  b403 00                 	!text	$00
  8298                          TAB_ASCI
  8299                          LBB_IF
  8300  b404 468b               	!text	"F",TK_IF		; IF
  8301                          LBB_INC
  8302  b406 4e4395             	!text	"NC",TK_INC		; INC
  8303                          LBB_INPUT
  8304  b409 4e50555484         	!text	"NPUT",TK_INPUT	; INPUT
  8305                          LBB_INT
  8306  b40e 4e5428c4           	!text	"NT(",TK_INT	; INT(
  8307                          LBB_IRQ
  8308  b412 5251a9             	!text	"RQ",TK_IRQ		; IRQ
  8309  b415 00                 	!text	$00
  8310                          TAB_ASCL
  8311                          LBB_LCASES
  8312  b416 434153452428d9     	!text	"CASE$(",TK_LCASES
  8313                          					; LCASE$(
  8314                          LBB_LEFTS
  8315  b41d 4546542428e3       	!text	"EFT$(",TK_LEFTS	; LEFT$(
  8316                          LBB_LEN
  8317  b423 454e28d4           	!text	"EN(",TK_LEN	; LEN(
  8318                          LBB_LET
  8319  b427 455487             	!text	"ET",TK_LET		; LET
  8320                          LBB_LIST
  8321  b42a 495354a1           	!text	"IST",TK_LIST	; LIST
  8322                          LBB_LOAD
  8323  b42e 4f414497           	!text	"OAD",TK_LOAD	; LOAD
  8324                          LBB_LOG
  8325  b432 4f4728cb           	!text	"OG(",TK_LOG	; LOG(
  8326                          LBB_LOOP
  8327  b436 4f4f509e           	!text	"OOP",TK_LOOP	; LOOP
  8328  b43a 00                 	!text	$00
  8329                          TAB_ASCM
  8330                          LBB_MAX
  8331  b43b 415828de           	!text	"AX(",TK_MAX	; MAX(
  8332                          LBB_MIDS
  8333  b43f 49442428e5         	!text	"ID$(",TK_MIDS	; MID$(
  8334                          LBB_MIN
  8335  b444 494e28df           	!text	"IN(",TK_MIN	; MIN(
  8336  b448 00                 	!text	$00
  8337                          TAB_ASCN
  8338                          LBB_NEW
  8339  b449 4557a3             	!text	"EW",TK_NEW		; NEW
  8340                          LBB_NEXT
  8341  b44c 45585482           	!text	"EXT",TK_NEXT	; NEXT
  8342                          LBB_NMI
  8343  b450 4d49aa             	!text	"MI",TK_NMI		; NMI
  8344                          LBB_NOT
  8345  b453 4f54b1             	!text	"OT",TK_NOT		; NOT
  8346                          LBB_NULL
  8347  b456 554c4c94           	!text	"ULL",TK_NULL	; NULL
  8348  b45a 00                 	!text	$00
  8349                          TAB_ASCO
  8350                          LBB_OFF
  8351  b45b 4646b5             	!text	"FF",TK_OFF		; OFF
  8352                          LBB_ON
  8353  b45e 4e93               	!text	"N",TK_ON		; ON
  8354                          LBB_OR
  8355  b460 52bd               	!text	"R",TK_OR		; OR
  8356  b462 00                 	!text	$00
  8357                          TAB_ASCP
  8358                          LBB_PEEK
  8359  b463 45454b28d1         	!text	"EEK(",TK_PEEK	; PEEK(
  8360                          LBB_PI
  8361  b468 49e0               	!text	"I",TK_PI		; PI
  8362                          LBB_POKE
  8363  b46a 4f4b459a           	!text	"OKE",TK_POKE	; POKE
  8364                          LBB_POS
  8365  b46e 4f5328c8           	!text	"OS(",TK_POS	; POS(
  8366                          LBB_PRINT
  8367  b472 52494e549f         	!text	"RINT",TK_PRINT	; PRINT
  8368  b477 00                 	!text	$00
  8369                          TAB_ASCR
  8370                          LBB_READ
  8371  b478 45414486           	!text	"EAD",TK_READ	; READ
  8372                          LBB_REM
  8373  b47c 454d91             	!text	"EM",TK_REM		; REM
  8374                          LBB_RESTORE
  8375  b47f 4553544f52458c     	!text	"ESTORE",TK_RESTORE
  8376                          					; RESTORE
  8377                          LBB_RETIRQ
  8378  b486 45544952518e       	!text	"ETIRQ",TK_RETIRQ	; RETIRQ
  8379                          LBB_RETNMI
  8380  b48c 45544e4d498f       	!text	"ETNMI",TK_RETNMI	; RETNMI
  8381                          LBB_RETURN
  8382  b492 455455524e90       	!text	"ETURN",TK_RETURN	; RETURN
  8383                          LBB_RIGHTS
  8384  b498 494748542428e4     	!text	"IGHT$(",TK_RIGHTS
  8385                          					; RIGHT$(
  8386                          LBB_RND
  8387  b49f 4e4428ca           	!text	"ND(",TK_RND	; RND(
  8388                          LBB_RUN
  8389  b4a3 554e8a             	!text	"UN",TK_RUN		; RUN
  8390  b4a6 00                 	!text	$00
  8391                          TAB_ASCS
  8392                          LBB_SADD
  8393  b4a7 41444428d3         	!text	"ADD(",TK_SADD	; SADD(
  8394                          LBB_SAVE
  8395  b4ac 41564598           	!text	"AVE",TK_SAVE	; SAVE
  8396                          LBB_SGN
  8397  b4b0 474e28c3           	!text	"GN(",TK_SGN	; SGN(
  8398                          LBB_SIN
  8399  b4b4 494e28ce           	!text	"IN(",TK_SIN	; SIN(
  8400                          LBB_SPC
  8401  b4b8 504328af           	!text	"PC(",TK_SPC	; SPC(
  8402                          LBB_SQR
  8403  b4bc 515228c9           	!text	"QR(",TK_SQR	; SQR(
  8404                          LBB_STEP
  8405  b4c0 544550b2           	!text	"TEP",TK_STEP	; STEP
  8406                          LBB_STOP
  8407  b4c4 544f5092           	!text	"TOP",TK_STOP	; STOP
  8408                          LBB_STRS
  8409  b4c8 54522428d5         	!text	"TR$(",TK_STRS	; STR$(
  8410                          LBB_SWAP
  8411  b4cd 574150a6           	!text	"WAP",TK_SWAP	; SWAP
  8412  b4d1 00                 	!text	$00
  8413                          TAB_ASCT
  8414                          LBB_TAB
  8415  b4d2 414228ab           	!text	"AB(",TK_TAB	; TAB(
  8416                          LBB_TAN
  8417  b4d6 414e28cf           	!text	"AN(",TK_TAN	; TAN(
  8418                          LBB_THEN
  8419  b4da 48454eb0           	!text	"HEN",TK_THEN	; THEN
  8420                          LBB_TO
  8421  b4de 4fad               	!text	"O",TK_TO		; TO
  8422                          LBB_TWOPI
  8423  b4e0 574f5049e1         	!text	"WOPI",TK_TWOPI	; TWOPI
  8424  b4e5 00                 	!text	$00
  8425                          TAB_ASCU
  8426                          LBB_UCASES
  8427  b4e6 434153452428d8     	!text	"CASE$(",TK_UCASES
  8428                          					; UCASE$(
  8429                          LBB_UNTIL
  8430  b4ed 4e54494cb3         	!text	"NTIL",TK_UNTIL	; UNTIL
  8431                          LBB_USR
  8432  b4f2 535228c6           	!text	"SR(",TK_USR	; USR(
  8433  b4f6 00                 	!text	$00
  8434                          TAB_ASCV
  8435                          LBB_VAL
  8436  b4f7 414c28d6           	!text	"AL(",TK_VAL	; VAL(
  8437                          LBB_VPTR
  8438  b4fb 415250545228e2     	!text	"ARPTR(",TK_VPTR	; VARPTR(
  8439  b502 00                 	!text	$00
  8440                          TAB_ASCW
  8441                          LBB_WAIT
  8442  b503 41495496           	!text	"AIT",TK_WAIT	; WAIT
  8443                          LBB_WHILE
  8444  b507 48494c45b4         	!text	"HILE",TK_WHILE	; WHILE
  8445                          LBB_WIDTH
  8446  b50c 49445448a4         	!text	"IDTH",TK_WIDTH	; WIDTH
  8447  b511 00                 	!text	$00
  8448                          TAB_POWR
  8449  b512 ba00               	!text	TK_POWER,$00	; ^
  8450                          
  8451                          ; new decode table for LIST
  8452                          ; Table is ..
  8453                          ; byte - keyword length, keyword first character
  8454                          ; word - pointer to rest of keyword from dictionary
  8455                          
  8456                          ; note if length is 1 then the pointer is ignored
  8457                          
  8458                          LAB_KEYT
  8459  b514 0345               	!text	3,'E'
  8460  b516 dcb3               	!word	LBB_END		; END
  8461  b518 0346               	!text	3,'F'
  8462  b51a e9b3               	!word	LBB_FOR		; FOR
  8463  b51c 044e               	!text	4,'N'
  8464  b51e 4cb4               	!word	LBB_NEXT		; NEXT
  8465  b520 0444               	!text	4,'D'
  8466  b522 bfb3               	!word	LBB_DATA		; DATA
  8467  b524 0549               	!text	5,'I'
  8468  b526 09b4               	!word	LBB_INPUT		; INPUT
  8469  b528 0344               	!text	3,'D'
  8470  b52a ceb3               	!word	LBB_DIM		; DIM
  8471  b52c 0452               	!text	4,'R'
  8472  b52e 78b4               	!word	LBB_READ		; READ
  8473  b530 034c               	!text	3,'L'
  8474  b532 27b4               	!word	LBB_LET		; LET
  8475  b534 0344               	!text	3,'D'
  8476  b536 c3b3               	!word	LBB_DEC		; DEC
  8477  b538 0447               	!text	4,'G'
  8478  b53a f9b3               	!word	LBB_GOTO		; GOTO
  8479  b53c 0352               	!text	3,'R'
  8480  b53e a3b4               	!word	LBB_RUN		; RUN
  8481  b540 0249               	!text	2,'I'
  8482  b542 04b4               	!word	LBB_IF		; IF
  8483  b544 0752               	!text	7,'R'
  8484  b546 7fb4               	!word	LBB_RESTORE		; RESTORE
  8485  b548 0547               	!text	5,'G'
  8486  b54a f4b3               	!word	LBB_GOSUB		; GOSUB
  8487  b54c 0652               	!text	6,'R'
  8488  b54e 86b4               	!word	LBB_RETIRQ		; RETIRQ
  8489  b550 0652               	!text	6,'R'
  8490  b552 8cb4               	!word	LBB_RETNMI		; RETNMI
  8491  b554 0652               	!text	6,'R'
  8492  b556 92b4               	!word	LBB_RETURN		; RETURN
  8493  b558 0352               	!text	3,'R'
  8494  b55a 7cb4               	!word	LBB_REM		; REM
  8495  b55c 0453               	!text	4,'S'
  8496  b55e c4b4               	!word	LBB_STOP		; STOP
  8497  b560 024f               	!text	2,'O'
  8498  b562 5eb4               	!word	LBB_ON		; ON
  8499  b564 044e               	!text	4,'N'
  8500  b566 56b4               	!word	LBB_NULL		; NULL
  8501  b568 0349               	!text	3,'I'
  8502  b56a 06b4               	!word	LBB_INC		; INC
  8503  b56c 0457               	!text	4,'W'
  8504  b56e 03b5               	!word	LBB_WAIT		; WAIT
  8505  b570 044c               	!text	4,'L'
  8506  b572 2eb4               	!word	LBB_LOAD		; LOAD
  8507  b574 0453               	!text	4,'S'
  8508  b576 acb4               	!word	LBB_SAVE		; SAVE
  8509  b578 0344               	!text	3,'D'
  8510  b57a cbb3               	!word	LBB_DEF		; DEF
  8511  b57c 0450               	!text	4,'P'
  8512  b57e 6ab4               	!word	LBB_POKE		; POKE
  8513  b580 0444               	!text	4,'D'
  8514  b582 d1b3               	!word	LBB_DOKE		; DOKE
  8515  b584 0443               	!text	4,'C'
  8516  b586 a8b3               	!word	LBB_CALL		; CALL
  8517  b588 0244               	!text	2,'D'
  8518  b58a d5b3               	!word	LBB_DO		; DO
  8519  b58c 044c               	!text	4,'L'
  8520  b58e 36b4               	!word	LBB_LOOP		; LOOP
  8521  b590 0550               	!text	5,'P'
  8522  b592 72b4               	!word	LBB_PRINT		; PRINT
  8523  b594 0443               	!text	4,'C'
  8524  b596 b6b3               	!word	LBB_CONT		; CONT
  8525  b598 044c               	!text	4,'L'
  8526  b59a 2ab4               	!word	LBB_LIST		; LIST
  8527  b59c 0543               	!text	5,'C'
  8528  b59e b1b3               	!word	LBB_CLEAR		; CLEAR
  8529  b5a0 034e               	!text	3,'N'
  8530  b5a2 49b4               	!word	LBB_NEW		; NEW
  8531  b5a4 0557               	!text	5,'W'
  8532  b5a6 0cb5               	!word	LBB_WIDTH		; WIDTH
  8533  b5a8 0347               	!text	3,'G'
  8534  b5aa f1b3               	!word	LBB_GET		; GET
  8535  b5ac 0453               	!text	4,'S'
  8536  b5ae cdb4               	!word	LBB_SWAP		; SWAP
  8537  b5b0 0642               	!text	6,'B'
  8538  b5b2 9ab3               	!word	LBB_BITSET		; BITSET
  8539  b5b4 0642               	!text	6,'B'
  8540  b5b6 94b3               	!word	LBB_BITCLR		; BITCLR
  8541  b5b8 0349               	!text	3,'I'
  8542  b5ba 12b4               	!word	LBB_IRQ		; IRQ
  8543  b5bc 034e               	!text	3,'N'
  8544  b5be 50b4               	!word	LBB_NMI		; NMI
  8545                          
  8546                          ; secondary commands (can't start a statement)
  8547                          
  8548  b5c0 0454               	!text	4,'T'
  8549  b5c2 d2b4               	!word	LBB_TAB		; TAB
  8550  b5c4 0445               	!text	4,'E'
  8551  b5c6 d8b3               	!word	LBB_ELSE		; ELSE
  8552  b5c8 0254               	!text	2,'T'
  8553  b5ca deb4               	!word	LBB_TO		; TO
  8554  b5cc 0246               	!text	2,'F'
  8555  b5ce e7b3               	!word	LBB_FN		; FN
  8556  b5d0 0453               	!text	4,'S'
  8557  b5d2 b8b4               	!word	LBB_SPC		; SPC
  8558  b5d4 0454               	!text	4,'T'
  8559  b5d6 dab4               	!word	LBB_THEN		; THEN
  8560  b5d8 034e               	!text	3,'N'
  8561  b5da 53b4               	!word	LBB_NOT		; NOT
  8562  b5dc 0453               	!text	4,'S'
  8563  b5de c0b4               	!word	LBB_STEP		; STEP
  8564  b5e0 0555               	!text	5,'U'
  8565  b5e2 edb4               	!word	LBB_UNTIL		; UNTIL
  8566  b5e4 0557               	!text	5,'W'
  8567  b5e6 07b5               	!word	LBB_WHILE		; WHILE
  8568  b5e8 034f               	!text	3,'O'
  8569  b5ea 5bb4               	!word	LBB_OFF		; OFF
  8570                          
  8571                          ; opperators
  8572                          
  8573  b5ec 012b               	!text	1,'+'
  8574  b5ee 0000               	!word	$0000			; +
  8575  b5f0 012d               	!text	1,'-'
  8576  b5f2 0000               	!word	$0000			; -
  8577  b5f4 012a               	!text	1,'*'
  8578  b5f6 0000               	!word	$0000			; *
  8579  b5f8 012f               	!text	1,'/'
  8580  b5fa 0000               	!word	$0000			; /
  8581  b5fc 015e               	!text	1,'^'
  8582  b5fe 0000               	!word	$0000			; ^
  8583  b600 0341               	!text	3,'A'
  8584  b602 83b3               	!word	LBB_AND		; AND
  8585  b604 0345               	!text	3,'E'
  8586  b606 dfb3               	!word	LBB_EOR		; EOR
  8587  b608 024f               	!text	2,'O'
  8588  b60a 60b4               	!word	LBB_OR		; OR
  8589  b60c 023e               	!text	2,'>'
  8590  b60e 79b3               	!word	LBB_RSHIFT		; >>
  8591  b610 023c               	!text	2,'<'
  8592  b612 73b3               	!word	LBB_LSHIFT		; <<
  8593  b614 013e               	!text	1,'>'
  8594  b616 0000               	!word	$0000			; >
  8595  b618 013d               	!text	1,'='
  8596  b61a 0000               	!word	$0000			; =
  8597  b61c 013c               	!text	1,'<'
  8598  b61e 0000               	!word	$0000			; <
  8599                          
  8600                          ; functions
  8601                          
  8602  b620 0453               	!text	4,'S'			;
  8603  b622 b0b4               	!word	LBB_SGN		; SGN
  8604  b624 0449               	!text	4,'I'			;
  8605  b626 0eb4               	!word	LBB_INT		; INT
  8606  b628 0441               	!text	4,'A'			;
  8607  b62a 7fb3               	!word	LBB_ABS		; ABS
  8608  b62c 0455               	!text	4,'U'			;
  8609  b62e f2b4               	!word	LBB_USR		; USR
  8610  b630 0446               	!text	4,'F'			;
  8611  b632 ecb3               	!word	LBB_FRE		; FRE
  8612  b634 0450               	!text	4,'P'			;
  8613  b636 6eb4               	!word	LBB_POS		; POS
  8614  b638 0453               	!text	4,'S'			;
  8615  b63a bcb4               	!word	LBB_SQR		; SQR
  8616  b63c 0452               	!text	4,'R'			;
  8617  b63e 9fb4               	!word	LBB_RND		; RND
  8618  b640 044c               	!text	4,'L'			;
  8619  b642 32b4               	!word	LBB_LOG		; LOG
  8620  b644 0445               	!text	4,'E'			;
  8621  b646 e2b3               	!word	LBB_EXP		; EXP
  8622  b648 0443               	!text	4,'C'			;
  8623  b64a bab3               	!word	LBB_COS		; COS
  8624  b64c 0453               	!text	4,'S'			;
  8625  b64e b4b4               	!word	LBB_SIN		; SIN
  8626  b650 0454               	!text	4,'T'			;
  8627  b652 d6b4               	!word	LBB_TAN		; TAN
  8628  b654 0441               	!text	4,'A'			;
  8629  b656 8ab3               	!word	LBB_ATN		; ATN
  8630  b658 0550               	!text	5,'P'			;
  8631  b65a 63b4               	!word	LBB_PEEK		; PEEK
  8632  b65c 0544               	!text	5,'D'			;
  8633  b65e c6b3               	!word	LBB_DEEK		; DEEK
  8634  b660 0553               	!text	5,'S'			;
  8635  b662 a7b4               	!word	LBB_SADD		; SADD
  8636  b664 044c               	!text	4,'L'			;
  8637  b666 23b4               	!word	LBB_LEN		; LEN
  8638  b668 0553               	!text	5,'S'			;
  8639  b66a c8b4               	!word	LBB_STRS		; STR$
  8640  b66c 0456               	!text	4,'V'			;
  8641  b66e f7b4               	!word	LBB_VAL		; VAL
  8642  b670 0441               	!text	4,'A'			;
  8643  b672 86b3               	!word	LBB_ASC		; ASC
  8644  b674 0755               	!text	7,'U'			;
  8645  b676 e6b4               	!word	LBB_UCASES		; UCASE$
  8646  b678 074c               	!text	7,'L'			;
  8647  b67a 16b4               	!word	LBB_LCASES		; LCASE$
  8648  b67c 0543               	!text	5,'C'			;
  8649  b67e acb3               	!word	LBB_CHRS		; CHR$
  8650  b680 0548               	!text	5,'H'			;
  8651  b682 feb3               	!word	LBB_HEXS		; HEX$
  8652  b684 0542               	!text	5,'B'			;
  8653  b686 8fb3               	!word	LBB_BINS		; BIN$
  8654  b688 0742               	!text	7,'B'			;
  8655  b68a a0b3               	!word	LBB_BITTST		; BITTST
  8656  b68c 044d               	!text	4,'M'			;
  8657  b68e 3bb4               	!word	LBB_MAX		; MAX
  8658  b690 044d               	!text	4,'M'			;
  8659  b692 44b4               	!word	LBB_MIN		; MIN
  8660  b694 0250               	!text	2,'P'			;
  8661  b696 68b4               	!word	LBB_PI		; PI
  8662  b698 0554               	!text	5,'T'			;
  8663  b69a e0b4               	!word	LBB_TWOPI		; TWOPI
  8664  b69c 0756               	!text	7,'V'			;
  8665  b69e fbb4               	!word	LBB_VPTR		; VARPTR
  8666  b6a0 064c               	!text	6,'L'			;
  8667  b6a2 1db4               	!word	LBB_LEFTS		; LEFT$
  8668  b6a4 0752               	!text	7,'R'			;
  8669  b6a6 98b4               	!word	LBB_RIGHTS		; RIGHT$
  8670  b6a8 054d               	!text	5,'M'			;
  8671  b6aa 3fb4               	!word	LBB_MIDS		; MID$
  8672                          
  8673                          ; BASIC messages, mostly error messages
  8674                          
  8675                          LAB_BAER
  8676  b6ac d0b6               	!word	ERR_NF		;$00 NEXT without FOR
  8677  b6ae e2b6               	!word	ERR_SN		;$02 syntax
  8678  b6b0 eab6               	!word	ERR_RG		;$04 RETURN without GOSUB
  8679  b6b2 00b7               	!word	ERR_OD		;$06 out of data
  8680  b6b4 0db7               	!word	ERR_FC		;$08 function call
  8681  b6b6 1cb7               	!word	ERR_OV		;$0A overflow
  8682  b6b8 26b7               	!word	ERR_OM		;$0C out of memory
  8683  b6ba 35b7               	!word	ERR_US		;$0E undefined statement
  8684  b6bc 4ab7               	!word	ERR_BS		;$10 array bounds
  8685  b6be 58b7               	!word	ERR_DD		;$12 double dimension array
  8686  b6c0 6ab7               	!word	ERR_D0		;$14 divide by 0
  8687  b6c2 7ab7               	!word	ERR_ID		;$16 illegal direct
  8688  b6c4 8ab7               	!word	ERR_TM		;$18 type mismatch
  8689  b6c6 99b7               	!word	ERR_LS		;$1A long string
  8690  b6c8 aab7               	!word	ERR_ST		;$1C string too complex
  8691  b6ca beb7               	!word	ERR_CN		;$1E continue error
  8692  b6cc ceb7               	!word	ERR_UF		;$20 undefined function
  8693  b6ce e2b7               	!word ERR_LD		;$22 LOOP without DO
  8694                          
  8695                          ; I may implement these two errors to force definition of variables and
  8696                          ; dimensioning of arrays before use.
  8697                          
  8698                          ;	!word ERR_UV		;$24 undefined variable
  8699                          
  8700                          ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8701                          
  8702                          ;	!word ERR_UA		;$26 undimensioned array
  8703                          
  8704  b6d0 204e455854207769...ERR_NF	!text	" NEXT without FOR",$00
  8705  b6e2 2053796e74617800   ERR_SN	!text	" Syntax",$00
  8706  b6ea 2052455455524e20...ERR_RG	!text	" RETURN without GOSUB",$00
  8707  b700 204f7574206f6620...ERR_OD	!text	" Out of DATA",$00
  8708  b70d 2046756e6374696f...ERR_FC	!text	" Function call",$00
  8709  b71c 204f766572666c6f...ERR_OV	!text	" Overflow",$00
  8710  b726 204f7574206f6620...ERR_OM	!text	" Out of memory",$00
  8711  b735 20556e646566696e...ERR_US	!text	" Undefined statement",$00
  8712  b74a 2041727261792062...ERR_BS	!text	" Array bounds",$00
  8713  b758 20446f75626c6520...ERR_DD	!text	" Double dimension",$00
  8714  b76a 2044697669646520...ERR_D0	!text	" Divide by zero",$00
  8715  b77a 20496c6c6567616c...ERR_ID	!text	" Illegal direct",$00
  8716  b78a 2054797065206d69...ERR_TM	!text	" Type mismatch",$00
  8717  b799 20537472696e6720...ERR_LS	!text	" String too long",$00
  8718  b7aa 20537472696e6720...ERR_ST	!text	" String too complex",$00
  8719  b7be 2043616e27742063...ERR_CN	!text	" Can't continue",$00
  8720  b7ce 20556e646566696e...ERR_UF	!text	" Undefined function",$00
  8721  b7e2 204c4f4f50207769...ERR_LD	!text	" LOOP without DO",$00
  8722                          
  8723                          ;ERR_UV	!text	"Undefined variable",$00
  8724                          
  8725                          ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8726                          
  8727                          ;ERR_UA	!text	"Undimensioned array",$00
  8728                          
  8729  b7f3 07427265616b00     LAB_BMSG	!text	$07, "Break",$00
  8730  b7fa 07204572726f7200   LAB_EMSG	!text	$07, " Error",$00
  8731  b802 20696e206c696e65...LAB_LMSG	!text	" in line ",$00
  8732  b80c 0a0a205265616479...LAB_RMSG	!text	$0A,$0A," Ready",$0A,$0A,$00
  8733                          
  8734  b817 2045787472612069...LAB_IMSG	!text	" Extra ignored",$0D,$0A,$00
  8735  b828 205265646f206672...LAB_REDO	!text	" Redo from start",$0D,$0A,$00
  8736                          

; ******** Source: basic_hbc56_core.asm
    12                                 ; EhBASIC
    13                          
    14                          ; For saving registers
    15                          SAVE_X          = HBC56_USER_ZP_START
    16                          SAVE_Y          = HBC56_USER_ZP_START + 1
    17                          SAVE_A          = HBC56_USER_ZP_START + 2
    18                          
    19                          ; put the IRQ and NMI code in RAM so that it can be changed
    20                          IRQ_vec         = VEC_SV+2      ; IRQ code vector
    21                          NMI_vec         = IRQ_vec+$0A   ; NMI code vector
    22                          
    23                          ; -----------------------------------------------------------------------------
    24                          ; main entry point
    25                          ; -----------------------------------------------------------------------------
    26                          hbc56Main:
    27                          RES_vec:
    28  b83b 2075b8                     jsr hbc56SetupDisplay
    29                          
    30                                  ; copy I/O vectors
    31  b83e a009                       ldy #END_CODE - LAB_vec - 1    ; set index/count
    32                          LAB_stlp
    33  b840 b94fb8                     lda LAB_vec, Y         ; get byte from interrupt code
    34  b843 990303                     sta VEC_CC, Y            ; save to RAM
    35  b846 88                         dey
    36  b847 10f7                       bpl LAB_stlp
    37                          
    38  b849 58                         cli                        ; enable interrupts
    39                          
    40  b84a 4c0390                     jmp LAB_COLD
    41                          
    42                          ; -----------------------------------------------------------------------------
    43                          ; hybc56Load - EhBASIC load subroutine (for HBC-56)   (TBA)
    44                          ; -----------------------------------------------------------------------------
    45                          hbc56Load
    46  b84d 60                         rts
    47                          
    48                          ; -----------------------------------------------------------------------------
    49                          ; hybc56Save - EhBASIC save subroutine (for HBC-56)   (TBA)
    50                          ; -----------------------------------------------------------------------------
    51                          hbc56Save
    52  b84e 60                         rts
    53                          
    54                          ; -----------------------------------------------------------------------------
    55                          ; vector table - gets copied to VEC_IN in RAM
    56                          ; -----------------------------------------------------------------------------
    57                          LAB_vec
    58  b84f 59b8                   !word    hbc56In         ; check for break (Ctrl+C)
    59  b851 59b8                   !word    hbc56In            ; byte in from keyboard
    60  b853 92b8                   !word    hbc56Out           ; byte out to screen
    61  b855 4db8                   !word    hbc56Load          ; load vector for EhBASIC
    62  b857 4eb8                   !word    hbc56Save          ; save vector for EhBASIC
    63                          
    64                          END_CODE        ; so we know when to stop copying

; ******** Source: basic_tms.asm
    11                                      ; core basic
    12                          

; ******** Source: drivers\input.asm
     1                          ; Troy's HBC-56 - BASIC - Input
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          ; -----------------------------------------------------------------------------
    12                          ; hbc56In - EhBASIC input subroutine (for HBC-56) - must not block
    13                          ; -----------------------------------------------------------------------------
    14                          ; Outputs:      A - ASCII character captured from keyboard
    15                          ;               C - Flag set if key captured, clear if no key pressed
    16                          ; -----------------------------------------------------------------------------
    17                          hbc56In
    18  b859 da                         phx
    19                          
    20  b85a a221                       ldx #$21        ; check ctrl+c
    21  b85c 20c9eb                     jsr kbIsPressed
    22  b85f f00f                       beq @notPressed
    23  b861 a214                       ldx #$14
    24  b863 20c9eb                     jsr kbIsPressed
    25  b866 f008                       beq @notPressed
    26  b868 fa                         plx
    27  b869 2063ec                     jsr kbReadAscii
    28  b86c a903                       lda #$03
    29  b86e 38                         sec
    30  b86f 60                         rts
    31                          @notPressed
    32  b870 fa                         plx
    33                          
    34  b871 2063ec                     jsr kbReadAscii ; HBC-56 keyboard routine can be used directly
    35                                                  ; we could just use it directly in the vector 
    36                                                  ; table, but it's here for clarity
    37  b874 60                         rts

; ******** Source: basic_tms.asm
    13                                                 ; input routines

; ******** Source: drivers\output_tms9918.asm
     1                          ; Troy's HBC-56 - BASIC - Output (TMS9918)
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          FG     = TMS_DK_BLUE
    11                          BG     = TMS_WHITE
    12                          BORDER = TMS_DK_BLUE
    13                          
    14                          ; -----------------------------------------------------------------------------
    15                          ; hbc56SetupDisplay - Setup the display (TMS9918)
    16                          ; -----------------------------------------------------------------------------
    17                          hbc56SetupDisplay:
    18  b875 a944                       +tmsColorFgBg FG, BORDER
    19  b877 20cfe5                     jsr tmsSetBackground
    20  b87a a94f                       +tmsColorFgBg FG, BG
    21  b87c 2054e7                     jsr tmsInitEntireColorTable
    22                          
    23  b87f a92020e5e5                 +tmsEnableInterrupts    ; gives us the console cursor, etc.
    24  b884 a94020e5e5                 +tmsEnableOutput
    25                          
    26  b889 ada37c09808da37c           +consoleEnableCursor
    27  b891 60                         rts
    28                          
    29                          ; -----------------------------------------------------------------------------
    30                          ; hbc56Out - EhBASIC output subroutine (for HBC-56 TMS9918)
    31                          ; -----------------------------------------------------------------------------
    32                          ; Inputs:       A - ASCII character (or code) to output
    33                          ; Outputs:      A - must be maintained
    34                          ; -----------------------------------------------------------------------------
    35                          hbc56Out:
    36  b892 8636                       stx SAVE_X              ; save registers
    37  b894 8437                       sty SAVE_Y
    38  b896 8538                       sta SAVE_A
    39                          
    40  b898 c907                       cmp #$07        ; bell (error beep)
    41  b89a f00a                       beq .bellOut
    42                          
    43                                  ; output 'A' to console
    44  b89c 205ae9                     jsr tmsConsoleOut
    45                          
    46                          .endOut:
    47  b89f a636                       ldx SAVE_X              ; restore registers
    48  b8a1 a437                       ldy SAVE_Y
    49  b8a3 a538                       lda SAVE_A
    50  b8a5 60                         rts
    51                          
    52                          .bellOut
    53  b8a6 20fff1                     jsr hbc56Bell

; ******** Source: basic_tms.asm
    14  b8a9 4c9fb8                           ; output routines
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; metadata for the HBC-56 kernel
    19                          ; -----------------------------------------------------------------------------
    20                          hbc56Meta:
    21  b8ac 4cbcb84842432d35...        +setHbcMetaTitle "HBC-56 BASIC"

; ******** Source: kernel.asm
     1                          ; 6502 - HBC-56 Kernel
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          HBC56_INT_VECTOR = $7e00
    12                          HBC56_NMI_VECTOR = $7e04
    13                          HBC56_RST_VECTOR = kernelMain
    14                          
    15                          HBC56_KERNEL_START = $e000
    16                          HBC56_META_VECTOR  = HBC56_KERNEL_START-4
    17                          
    18                          RTI_OPCODE = $40
    19                          JMP_OPCODE = $4c
    20                          
    21                          ; -------------------------
    22                          ; I/O devices
    23                          ; -------------------------
    24                          LCD_IO_PORT             = $02
    25                          TMS9918_IO_PORT         = $10
    26                          UART_IO_PORT            = $20
    27                          AY_IO_PORT              = $40
    28                          KB_IO_PORT              = $80
    29                          NES_IO_PORT             = $82
    30                          INT_IO_PORT             = $df
    31                          VIA_IO_PORT             = $f0
    32                          ROM_BANK_REG            = $08
    33                          
    34                          ; -------------------------
    35                          ; Kernel Zero Page
    36                          ; -------------------------
    37                          HBC56_KERNEL_ZP_START   = $18
    38                          
    39                          TILEMAP_ZP_START        = HBC56_KERNEL_ZP_START
    40                          TILEMAP_ZP_END          = TILEMAP_ZP_START + 6
    41                          
    42                          BITMAP_ZP_START         = TILEMAP_ZP_END
    43                          BITMAP_ZP_END           = BITMAP_ZP_START + 6
    44                          
    45                          !ifdef HBC56_DISABLE_TMS9918 { .TMS_ZP_SIZE = 0 } else { .TMS_ZP_SIZE = 4 }
    46                          TMS9918_ZP_START        = BITMAP_ZP_END
    47                          TMS9918_ZP_END          = TMS9918_ZP_START + .TMS_ZP_SIZE
    48                          
    49                          !ifdef HBC56_DISABLE_LCD { .LCD_ZP_SIZE = 0 } else { .LCD_ZP_SIZE = 2 }
    50                          LCD_ZP_START            = TMS9918_ZP_END
    51                          LCD_ZP_END              = LCD_ZP_START + .LCD_ZP_SIZE
    52                          
    53                          !ifdef HBC56_DISABLE_UART { .UART_ZP_SIZE = 0 } else { .UART_ZP_SIZE = 4 }
    54                          UART_ZP_START            = LCD_ZP_END
    55                          UART_ZP_END              = UART_ZP_START + .UART_ZP_SIZE
    56                          
    57                          MEMORY_ZP_START         = UART_ZP_END
    58                          MEMORY_ZP_END           = MEMORY_ZP_START + 6
    59                          
    60                          STR_ADDR                = MEMORY_ZP_END
    61                          STR_ADDR_L              = MEMORY_ZP_END
    62                          STR_ADDR_H              = MEMORY_ZP_END + 1
    63                          
    64                          DELAY_L                 = STR_ADDR_H + 1
    65                          DELAY_H                 = DELAY_L + 1
    66                          
    67                          HBC56_KERNEL_ZP_END     = DELAY_H + 1
    68                          HBC56_USER_ZP_START     = HBC56_KERNEL_ZP_END
    69                          
    70                          ;!warn "Total ZP used: ",STR_ADDR_H-HBC56_KERNEL_ZP_START
    71                          
    72                          
    73                          !ifndef HAVE_TMS9918 { HBC56_DISABLE_SFXMAN=1 }
    74                          
    75                          ; -------------------------
    76                          ; Kernel RAM
    77                          ; -------------------------
    78                          HBC56_KERNEL_RAM_START  = $7a00
    79                          
    80                          TILEMAP_RAM_START       = HBC56_KERNEL_RAM_START
    81                          TILEMAP_RAM_END         = TILEMAP_RAM_START + $116
    82                          
    83                          BITMAP_RAM_START        = TILEMAP_RAM_END
    84                          BITMAP_RAM_END          = BITMAP_RAM_START + 16
    85                          
    86                          !ifdef HBC56_DISABLE_TMS9918 { .TMS_RAM_SIZE = 0 } else { .TMS_RAM_SIZE = 50 }
    87                          TMS9918_RAM_START       = BITMAP_RAM_END
    88                          TMS9918_RAM_END         = TMS9918_RAM_START + .TMS_RAM_SIZE
    89                          
    90                          !ifdef HBC56_DISABLE_LCD { .LCD_RAM_SIZE = 0 } else { .LCD_RAM_SIZE = 42 }
    91                          LCD_RAM_START           = TMS9918_RAM_END
    92                          LCD_RAM_END             = LCD_RAM_START + .LCD_RAM_SIZE
    93                          
    94                          !ifdef HBC56_DISABLE_UART { .UART_RAM_SIZE = 0 } else { .UART_RAM_SIZE = 256 }
    95                          UART_RAM_START            = LCD_RAM_END
    96                          UART_RAM_END              = UART_RAM_START + .UART_RAM_SIZE
    97                          
    98                          VIA_RAM_START             = UART_RAM_END
    99                          VIA_RAM_END               = VIA_RAM_START + 1
   100                          
   101                          !ifdef HBC56_DISABLE_SFXMAN { .SFXMAN_RAM_SIZE = 0 } else { .SFXMAN_RAM_SIZE = 18 }
   102                          SFXMAN_RAM_START        = VIA_RAM_END
   103                          SFXMAN_RAM_END          = SFXMAN_RAM_START + .SFXMAN_RAM_SIZE
   104                          
   105                          BCD_RAM_START           = SFXMAN_RAM_END
   106                          BCD_RAM_END             = BCD_RAM_START + 3
   107                          
   108                          KB_RAM_START            = BCD_RAM_END
   109                          KB_RAM_END              = KB_RAM_START + 64
   110                          
   111                          NES_RAM_START            = KB_RAM_END
   112                          NES_RAM_END              = NES_RAM_START + 3
   113                          
   114                          LAST_MODULE_RAM_END     = NES_RAM_END
   115                          
   116                          HBC56_TICKS             = LAST_MODULE_RAM_END
   117                          HBC56_SECONDS_L         = LAST_MODULE_RAM_END + 1
   118                          HBC56_SECONDS_H         = LAST_MODULE_RAM_END + 2
   119                          HBC56_TMP               = LAST_MODULE_RAM_END + 3
   120                          
   121                          HBC56_CONSOLE_FLAGS     = LAST_MODULE_RAM_END + 4
   122                          HBC56_CONSOLE_FLAG_CURSOR = $80
   123                          HBC56_CONSOLE_FLAG_NES    = $40
   124                          HBC56_CONSOLE_FLAG_LCD    = $20
   125                          HBC56_CONSOLE_FLAG_NOWAIT = $10
   126                          
   127                          HBC56_TMP_X             = LAST_MODULE_RAM_END + 5
   128                          HBC56_TMP_Y             = LAST_MODULE_RAM_END + 6
   129                          
   130                          HBC56_META_TITLE_MAX_LEN = 16
   131                          HBC56_META_TITLE        = LAST_MODULE_RAM_END + 7
   132                          HBC56_META_TITLE_END    = HBC56_META_TITLE + HBC56_META_TITLE_MAX_LEN + 1
   133                          HBC56_META_TITLE_LEN    = HBC56_META_TITLE_END + 1
   134                          
   135                          ; callback function on vsync
   136                          HBC56_VSYNC_CALLBACK = HBC56_META_TITLE_LEN + 1
   137                          HBC56_VIA_CALLBACK   = HBC56_VSYNC_CALLBACK + 2
   138                          
   139                          
   140                          HBC56_KERNEL_RAM_END    = HBC56_VIA_CALLBACK + 2
   141                          HBC56_KERNEL_RAM_SIZE   = HBC56_KERNEL_RAM_END - HBC56_KERNEL_RAM_START
   142                          ;!warn "Total RAM used: ",HBC56_KERNEL_RAM_SIZE
   143                          

; ******** Source: ../lib\hbc56.asm
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !cpu w65c02
    12                          !initmem $FF
    13                          cputype = $65c02
    14                          

; ******** Source: ../lib\hbc56.inc
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; Base address of the 256 IO port memory range
    12                          IO_PORT_BASE_ADDRESS    = $7f00
    13                          
    14                          
    15                          ; -------------------------
    16                          ; ASCII constants
    17                          ; -------------------------
    18                          ASCII_RETURN    = $0A
    19                          ASCII_CR        = $0D
    20                          ASCII_BACKSPACE = $08
    21                          ASCII_BELL      = $07

; ******** Source: ../lib\hbc56.asm
    16                          
    17                          DEFAULT_HBC56_NMI_VECTOR = $FFE0
    18                          DEFAULT_HBC56_RST_VECTOR = $8000
    19                          DEFAULT_HBC56_INT_VECTOR = $FFE0
    20                          
    21                          !macro hbc56Title .title {
    22                          HBC56_TITLE_TEXT:
    23                                  !text .title
    24                          HBC56_TITLE_TEXT_LEN = * - HBC56_TITLE_TEXT
    25                                  !byte 0 ; nul terminator for game name
    26                          }
    27                          
    28                          *=DEFAULT_HBC56_INT_VECTOR
    29  ffe0 40                         rti
    30                          
    31                          hbc56Delay:
    32  ffe1 a000                       ldy #0
    33                          hbc56CustomDelay:
    34  ffe3 a200                       ldx #0
    35                          -
    36  ffe5 ca                         dex
    37  ffe6 d0fd                       bne -
    38  ffe8 a200                       ldx #0
    39  ffea 88                         dey
    40  ffeb d0f8                       bne -
    41  ffed 60                         rts
    42                          
    43                          *=$FFFA
    44  fffa 047e               !ifdef HBC56_NMI_VECTOR { !word HBC56_NMI_VECTOR } else { !word DEFAULT_HBC56_NMI_VECTOR }
    45  fffc e4f0               !ifdef HBC56_RST_VECTOR { !word HBC56_RST_VECTOR } else { !word DEFAULT_HBC56_RST_VECTOR }
    46  fffe 007e               !ifdef HBC56_INT_VECTOR { !word HBC56_INT_VECTOR } else { !word DEFAULT_HBC56_INT_VECTOR }
    47                          
    48                          
    49                          *=DEFAULT_HBC56_RST_VECTOR

; ******** Source: kernel.asm
   144                          
   145                          *=HBC56_KERNEL_START
   146                          

; ******** Source: ../lib\ut\ascii.asm
     1                          ; 6502 - ASCII subroutines
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; -----------------------------------------------------------------------------
    12                          ; isLower: Is the ASCII character a lower-case letter (a-z)
    13                          ; -----------------------------------------------------------------------------
    14                          ; Inputs:
    15                          ;   A: ASCII character
    16                          ; Outputs:
    17                          ;   Carry set if lower case, carry clear if not lower case
    18                          ; -----------------------------------------------------------------------------
    19                          isLower:
    20  e000 c961                       cmp #'a'
    21  e002 9005                       bcc @notLower   ; less than 'a'?
    22  e004 c97b                       cmp #'z' + 1
    23  e006 9002                       bcc @isLower    ; less than or equal 'z'?
    24  e008 18                         clc
    25                          @notLower:
    26  e009 60                         rts
    27                          
    28                          @isLower
    29  e00a 38                         sec
    30  e00b 60                         rts
    31                          
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; isUpper: Is the ASCII character a upper-case letter (A-Z)
    35                          ; -----------------------------------------------------------------------------
    36                          ; Inputs:
    37                          ;   A: ASCII character
    38                          ; Outputs:
    39                          ;   Carry set if upper case, carry clear if not upper case
    40                          ; -----------------------------------------------------------------------------
    41                          isUpper:
    42  e00c c941                       cmp #'A'
    43  e00e 9005                       bcc @notUpper   ; less than 'A'?
    44  e010 c95b                       cmp #'Z' + 1
    45  e012 9002                       bcc @isUpper    ; less than or equal 'Z'?
    46  e014 18                         clc
    47                          @notUpper:
    48  e015 60                         rts
    49                          
    50                          @isUpper
    51  e016 38                         sec
    52  e017 60                         rts
    53                          
    54                          ; -----------------------------------------------------------------------------
    55                          ; isAlpha: Is the ASCII character alphanumeric (A-Z, a-z)
    56                          ; -----------------------------------------------------------------------------
    57                          ; Inputs:
    58                          ;   A: ASCII character
    59                          ; Outputs:
    60                          ;   Carry set if alpha, carry clear if not alpha
    61                          ; -----------------------------------------------------------------------------
    62                          isAlpha:
    63  e018 2000e0                     jsr isLower
    64  e01b 90ef                       bcc isUpper
    65  e01d 60                         rts
    66                          
    67                          
    68                          ; -----------------------------------------------------------------------------
    69                          ; isDigit: Is the ASCII character a decimal digit (0-9)
    70                          ; -----------------------------------------------------------------------------
    71                          ; Inputs:
    72                          ;   A: ASCII character
    73                          ; Outputs:
    74                          ;   Carry set if digit, carry clear if not digit
    75                          ; -----------------------------------------------------------------------------
    76                          isDigit:
    77  e01e c930                       cmp #'0'
    78  e020 9005                       bcc @notDigit    ; less than '0'?
    79  e022 c93a                       cmp #'9' + 1
    80  e024 9002                       bcc @isDigit     ; less than or equal '9'?
    81  e026 18                         clc
    82                          
    83                          @notDigit:
    84  e027 60                         rts
    85                          
    86                          @isDigit
    87  e028 38                         sec
    88  e029 60                         rts
    89                          
    90                          
    91                          ; -----------------------------------------------------------------------------
    92                          ; isAlNum: Is the ASCII character alphanumeric (A-Z, a-z, 0-9)
    93                          ; -----------------------------------------------------------------------------
    94                          ; Inputs:
    95                          ;   A: ASCII character
    96                          ; Outputs:
    97                          ;   Carry set if alphanumeric, carry clear if not alphanumeric
    98                          ; -----------------------------------------------------------------------------
    99                          isAlNum:
   100  e02a 2018e0                     jsr isAlpha
   101  e02d 90ef                       bcc isDigit
   102  e02f 60                         rts
   103                          
   104                          ; -----------------------------------------------------------------------------
   105                          ; isDigitX: Is the ASCII character a hex digit (A-F, a-f, 0-9)
   106                          ; -----------------------------------------------------------------------------
   107                          ; Inputs:
   108                          ;   A: ASCII character
   109                          ; Outputs:
   110                          ;   Carry set if hexadecimal, carry clear if not hexadecimal
   111                          ; -----------------------------------------------------------------------------
   112                          isDigitX:
   113  e030 201ee0                     jsr isDigit
   114  e033 b013                       bcs @endIsDigitX
   115  e035 c941                       cmp #'A'
   116  e037 900d                       bcc @notHexDigit   ; less than 'A'?
   117  e039 c947                       cmp #'F' + 1
   118  e03b 900a                       bcc @isHexDigit    ; less than or equal 'F'?
   119  e03d c961                       cmp #'a'
   120  e03f 9005                       bcc @notHexDigit   ; less than 'a'?
   121  e041 c967                       cmp #'f' + 1
   122  e043 9002                       bcc @isHexDigit    ; less than or equal 'f'?
   123  e045 18                         clc
   124                          @notHexDigit:
   125  e046 60                         rts
   126                          
   127                          @isHexDigit
   128  e047 38                         sec
   129                          
   130                          @endIsDigitX
   131  e048 60                         rts
   132                          
   133                          
   134                          ; -----------------------------------------------------------------------------
   135                          ; isSpace: Is the ASCII character a whitespace character?
   136                          ; -----------------------------------------------------------------------------
   137                          ; Inputs:
   138                          ;   A: ASCII character
   139                          ; Outputs:
   140                          ;   Carry set if space, carry clear if not space
   141                          ; -----------------------------------------------------------------------------
   142                          isSpace:
   143  e049 c920                       cmp #' '
   144  e04b f01c                       beq @isSpace
   145  e04d b018                       bcs @notSpace
   146  e04f c90a                       cmp #'\n'
   147  e051 f016                       beq @isSpace
   148  e053 c90d                       cmp #'\r'
   149  e055 f012                       beq @isSpace
   150  e057 c909                       cmp #'\t'
   151  e059 f00e                       beq @isSpace
   152  e05b c90d                       cmp #'\r'
   153  e05d f00a                       beq @isSpace
   154  e05f c90b                       cmp #$0b
   155  e061 f006                       beq @isSpace
   156  e063 c90c                       cmp #$0c
   157  e065 f002                       beq @isSpace
   158                          
   159                          @notSpace:
   160  e067 18                         clc
   161  e068 60                         rts
   162                          
   163                          @isSpace
   164  e069 38                         sec
   165  e06a 60                         rts
   166                          
   167                          ; -----------------------------------------------------------------------------
   168                          ; toUpper: convert an ascii character to upper case
   169                          ; -----------------------------------------------------------------------------
   170                          ; Inputs:
   171                          ;   A: ascii character
   172                          ; Outputs:
   173                          ;   A: upper case ascii character
   174                          ;   C: set if character was converted
   175                          ; -----------------------------------------------------------------------------
   176                          toUpper:
   177  e06b 2000e0                     jsr isLower
   178  e06e 9002                       bcc @endToUpper
   179  e070 4920                       eor #$20        ; convert (subtract $20)
   180                          
   181                          @endToUpper
   182  e072 60                         rts        
   183                          
   184                          ; -----------------------------------------------------------------------------
   185                          ; toLower: convert an ascii character to lower case
   186                          ; -----------------------------------------------------------------------------
   187                          ; Inputs:
   188                          ;   A: ascii character
   189                          ; Outputs:
   190                          ;   A: lower case ascii character
   191                          ;   C: set if character was converted
   192                          ; -----------------------------------------------------------------------------
   193                          toLower:
   194  e073 200ce0                     jsr isUpper
   195  e076 9002                       bcc @endToUpper
   196                          
   197  e078 0920                       ora #$20        ; convert (add $20)
   198                          
   199                          @endToUpper

; ******** Source: kernel.asm
   147  e07a 60                 

; ******** Source: ../lib\ut\bcd.asm
     1                          ; 6502 - BCD subroutines
     2                          ;
     3                          ; Copyright (c) 2020 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          
    12                          !ifndef BCD_RAM_START { BCD_RAM_START = $7810
    13                                  !warn "BCD_RAM_START not provided. Defaulting to ", BCD_RAM_START
    14                          }
    15                          
    16                          ; -------------------------
    17                          ; High RAM
    18                          ; -------------------------
    19                          BCD_TMP1        = BCD_RAM_START
    20                          BCD_TMP2        = BCD_RAM_START + 1
    21                          BCD_TMP3        = BCD_RAM_START + 2
    22                          .BCD_RAM_SIZE   = 3
    23                          
    24                          !if BCD_RAM_END < (BCD_RAM_START + .BCD_RAM_SIZE) {
    25                                  !error "BCD_RAM requires ",BCD_RAM_SIZE," bytes. Allocated ",BCD_RAM_END - BCD_RAM_START
    26                          }
    27                          
    28                          
    29                          ; -----------------------------------------------------------------------------
    30                          ; bin2bcd8: convert an unsigned byte to a 2-digit bcd value
    31                          ; -----------------------------------------------------------------------------
    32                          ; Inputs:
    33                          ;   A: value
    34                          ; Outputs:
    35                          ;   BCD value in R8
    36                          ; -----------------------------------------------------------------------------
    37                          bin2bcd8:
    38  e07b 8d597c               sta BCD_TMP1
    39  e07e a900                 lda #0
    40  e080 8d5a7c               sta BCD_TMP2
    41  e083 8d5b7c               sta BCD_TMP3
    42  e086 a208                 ldx #8 
    43  e088 f8                   sed    
    44                          .loop:
    45  e089 0e597c               asl BCD_TMP1
    46  e08c ad5a7c               lda BCD_TMP2
    47  e08f 6d5a7c               adc BCD_TMP2
    48  e092 8d5a7c               sta BCD_TMP2
    49  e095 ad5b7c               lda BCD_TMP3
    50  e098 6d5b7c               adc BCD_TMP3
    51  e09b 8d5b7c               sta BCD_TMP3
    52  e09e ca                   dex
    53  e09f d0e8                 bne .loop
    54  e0a1 d8                   cld   
    55  e0a2 60                   rts
    56                          

; ******** Source: kernel.asm
   148                          

; ******** Source: ../lib\ut\memory.asm
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          

; ******** Source: ../lib\ut\memory.inc
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; store16: Write a 16-bit immediate value to memory
    15                          ; -----------------------------------------------------------------------------
    16                          ; Inputs:
    17                          ;       .dst: destination address
    18                          ;       .val16: 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          !macro store16 .dst, .val16 {
    21                                  lda #<.val16
    22                                  sta .addr
    23                                  lda #>.val16
    24                                  sta .addr + 1
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; memcpy: Copy a fixed number of bytes from .src to dest
    29                          ; -----------------------------------------------------------------------------
    30                          ; Inputs:
    31                          ;       .src: source address
    32                          ;       .dst: destination address
    33                          ;       .cnt: number of bytes
    34                          ; -----------------------------------------------------------------------------
    35                          !macro memcpy .dst, .src, .cnt {
    36                          !if .cnt <= 0 {
    37                                  !error "memcpy: invalid count: ", .cnt
    38                          } else if .cnt <= 8 {
    39                                  !for i, 0, .cnt - 1 {
    40                                          lda .src + i
    41                                          sta .dst + i
    42                                  }
    43                          } else { !if .cnt <= 256 {
    44                                  ldx #0
    45                          -
    46                                  lda .src, x
    47                                  sta .dst, x
    48                                  inx
    49                                  cpx #(.cnt & $ff)       
    50                                  bne -
    51                          } else {
    52                                  lda #<.src
    53                                  sta MEM_SRC
    54                                  lda #>.src
    55                                  sta MEM_SRC + 1
    56                          
    57                                  lda #<.dst
    58                                  sta MEM_DST
    59                                  lda #>.dst
    60                                  sta MEM_DST + 1
    61                          
    62                          
    63                                          lda #<.cnt
    64                                          sta MEM_LEN
    65                                          lda #>.cnt
    66                                          sta MEM_LEN + 1
    67                                          jsr memcpyMultiPage
    68                                  }
    69                          }
    70                          }
    71                          
    72                          !macro setMemCpySrc .src {
    73                                  lda #<.src
    74                                  sta MEM_SRC
    75                                  lda #>.src
    76                                  sta MEM_SRC + 1
    77                          }
    78                          
    79                          !macro setMemCpyDst .dst {
    80                                  lda #<.dst
    81                                  sta MEM_DST
    82                                  lda #>.dst
    83                                  sta MEM_DST + 1
    84                          }
    85                          
    86                          !macro setMemCpySrcInd .srcRef {
    87                                  lda .srcRef
    88                                  sta MEM_SRC
    89                                  lda .srcRef + 1
    90                                  sta MEM_SRC + 1
    91                          }
    92                          
    93                          !macro setMemCpyDstInd .dstRef {
    94                                  lda .dstRef
    95                                  sta MEM_DST
    96                                  lda .dstRef + 1
    97                                  sta MEM_DST + 1
    98                          }
    99                          
   100                          !macro memcpySinglePage .bytes {
   101                          
   102                                  !if .bytes <= 0 {
   103                                          !error "memcpySinglePage: invalid count: ", .bytes
   104                                  }       
   105                          
   106                                  ldy #.bytes
   107                                  jsr memcpySinglePage
   108                          }
   109                          
   110                          
   111                          ; -----------------------------------------------------------------------------
   112                          ; memcpyPort: Copy a fixed number of bytes from .src ram to dest port
   113                          ; -----------------------------------------------------------------------------
   114                          ; Inputs:
   115                          ;       .src: source address
   116                          ;       .dst: destination address
   117                          ;       .cnt: number of bytes
   118                          ; -----------------------------------------------------------------------------
   119                          !macro memcpyPort .dst, .src, .cnt {
   120                                  !if .cnt <= 0 {
   121                                          !error "memcpyPort: invalid count: ", .cnt
   122                                  }
   123                                  
   124                                  lda #<.src
   125                                  sta MEM_SRC
   126                                  lda #>.src
   127                                  sta MEM_SRC + 1
   128                          
   129                                  lda #<.dst
   130                                  sta MEM_DST
   131                                  lda #>.dst
   132                                  sta MEM_DST + 1
   133                          
   134                                  !if .cnt <= 256 {
   135                                          ldy #<.cnt                                      
   136                                          jsr memcpySinglePagePort
   137                                  } else {
   138                                          lda #<.cnt
   139                                          sta MEM_LEN
   140                                          lda #>.cnt
   141                                          sta MEM_LEN + 1
   142                                          jsr memcpyMultiPagePort
   143                                  }
   144                          }
   145                          
   146                          !zone {
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; memset: Set a fixed number of bytes to a single value
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;       .dst: destination address
   153                          ;       val: the byte value
   154                          ;       .cnt: number of bytes
   155                          ; -----------------------------------------------------------------------------
   156                          !macro memset .dst, .val, .cnt {
   157                          !if .cnt <= 0 {
   158                                  !error "memset: invalid count: ", .cnt
   159                          } else if .cnt <= 8 {
   160                                  lda #.val
   161                                  !for i, 0, .cnt - 1 {
   162                                  sta .dst + i
   163                                  }
   164                          } else if .cnt <= 256 {
   165                                  ldx #<.cnt
   166                                  lda #.val
   167                          -
   168                                  dex
   169                                  sta .dst, x
   170                                  cpx #0
   171                                  bne -
   172                          } else {
   173                                  lda #<.dst
   174                                  sta MEM_DST
   175                                  lda #>.dst
   176                                  sta MEM_DST + 1
   177                                  lda #<.cnt
   178                                  sta MEM_LEN
   179                                  lda #>.cnt
   180                                  sta MEM_LEN + 1
   181                                  lda #.val
   182                                  jsr memsetMultiPage
   183                          }
   184                          }
   185                          
   186                          

; ******** Source: ../lib\ut\memory.asm
    14                          
    15                          
    16                          !ifndef MEMORY_ZP_START { MEMORY_ZP_START = $48
    17                                  !warn "MEMORY_ZP_START not provided. Defaulting to ", MEMORY_ZP_START
    18                          }
    19                          
    20                          ; -------------------------
    21                          ; Zero page
    22                          ; -------------------------
    23                          MEM_DST = MEMORY_ZP_START
    24                          MEM_SRC = MEMORY_ZP_START + 2
    25                          MEM_LEN = MEMORY_ZP_START + 4
    26                          MEMORY_ZP_SIZE  = 6
    27                          
    28                          
    29                          !if MEMORY_ZP_END < (MEMORY_ZP_START + MEMORY_ZP_SIZE) {
    30                                  !error "MEMORY_ZP requires ",MEMORY_ZP_SIZE," bytes. Allocated ",MEMORY_ZP_END - MEMORY_ZP_START
    31                          }
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; memcpySinglePage: Copy up to 255 bytes 
    35                          ; -----------------------------------------------------------------------------
    36                          ; Inputs:
    37                          ;       MEM_SRC: src address
    38                          ;       MEM_DST: dst address
    39                          ;       Y:      bytes
    40                          ; -----------------------------------------------------------------------------
    41                          memcpySinglePage:
    42  e0a3 c000                       cpy #0
    43  e0a5 f009                       beq .endMemcpySinglePage
    44                          -
    45  e0a7 88                         dey
    46  e0a8 b12e                       lda (MEM_SRC), Y
    47  e0aa 912c                       sta (MEM_DST), Y
    48  e0ac c000                       cpy #0
    49  e0ae d0f7                       bne -
    50                          .endMemcpySinglePage:
    51  e0b0 60                         rts
    52                          ; -----------------------------------------------------------------------------
    53                          
    54                          
    55                          
    56                          ; -----------------------------------------------------------------------------
    57                          ; memcpySinglePagePort: Copy up to 255 bytes 
    58                          ; -----------------------------------------------------------------------------
    59                          ; Inputs:
    60                          ;       MEM_SRC: src address
    61                          ;       MEM_DST: dst address (port)
    62                          ;       Y:      bytes
    63                          ; -----------------------------------------------------------------------------
    64                          memcpySinglePagePort:
    65  e0b1 c000                       cpy #0
    66  e0b3 f009                       beq .endMemcpySinglePagePort
    67                          -
    68  e0b5 88                         dey
    69  e0b6 b12e                       lda (MEM_SRC), Y
    70  e0b8 852c                       sta MEM_DST
    71  e0ba c000                       cpy #0
    72  e0bc d0f7                       bne -
    73                          .endMemcpySinglePagePort
    74  e0be 60                         rts
    75                          ; -----------------------------------------------------------------------------
    76                          
    77                          
    78                          
    79                          ; -----------------------------------------------------------------------------
    80                          ; memcpyMultiPage: Copy an up to 2^15 bytes 
    81                          ; -----------------------------------------------------------------------------
    82                          ; Inputs:
    83                          ;       MEM_SRC: src address
    84                          ;       MEM_DST: dst address
    85                          ;       MEM_LEN: length
    86                          ; -----------------------------------------------------------------------------
    87                          memcpyMultiPage:
    88                          
    89                          !ifdef ALLOW_SELF_MODIFYING_CODE {
    90                                  lda MEM_SRC
    91                                  sta .loadIns + 1
    92                                  lda MEM_SRC + 1
    93                                  sta .loadIns + 2
    94                          
    95                                  lda MEM_DST
    96                                  sta .storeIns + 1
    97                                  lda MEM_DST + 1
    98                                  sta .storeIns + 2
    99                          
   100                          .loadIns:
   101                                  lda SELF_MODIFY_ADDR, Y
   102                                  
   103                          .storeIns:
   104                                  sta SELF_MODIFY_ADDR, Y
   105                                  dey
   106                                  bne .loadIns
   107                                  inc .loadIns + 2
   108                                  inc .storeIns + 2
   109                                  dex
   110                                  bne .loadIns
   111                          } else {
   112  e0bf a000                       ldy #0
   113  e0c1 a631                       ldx MEM_LEN + 1
   114                          - 
   115  e0c3 b12e                       lda (MEM_SRC),y ; could unroll to any power of 2
   116  e0c5 912c                       sta (MEM_DST),y
   117  e0c7 c8                         iny
   118  e0c8 d0f9                       bne -
   119  e0ca ca                         dex
   120  e0cb f007                       beq .memcpyMultiPageRemaining
   121  e0cd e62f                       inc MEM_SRC + 1
   122  e0cf e62d                       inc MEM_DST + 1
   123  e0d1 4cc3e0                     jmp -
   124                          .memcpyMultiPageRemaining ; remaining bytes
   125  e0d4 a630                       ldx MEM_LEN
   126  e0d6 f008                       beq .memcpyMultiPageEnd
   127                          - ; X bytes
   128  e0d8 b12e                       lda (MEM_SRC),y
   129  e0da 912c                       sta (MEM_DST),y
   130  e0dc c8                         iny
   131  e0dd ca                         dex
   132  e0de d0f8                       bne -
   133                          .memcpyMultiPageEnd
   134                          }
   135                          
   136  e0e0 60                         rts
   137                          ; -----------------------------------------------------------------------------
   138                          
   139                          
   140                          ; -----------------------------------------------------------------------------
   141                          ; memcpyMultiPagePort: Copy an up to 2^15 bytes 
   142                          ; -----------------------------------------------------------------------------
   143                          ; Inputs:
   144                          ;       MEM_SRC: src address
   145                          ;       MEM_DST: dst address (port)
   146                          ;       MEM_LEN: length
   147                          ; -----------------------------------------------------------------------------
   148                          memcpyMultiPagePort:
   149                          
   150  e0e1 a000                       ldy #0
   151  e0e3 a631                       ldx MEM_LEN + 1
   152                          - 
   153  e0e5 b12e                       lda (MEM_SRC),y ; could unroll to any power of 2
   154  e0e7 852c                       sta MEM_DST
   155  e0e9 c8                         iny
   156  e0ea d0f9                       bne -
   157  e0ec ca                         dex
   158  e0ed f005                       beq .memcpyMultiPagePortRemaining
   159  e0ef e62f                       inc MEM_SRC + 1
   160  e0f1 4ce5e0                     jmp -
   161                          .memcpyMultiPagePortRemaining ; remaining bytes
   162  e0f4 a630                       ldx MEM_LEN
   163  e0f6 f008                       beq .memcpyMultiPagePortEnd
   164                          - ; X bytes
   165  e0f8 b12e                       lda (MEM_SRC),y
   166  e0fa 852c                       sta MEM_DST
   167  e0fc c8                         iny
   168  e0fd ca                         dex
   169  e0fe d0f8                       bne -
   170                          .memcpyMultiPagePortEnd
   171  e100 60                         rts
   172                          ; -----------------------------------------------------------------------------
   173                          
   174                          
   175                          ; -----------------------------------------------------------------------------
   176                          ; memsetSinglePage: set a block of memory data
   177                          ; -----------------------------------------------------------------------------
   178                          ; Inputs:
   179                          ;        A:     value to set
   180                          ;        MEM_DST: start address
   181                          ;        Y:     bytes
   182                          ; -----------------------------------------------------------------------------
   183                          memsetSinglePage:
   184  e101 c000                       cpy #0
   185  e103 f007                       beq .doneCpy
   186                          -
   187  e105 88                         dey
   188  e106 912c                       sta (MEM_DST), y
   189  e108 c000                       cpy #0
   190  e10a d0f9                       bne -
   191                          .doneCpy
   192  e10c 60                         rts
   193                          
   194                          
   195                          ; -----------------------------------------------------------------------------
   196                          ; memsetMultiPage: set a block of memory data
   197                          ; -----------------------------------------------------------------------------
   198                          ; Inputs:
   199                          ;        A: value
   200                          ;        MEM_DST: start address
   201                          ;        MEM_LEN: length
   202                          ; -----------------------------------------------------------------------------
   203                          memsetMultiPage:
   204  e10d a631                       ldx MEM_LEN + 1
   205  e10f d005                       bne .doneSet
   206  e111 a430                       ldy MEM_LEN
   207  e113 4c01e1                     jmp memsetSinglePage
   208                          .doneSet
   209  e116 a000                       ldy #0
   210                          - 
   211  e118 912c                       sta (MEM_DST),y ; could unroll to any power of 2
   212  e11a c8                         iny
   213  e11b d0fb                       bne -
   214  e11d ca                         dex
   215  e11e f005                       beq .doneSet2
   216  e120 e62d                       inc MEM_DST + 1
   217  e122 4c18e1                     jmp -
   218                          .doneSet2 ; remaining bytes
   219  e125 a630                       ldx MEM_LEN
   220  e127 f006                       beq .doneSet3
   221                          - ; X bytes
   222  e129 912c                       sta (MEM_DST),y
   223  e12b c8                         iny
   224  e12c ca                         dex
   225  e12d d0fa                       bne -
   226                          .doneSet3
   227  e12f 60                         rts

; ******** Source: kernel.asm
   149                          

; ******** Source: ../lib\ut\tables.asm
     1                          ; 6502 - Useful tables
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          tableBitFromLeft:
    12  e130 8040201008040201   !byte $80,$40,$20,$10,$08,$04,$02,$01
    13                          tableInvBitFromLeft:
    14  e138 7fbfdfeff7fbfdfe   !byte $7f,$bf,$df,$ef,$f7,$fb,$fd,$fe
    15                          tableBitFromRight:
    16  e140 0102040810204080   !byte $01,$02,$04,$08,$10,$20,$40,$80
    17                          tableInvBitFromRight:
    18  e148 fefdfbf7efdfbf7f   !byte $fe,$fd,$fb,$f7,$ef,$df,$bf,$7f
    19                          tableBitsFromLeft:
    20  e150 80c0e0f0f8fcfeff   !byte $80,$c0,$e0,$f0,$f8,$fc,$fe,$ff

; ******** Source: kernel.asm
   150                          
   151                          
   152                          !ifndef HBC56_DISABLE_AY3891X {

; ******** Source: ../lib\sfx\ay3891x.asm
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          

; ******** Source: ../lib\sfx\ay3891x.inc
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          !macro ayWrite .dev, .reg, .val {
    13                                  lda #.reg
    14                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    15                                  lda #.val
    16                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    17                          }        
    18                          
    19                          !macro ayRead .dev, .reg {
    20                                  lda #.reg
    21                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    22                                  lda IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_READ | .dev
    23                          }        
    24                          
    25                          
    26                          !macro ayWriteX .dev, .reg {
    27                                  lda #.reg
    28                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    29                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    30                          }
    31                          
    32                          !macro ayWriteA .dev, .reg {
    33                                  ldx #.reg
    34                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    35                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    36                          }
    37                          
    38                          !macro ayPlayNote .dev, .chan, .freq {
    39                                  !if .freq <= 0 {
    40                                          .val = 0
    41                                  } else {
    42                                          .val = AY_CLOCK_FREQ / (32.0 * .freq)
    43                                  }
    44                                  +ayWrite .dev, AY_CHA_TONE_L + (.chan * 2), <.val
    45                                  +ayWrite .dev, AY_CHA_TONE_H + (.chan * 2), >.val
    46                          }
    47                          
    48                          !macro ayToneWord .freq {
    49                                  !word (AY_CLOCK_FREQ / (32.0 * .freq))
    50                          }
    51                          
    52                          !macro ayToneByteL .freq {
    53                                  !byte <(AY_CLOCK_FREQ / (32.0 * .freq))
    54                          }
    55                          
    56                          !macro ayToneByteH .freq {
    57                                  !byte >(AY_CLOCK_FREQ / (32.0 * .freq))
    58                          }
    59                          
    60                          
    61                          !macro ayToneEnable .dev, .chan {
    62                                  +ayRead .dev, AY_ENABLES
    63                                  and #!($01 << .chan)
    64                                  +ayWriteA .dev, AY_ENABLES
    65                          }
    66                          
    67                          !macro ayToneDisable .dev, .chan {
    68                                  +ayRead .dev, AY_ENABLES
    69                                  ora #($01 << .chan)
    70                                  +ayWriteA .dev, AY_ENABLES
    71                          }
    72                          
    73                          !macro ayNoiseEnable .dev, .chan {
    74                                  +ayRead .dev, AY_ENABLES
    75                                  eor #($08 << .chan)
    76                                  +ayWriteA .dev, AY_ENABLES
    77                          }
    78                          
    79                          !macro ayNoiseDisable .dev, .chan {
    80                                  +ayRead .dev, AY_ENABLES
    81                                  ora #($08 << .chan)
    82                                  +ayWriteA .dev, AY_ENABLES
    83                          }
    84                          
    85                          !macro aySetVolume .dev, .chan, .vol {
    86                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), (.vol >> 4)
    87                          }
    88                          
    89                          !macro aySetVolumeEnvelope .dev, .chan {
    90                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), $10
    91                          }
    92                          
    93                          !macro aySetEnvelopePeriod .dev, .period {
    94                                  +ayWrite .dev, AY_ENV_PERIOD_L, <.period
    95                                  +ayWrite .dev, AY_ENV_PERIOD_H, >.period
    96                          }
    97                          
    98                          !macro aySetEnvShape .dev, .shape {
    99                                  +ayWrite .dev, AY_ENV_SHAPE, .shape
   100                          }
   101                          
   102                          !macro aySetNoise .dev, .freq {
   103                                  +ayWrite .dev, AY_ENV_SHAPE, .freq >> 3
   104                          }
   105                          
   106                          !macro ayStop .dev, .chan {
   107                                  +ayPlayNote .dev, .chan, 0
   108                          }

; ******** Source: ../lib\sfx\ay3891x.asm
    10                          
    11                          
    12                          
    13                          !ifndef AY_IO_PORT { AY_IO_PORT = $40
    14                                  !warn "AY_IO_PORT not provided. Defaulting to ", AY_IO_PORT
    15                          }
    16                          
    17                          HAVE_AY3891X = 1
    18                          
    19                          ; -------------------------
    20                          ; Constants
    21                          ; -------------------------
    22                          AY_PSG0 = $00
    23                          AY_PSG1 = $04
    24                          
    25                          ; IO Ports
    26                          AY_S0 = IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_PSG0
    27                          AY_S1 = IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_PSG1
    28                          
    29                          AY_INACTIVE = $03
    30                          AY_READ     = $02
    31                          AY_WRITE    = $01
    32                          AY_ADDR     = $00
    33                          
    34                          AY_S0_READ  = AY_S0 | AY_READ
    35                          AY_S0_WRITE = AY_S0 | AY_WRITE
    36                          AY_S0_ADDR  = AY_S0 | AY_ADDR
    37                          
    38                          AY_S1_READ  = AY_S1 | AY_READ
    39                          AY_S1_WRITE = AY_S1 | AY_WRITE
    40                          AY_S1_ADDR  = AY_S1 | AY_ADDR
    41                          
    42                          ; Registers
    43                          AY_R0 = 0
    44                          AY_R1 = 1
    45                          AY_R2 = 2
    46                          AY_R3 = 3
    47                          AY_R4 = 4
    48                          AY_R5 = 5
    49                          AY_R6 = 6
    50                          AY_R7 = 7
    51                          AY_R8 = 8
    52                          AY_R9 = 9
    53                          AY_R10 = 10
    54                          AY_R11 = 11
    55                          AY_R12 = 12
    56                          AY_R13 = 13
    57                          AY_R14 = 14
    58                          AY_R15 = 15
    59                          AY_R16 = 16
    60                          AY_R17 = 17
    61                          
    62                          AY_CHA = 0
    63                          AY_CHB = 1
    64                          AY_CHC = 2
    65                          AY_CHN = 3
    66                          
    67                          AY_CHA_TONE_L   = AY_R0
    68                          AY_CHA_TONE_H   = AY_R1
    69                          AY_CHB_TONE_L   = AY_R2
    70                          AY_CHB_TONE_H   = AY_R3
    71                          AY_CHC_TONE_L   = AY_R4
    72                          AY_CHC_TONE_H   = AY_R5
    73                          AY_NOISE_GEN    = AY_R6
    74                          AY_ENABLES      = AY_R7
    75                          AY_CHA_AMPL     = AY_R8
    76                          AY_CHB_AMPL     = AY_R9
    77                          AY_CHC_AMPL     = AY_R10
    78                          AY_ENV_PERIOD_L = AY_R11
    79                          AY_ENV_PERIOD_H = AY_R12
    80                          AY_ENV_SHAPE    = AY_R13
    81                          AY_PORTA        = AY_R14
    82                          AY_PORTB        = AY_R15
    83                          
    84                          AY_ENV_SHAPE_CONTINUE  = $08
    85                          AY_ENV_SHAPE_ATTACK    = $04
    86                          AY_ENV_SHAPE_ALTERNATE = $02
    87                          AY_ENV_SHAPE_HOLD      = $01
    88                          
    89                          ;  /\  /\  /\  /\  /\ 
    90                          ; /  \/  \/  \/  \/  \
    91                          AY_ENV_SHAPE_TRIANGLE     = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK | AY_ENV_SHAPE_ALTERNATE)
    92                          
    93                          ;  /------------------
    94                          ; /
    95                          AY_ENV_SHAPE_FADE_IN      = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK | AY_ENV_SHAPE_HOLD)
    96                          
    97                          ; \
    98                          ;  \__________________
    99                          AY_ENV_SHAPE_FADE_OUT     = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_HOLD)
   100                          
   101                          ; \ |\ |\ |\ |\ |\ |\ |
   102                          ;  \| \| \| \| \| \| \|
   103                          AY_ENV_SHAPE_SAW1         = (AY_ENV_SHAPE_CONTINUE)
   104                          
   105                          ;  /| /| /| /| /| /| /|
   106                          ; / |/ |/ |/ |/ |/ |/ |
   107                          AY_ENV_SHAPE_SAW2         = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK)
   108                          
   109                          ;  /|
   110                          ; / |__________________
   111                          AY_ENV_SHAPE_FADE_IN_STOP = (AY_ENV_SHAPE_ATTACK)
   112                          
   113                          
   114                          AY_CLOCK_FREQ   = 2000000
   115                          
   116                          ayInit:
   117                                  ; disable everything
   118  e158 a9078d407fa9ff8d...        +ayWrite AY_PSG0, AY_ENABLES, $ff
   119  e162 a9078d447fa9ff8d...        +ayWrite AY_PSG1, AY_ENABLES, $ff
   120                          
   121  e16c a9088d407fa9008d...        +aySetVolume AY_PSG0, AY_CHA, 0
   122  e176 a9098d407fa9008d...        +aySetVolume AY_PSG0, AY_CHB, 0
   123  e180 a90a8d407fa9008d...        +aySetVolume AY_PSG0, AY_CHC, 0
   124                          
   125  e18a a9008d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHA, 0
   126  e19e a9028d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHB, 0
   127  e1b2 a9048d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHC, 0
   128                          
   129  e1c6 a90b8d407fa9008d...        +aySetEnvelopePeriod AY_PSG0, 0
   130  e1da a90d8d407fa9008d...        +aySetEnvShape AY_PSG0, 0
   131  e1e4 a90d8d407fa9008d...        +aySetNoise  AY_PSG0, 0
   132                          
   133  e1ee a9088d447fa9008d...        +aySetVolume AY_PSG1, AY_CHA, 0
   134  e1f8 a9098d447fa9008d...        +aySetVolume AY_PSG1, AY_CHB, 0
   135  e202 a90a8d447fa9008d...        +aySetVolume AY_PSG1, AY_CHC, 0
   136                          
   137  e20c a9008d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHA, 0
   138  e220 a9028d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHB, 0
   139  e234 a9048d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHC, 0
   140                          
   141  e248 a90b8d447fa9008d...        +aySetEnvelopePeriod AY_PSG1, 0
   142  e25c a90d8d447fa9008d...        +aySetEnvShape AY_PSG1, 0
   143  e266 a90d8d447fa9008d...        +aySetNoise  AY_PSG1, 0
   144  e270 60                         rts
   145                          
   146                          ; Note frequencies from https://pages.mtu.edu/~suits/notefreqs.html
   147                          
   148                          NOTE_FREQ_C0  = 16.35
   149                          NOTE_FREQ_CS0 = 17.32
   150                          NOTE_FREQ_D0  = 18.35
   151                          NOTE_FREQ_DS0 = 19.45
   152                          NOTE_FREQ_E0  = 20.6
   153                          NOTE_FREQ_F0  = 21.83
   154                          NOTE_FREQ_FS0 = 23.12
   155                          NOTE_FREQ_G0  = 24.5
   156                          NOTE_FREQ_GS0 = 25.96
   157                          NOTE_FREQ_A0  = 27.5
   158                          NOTE_FREQ_AS0 = 29.14
   159                          NOTE_FREQ_B0  = 30.87
   160                          NOTE_FREQ_C1  = 32.7
   161                          NOTE_FREQ_CS1 = 34.65
   162                          NOTE_FREQ_D1  = 36.71
   163                          NOTE_FREQ_DS1 = 38.89
   164                          NOTE_FREQ_E1  = 41.2
   165                          NOTE_FREQ_F1  = 43.65
   166                          NOTE_FREQ_FS1 = 46.25
   167                          NOTE_FREQ_G1  = 49
   168                          NOTE_FREQ_GS1 = 51.91
   169                          NOTE_FREQ_A1  = 55
   170                          NOTE_FREQ_AS1 = 58.27
   171                          NOTE_FREQ_B1  = 61.74
   172                          NOTE_FREQ_C2  = 65.41
   173                          NOTE_FREQ_CS2 = 69.3
   174                          NOTE_FREQ_D2  = 73.42
   175                          NOTE_FREQ_DS2 = 77.78
   176                          NOTE_FREQ_E2  = 82.41
   177                          NOTE_FREQ_F2  = 87.31
   178                          NOTE_FREQ_FS2 = 92.5
   179                          NOTE_FREQ_G2  = 98
   180                          NOTE_FREQ_GS2 = 103.83
   181                          NOTE_FREQ_A2  = 110
   182                          NOTE_FREQ_AS2 = 116.54
   183                          NOTE_FREQ_B2  = 123.47
   184                          NOTE_FREQ_C3  = 130.81
   185                          NOTE_FREQ_CS3 = 138.59
   186                          NOTE_FREQ_D3  = 146.83
   187                          NOTE_FREQ_DS3 = 155.56
   188                          NOTE_FREQ_E3  = 164.81
   189                          NOTE_FREQ_F3  = 174.61
   190                          NOTE_FREQ_FS3 = 185
   191                          NOTE_FREQ_G3  = 196
   192                          NOTE_FREQ_GS3 = 207.65
   193                          NOTE_FREQ_A3  = 220
   194                          NOTE_FREQ_AS3 = 233.08
   195                          NOTE_FREQ_B3  = 246.94
   196                          NOTE_FREQ_C4  = 261.63
   197                          NOTE_FREQ_CS4 = 277.18
   198                          NOTE_FREQ_D4  = 293.66
   199                          NOTE_FREQ_DS4 = 311.13
   200                          NOTE_FREQ_E4  = 329.63
   201                          NOTE_FREQ_F4  = 349.23
   202                          NOTE_FREQ_FS4 = 369.99
   203                          NOTE_FREQ_G4  = 392
   204                          NOTE_FREQ_GS4 = 415.3
   205                          NOTE_FREQ_A4  = 440
   206                          NOTE_FREQ_AS4 = 466.16
   207                          NOTE_FREQ_B4  = 493.88
   208                          NOTE_FREQ_C5  = 523.25
   209                          NOTE_FREQ_CS5 = 554.37
   210                          NOTE_FREQ_D5  = 587.33
   211                          NOTE_FREQ_DS5 = 622.25
   212                          NOTE_FREQ_E5  = 659.25
   213                          NOTE_FREQ_F5  = 698.46
   214                          NOTE_FREQ_FS5 = 739.99
   215                          NOTE_FREQ_G5  = 783.99
   216                          NOTE_FREQ_GS5 = 830.61
   217                          NOTE_FREQ_A5  = 880
   218                          NOTE_FREQ_AS5 = 932.33
   219                          NOTE_FREQ_B5  = 987.77
   220                          NOTE_FREQ_C6  = 1046.5
   221                          NOTE_FREQ_CS6 = 1108.73
   222                          NOTE_FREQ_D6  = 1174.66
   223                          NOTE_FREQ_DS6 = 1244.51
   224                          NOTE_FREQ_E6  = 1318.51
   225                          NOTE_FREQ_F6  = 1396.91
   226                          NOTE_FREQ_FS6 = 1479.98
   227                          NOTE_FREQ_G6  = 1567.98
   228                          NOTE_FREQ_GS6 = 1661.22
   229                          NOTE_FREQ_A6  = 1760
   230                          NOTE_FREQ_AS6 = 1864.66
   231                          NOTE_FREQ_B6  = 1975.53
   232                          NOTE_FREQ_C7  = 2093
   233                          NOTE_FREQ_CS7 = 2217.46
   234                          NOTE_FREQ_D7  = 2349.32
   235                          NOTE_FREQ_DS7 = 2489.02
   236                          NOTE_FREQ_E7  = 2637.02
   237                          NOTE_FREQ_F7  = 2793.83
   238                          NOTE_FREQ_FS7 = 2959.96
   239                          NOTE_FREQ_G7  = 3135.96
   240                          NOTE_FREQ_GS7 = 3322.44
   241                          NOTE_FREQ_A7  = 3520
   242                          NOTE_FREQ_AS7 = 3729.31
   243                          NOTE_FREQ_B7  = 3951.07
   244                          NOTE_FREQ_C8  = 4186.01
   245                          NOTE_FREQ_CS8 = 4434.92
   246                          NOTE_FREQ_D8  = 4698.63
   247                          NOTE_FREQ_DS8 = 4978.03
   248                          NOTE_FREQ_E8  = 5274.04
   249                          NOTE_FREQ_F8  = 5587.65
   250                          NOTE_FREQ_FS8 = 5919.91
   251                          NOTE_FREQ_G8  = 6271.93
   252                          NOTE_FREQ_GS8 = 6644.88
   253                          NOTE_FREQ_A8  = 7040
   254                          NOTE_FREQ_AS8 = 7458.62
   255                          NOTE_FREQ_B8  = 7902.13

; ******** Source: kernel.asm
   153                          
   154                          }
   155                          
   156                          !ifndef HBC56_DISABLE_TMS9918 {
   157                                  !ifndef TMS_MODEL { TMS_MODEL = 9918 }

; ******** Source: ../lib\gfx\tms9918.asm
     1                          ; 6502 - TMS9918 VDP
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          

; ******** Source: ../lib\hbc56.inc
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; Base address of the 256 IO port memory range
    12                          IO_PORT_BASE_ADDRESS    = $7f00
    13                          
    14                          
    15                          ; -------------------------
    16                          ; ASCII constants
    17                          ; -------------------------
    18                          ASCII_RETURN    = $0A
    19                          ASCII_CR        = $0D
    20                          ASCII_BACKSPACE = $08
    21                          ASCII_BELL      = $07

; ******** Source: ../lib\gfx\tms9918.asm
    10                          
    11                          
    12                          !ifndef HAVE_MATH_INC { !src "ut/math.inc" }

; ******** Source: ../lib\gfx\tms9918.inc
     1                          ; 6502 - TMS9918 VDP Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; tmsWaitReg: Not sure how much delay we need so make a macro for now
    15                          ; -----------------------------------------------------------------------------
    16                          !macro tmsWaitReg {
    17                                  jsr _tmsWaitReg
    18                          }
    19                          
    20                          ; -----------------------------------------------------------------------------
    21                          ; tmsWaitData: Not sure how much delay we need so make a macro for now
    22                          ; -----------------------------------------------------------------------------
    23                          !macro tmsWaitData {
    24                                  jsr _tmsWaitData
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; tmsSetAddressWrite: Set an address in the TMS9918
    29                          ; -----------------------------------------------------------------------------
    30                          !macro tmsSetAddressWrite .addr {
    31                                  +tmsSetAddressRead ($4000 | .addr)
    32                          }
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; tmsSetAddressRead: Set an address to read from the TMS9918
    36                          ; -----------------------------------------------------------------------------
    37                          !macro tmsSetAddressRead .addr {
    38                                  php
    39                                  sei             ; we can't be interrupted here
    40                                  lda #<(.addr)
    41                                  sta TMS9918_REG
    42                                  +tmsWaitReg
    43                                  lda #>(.addr)
    44                                  sta TMS9918_REG
    45                                  +tmsWaitReg
    46                                  plp
    47                          }
    48                          
    49                          ; -----------------------------------------------------------------------------
    50                          ; tmsGet: Get a byte of data from the TMS9918
    51                          ; -----------------------------------------------------------------------------
    52                          !macro tmsGet {
    53                                  lda TMS9918_RAM
    54                                  +tmsWaitData
    55                          }
    56                          
    57                          ; -----------------------------------------------------------------------------
    58                          ; tmsPut: Send a byte of data to the TMS9918
    59                          ; -----------------------------------------------------------------------------
    60                          !macro tmsPut .byte {
    61                                  lda #(.byte & 0xff)
    62                                  +tmsPut
    63                          }
    64                          
    65                          
    66                          ; -----------------------------------------------------------------------------
    67                          ; tmsPut: Send a byte (A) of data to the TMS9918
    68                          ; -----------------------------------------------------------------------------
    69                          !macro tmsPut {
    70                                  sta TMS9918_RAM
    71                                  +tmsWaitData
    72                          }
    73                          
    74                          ; -----------------------------------------------------------------------------
    75                          ; tmsSetColor: Set current fg/bg color
    76                          ; -----------------------------------------------------------------------------
    77                          !macro tmsSetColor .color {
    78                                  lda #.color
    79                                  jsr tmsSetBackground
    80                          }
    81                          
    82                          ; -----------------------------------------------------------------------------
    83                          ; tmsSetColorFgBg: Set current fg/bg color
    84                          ; -----------------------------------------------------------------------------
    85                          !macro tmsSetColorFgBg .fg, .bg {
    86                                  +tmsColorFgBg .fg, .bg
    87                                  jsr tmsSetBackground
    88                          }
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; byteTmsColorFgBg: Output a data byte
    92                          ; -----------------------------------------------------------------------------
    93                          !macro byteTmsColorFgBg .fg, .bg {
    94                          !byte (.fg << 4 | .bg)
    95                          }
    96                          
    97                          
    98                          ; -----------------------------------------------------------------------------
    99                          ; tmsDisableOutput: Disable the TMS9918 output
   100                          ; -----------------------------------------------------------------------------
   101                          !macro tmsDisableOutput {
   102                                  lda #TMS_R1_DISP_ACTIVE
   103                                  jsr tmsReg1ClearFields
   104                          }
   105                          
   106                          ; -----------------------------------------------------------------------------
   107                          ; tmsEnableOutput: Enable the TMS9918 output
   108                          ; -----------------------------------------------------------------------------
   109                          !macro tmsEnableOutput {
   110                                  lda #TMS_R1_DISP_ACTIVE
   111                                  jsr tmsReg1SetFields
   112                          }
   113                          
   114                          ; -
   115                          !macro tmsEnableInterrupts {
   116                                  lda #TMS_R1_INT_ENABLE
   117                                  jsr tmsReg1SetFields
   118                          }
   119                          
   120                          !macro tmsDisableInterrupts {
   121                                  lda #TMS_R1_INT_ENABLE
   122                                  jsr tmsReg1ClearFields
   123                          }
   124                          
   125                          !macro tmsConsoleOut .char {
   126                                  lda #.char
   127                                  jsr tmsConsoleOut
   128                          }
   129                          
   130                          
   131                          ; -----------------------------------------------------------------------------
   132                          ; tmsConsolePrintAddr: Print text to console
   133                          ; -----------------------------------------------------------------------------
   134                          ; Inputs:
   135                          ;  textAddr: Address of null-terminated string to print
   136                          ; -----------------------------------------------------------------------------
   137                          !macro tmsConsolePrintAddr .textAddr {
   138                                  lda #<.textAddr
   139                                  sta STR_ADDR_L
   140                                  lda #>.textAddr
   141                                  sta STR_ADDR_H
   142                                  jsr tmsConsolePrint        
   143                          }
   144                          
   145                          ; -----------------------------------------------------------------------------
   146                          ; tmsConsolePrint: Print immediate text to console
   147                          ; -----------------------------------------------------------------------------
   148                          ; Inputs:
   149                          ;  str: String to print
   150                          ; -----------------------------------------------------------------------------
   151                          !macro tmsConsolePrint .str {
   152                                  jmp .afterText
   153                          .textAddr
   154                                  !text .str,0
   155                          .afterText        
   156                                  +tmsConsolePrintAddr .textAddr
   157                          }
   158                          
   159                          ; -----------------------------------------------------------------------------
   160                          ; +tmsColorFgBg: Set A to the given FG / BG color
   161                          ; -----------------------------------------------------------------------------
   162                          !macro tmsColorFgBg .fg, .bg {
   163                                  lda #(.fg << 4 | .bg)
   164                          }
   165                          
   166                          ; -----------------------------------------------------------------------------
   167                          ; tmsReadStatus: Read status - clear interrupt
   168                          ; -----------------------------------------------------------------------------
   169                          !macro tmsReadStatus  {
   170                                  bit TMS9918_REG
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; tmsSendData: Send # bytes from .sourceAddr to tms9918 data port
   175                          ; -----------------------------------------------------------------------------
   176                          !macro tmsSendData .sourceAddr, .numBytes {
   177                                  lda #<.sourceAddr
   178                                  sta TMS_TMP_ADDRESS
   179                                  lda #>.sourceAddr
   180                                  sta TMS_TMP_ADDRESS + 1
   181                          
   182                                  !if .numBytes < 256 {
   183                                          ldx #.numBytes
   184                                          jsr tmsSendBytes
   185                                  } else {
   186                                          !do while .numBytes > 0 {
   187                                                  !if .numBytes > 255 {
   188                                                          ldx #0
   189                                                          !set .numBytes = .numBytes - 256
   190                                                  } else {
   191                                                          ldx #.numBytes
   192                                                          !set .numBytes = 0
   193                                                  }
   194                                                  jsr tmsSendBytes
   195                                                  inc TMS_TMP_ADDRESS + 1
   196                                          }
   197                                  }
   198                          
   199                          }
   200                          
   201                          ; -----------------------------------------------------------------------------
   202                          ; tmsSendDataRpt: Send # bytes from .sourceAddr to tms9918 data port .rpt times
   203                          ; -----------------------------------------------------------------------------
   204                          !macro tmsSendDataRpt .sourceAddr, .numBytes, .rpt {
   205                                  lda #<.sourceAddr
   206                                  sta TMS_TMP_ADDRESS
   207                                  lda #>.sourceAddr
   208                                  sta TMS_TMP_ADDRESS + 1
   209                          
   210                                  !if .numBytes < 256 {
   211                                          !if .rpt < 5 {
   212                                                  !for i,1,.rpt {
   213                                                          ldx #.numBytes
   214                                                          jsr tmsSendBytes
   215                                                  }
   216                                          } else {
   217                                                  lda #.rpt
   218                                                  sta TMS9918_TMP_BUFFER
   219                          -
   220                                                  ldx #.numBytes
   221                                                  jsr tmsSendBytes
   222                                                  dec TMS9918_TMP_BUFFER
   223                                                  bne -
   224                                          }
   225                                  } else {
   226                                          !error "tmsSendDataRpt supports <256 bytes only"
   227                                  }
   228                          }
   229                          
   230                          
   231                          ; -----------------------------------------------------------------------------
   232                          ; tmsPutRpt: Send value .rpt times
   233                          ; -----------------------------------------------------------------------------
   234                          !macro tmsPutRpt .value, .rpt {
   235                                  ldx #.rpt
   236                                  lda #.value
   237                          -
   238                                  +tmsPut
   239                                  dex
   240                                  bne -
   241                          }
   242                          
   243                          !macro tmsPutSeq .from, .count {
   244                                  lda #.from
   245                          -
   246                                  +tmsPut
   247                                  inc
   248                                  cmp #<(.from + .count)
   249                                  bne -
   250                          }
   251                          
   252                          !macro tmsSetSourceAddressInd .addr {
   253                                  lda .addr
   254                                  sta TMS_TMP_ADDRESS
   255                                  lda .addr + 1
   256                                  sta TMS_TMP_ADDRESS + 1
   257                          }
   258                          
   259                          !macro tmsSetSourceAddressIndOffset .addr, .offset {
   260                                  clc
   261                                  lda .addr
   262                                  adc #<.offset
   263                                  sta TMS_TMP_ADDRESS
   264                                  lda .addr + 1
   265                                  adc #>.offset
   266                                  sta TMS_TMP_ADDRESS + 1
   267                          }
   268                          
   269                          
   270                          !macro tmsSendBytes .bytes {
   271                                  ldx #.bytes
   272                                  jsr tmsSendBytes
   273                          }
   274                          
   275                          
   276                          ; -----------------------------------------------------------------------------
   277                          ; tmsSetAddrPattTable: Initialise address for font table
   278                          ; -----------------------------------------------------------------------------
   279                          !macro tmsSetAddrPattTable {
   280                                  +tmsSetAddrPattTable 0
   281                          }
   282                          
   283                          ; -----------------------------------------------------------------------------
   284                          ; tmsSetAddrPattTable: Initialise address for pattern table
   285                          ; -----------------------------------------------------------------------------
   286                          !macro tmsSetAddrPattTable .ind {
   287                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   288                          }
   289                          
   290                          ; -----------------------------------------------------------------------------
   291                          ; tmsSetAddrPattTable: Initialise address for pattern table
   292                          ; -----------------------------------------------------------------------------
   293                          !macro tmsSetAddrPattTable .ind, .row {
   294                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   295                          }
   296                          
   297                          ; -----------------------------------------------------------------------------
   298                          ; tmsSetAddrPattTableIIBank0: Initialise address for pattern table
   299                          ; -----------------------------------------------------------------------------
   300                          !macro tmsSetAddrPattTableIIBank0 .ind {
   301                                  +tmsSetAddrPattTable .ind
   302                          }
   303                          
   304                          ; -----------------------------------------------------------------------------
   305                          ; tmsSetAddrPattTableIIBank1: Initialise address for pattern table
   306                          ; -----------------------------------------------------------------------------
   307                          !macro tmsSetAddrPattTableIIBank1 .ind {
   308                                  +tmsSetAddrPattTable 256 + .ind
   309                          }
   310                          
   311                          ; -----------------------------------------------------------------------------
   312                          ; tmsSetAddrPattTableIIBank2: Initialise address for pattern table
   313                          ; -----------------------------------------------------------------------------
   314                          !macro tmsSetAddrPattTableIIBank2 .ind {
   315                                  +tmsSetAddrPattTable 512 + .ind
   316                          }
   317                          
   318                          ; -----------------------------------------------------------------------------
   319                          ; tmsSetAddrPattTableRead: Initialise address for pattern table to read
   320                          ; -----------------------------------------------------------------------------
   321                          !macro tmsSetAddrPattTableRead .ind {
   322                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   323                          }
   324                          
   325                          ; -----------------------------------------------------------------------------
   326                          ; tmsSetAddrPattTableRowRead: Initialise address for pattern table to read
   327                          ; -----------------------------------------------------------------------------
   328                          !macro tmsSetAddrPattTableRead .ind, .row {
   329                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   330                          }
   331                          
   332                          ; -----------------------------------------------------------------------------
   333                          ; tmsUpdateFont: Update the pattern table with a given font
   334                          ; -----------------------------------------------------------------------------
   335                          !macro tmsUpdateFont .fontAddr {
   336                                  +tmsSetAddrPattTable 32
   337                                  +tmsSendData .fontAddr, $300
   338                          }
   339                          
   340                          ; -----------------------------------------------------------------------------
   341                          ; tmsSetAddrNameTable: Initialise address for base (text) table
   342                          ; -----------------------------------------------------------------------------
   343                          !macro tmsSetAddrNameTable {
   344                                  +tmsSetAddressWrite TMS_VRAM_NAME_ADDRESS
   345                          }
   346                          
   347                          ; -----------------------------------------------------------------------------
   348                          ; tmsSetAddrColorTable: Initialise address for color table
   349                          ; -----------------------------------------------------------------------------
   350                          !macro tmsSetAddrColorTable {
   351                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS
   352                          }
   353                          
   354                          ; -----------------------------------------------------------------------------
   355                          ; tmsSetAddrColorTable: Initialise address for color table index
   356                          ; -----------------------------------------------------------------------------
   357                          !macro tmsSetAddrColorTable .ind {
   358                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind
   359                          }
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; tmsSetAddrColorTableII: Initialise address for color table index (mode II)
   363                          ; -----------------------------------------------------------------------------
   364                          !macro tmsSetAddrColorTableII .ind {
   365                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind * 8
   366                          }
   367                          
   368                          ; -----------------------------------------------------------------------------
   369                          ; tmsSetAddrColorTableIIBank0: Initialise address for color table index (mode II)
   370                          ; -----------------------------------------------------------------------------
   371                          !macro tmsSetAddrColorTableIIBank0 .ind {
   372                                  +tmsSetAddrColorTableII .ind
   373                          }
   374                          
   375                          ; -----------------------------------------------------------------------------
   376                          ; tmsSetAddrColorTableIIBank1: Initialise address for color table index (mode II)
   377                          ; -----------------------------------------------------------------------------
   378                          !macro tmsSetAddrColorTableIIBank1 .ind {
   379                                  +tmsSetAddrColorTableII 256 + .ind
   380                          }
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; tmsSetAddrColorTableIIBank2: Initialise address for color table index (mode II)
   384                          ; -----------------------------------------------------------------------------
   385                          !macro tmsSetAddrColorTableIIBank2 .ind {
   386                                  +tmsSetAddrColorTableII 512 + .ind
   387                          }
   388                          
   389                          ; -----------------------------------------------------------------------------
   390                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   391                          ; -----------------------------------------------------------------------------
   392                          !macro tmsSetAddrSpriteAttrTable {
   393                                  +tmsSetAddrSpriteAttrTable 0
   394                          }
   395                          
   396                          ; -----------------------------------------------------------------------------
   397                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   398                          ; -----------------------------------------------------------------------------
   399                          !macro tmsSetAddrSpriteAttrTable .index {
   400                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + .index * 4
   401                          }
   402                          
   403                          ; -----------------------------------------------------------------------------
   404                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   405                          ; -----------------------------------------------------------------------------
   406                          !macro tmsSetAddrSpritePattTable {
   407                                  +tmsSetAddrSpritePattTable 0
   408                          }
   409                          
   410                          ; -----------------------------------------------------------------------------
   411                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   412                          ; -----------------------------------------------------------------------------
   413                          !macro tmsSetAddrSpritePattTable .index {
   414                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_PATT_ADDRESS + .index * 8
   415                          }
   416                          
   417                          
   418                          ; -----------------------------------------------------------------------------
   419                          ; tmsCreateSpritePattern: Create a sprite pattern (.spriteDataAddr is 8 bytes)
   420                          ; -----------------------------------------------------------------------------
   421                          !macro tmsCreateSpritePattern .pattInd, .spriteDataAddr {
   422                          
   423                                  
   424                          
   425                                  ; sprite pattern table
   426                                  +tmsSetAddrSpritePattTable .pattInd
   427                          
   428                                  ldx #0
   429                          -
   430                                  lda .spriteDataAddr,x
   431                                  +tmsPut
   432                                  inx
   433                                  cpx #8
   434                          
   435                                  
   436                          
   437                                  bne -
   438                          }
   439                          
   440                          ; -----------------------------------------------------------------------------
   441                          ; tmsCreateSpritePatternQuad: Create a (size 1) sprite pattern 
   442                          ;   (.spriteDataAddr is 32 bytes)
   443                          ; -----------------------------------------------------------------------------
   444                          !macro tmsCreateSpritePatternQuad .pattInd, .spriteDataAddr {
   445                          
   446                                  
   447                          
   448                                  ; sprite pattern table
   449                                  +tmsSetAddrSpritePattTable .pattInd * 4
   450                          
   451                                  ldx #0
   452                          -
   453                                  lda .spriteDataAddr,x
   454                                  +tmsPut 
   455                                  inx
   456                                  cpx #32
   457                          
   458                                  
   459                          
   460                                  bne -
   461                          }
   462                          
   463                          
   464                          !macro tmsCreateSpritePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   465                          
   466                                  ; sprite pattern table
   467                                  +tmsSetAddrSpritePattTable .ind
   468                                  +tmsPut .b0
   469                                  +tmsPut .b2
   470                                  +tmsPut .b2
   471                                  +tmsPut .b3
   472                                  +tmsPut .b4
   473                                  +tmsPut .b5
   474                                  +tmsPut .b6
   475                                  +tmsPut .b7
   476                          }
   477                          
   478                          !macro tmsCreatePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   479                          
   480                                  ; sprite pattern table
   481                                  +tmsSetAddrPattTable .ind
   482                                  +tmsPut .b0
   483                                  +tmsPut .b2
   484                                  +tmsPut .b2
   485                                  +tmsPut .b3
   486                                  +tmsPut .b4
   487                                  +tmsPut .b5
   488                                  +tmsPut .b6
   489                                  +tmsPut .b7
   490                          }
   491                          
   492                          
   493                          ; -----------------------------------------------------------------------------
   494                          ; tmsCreateSprite: Create a sprite
   495                          ; -----------------------------------------------------------------------------
   496                          !macro tmsCreateSprite .ind, .pattInd, .xPos, .yPos, .color {
   497                          
   498                                  ; sprite attr table
   499                                  +tmsSetAddrSpriteAttrTable .ind
   500                          
   501                                  +tmsPut .yPos
   502                                  +tmsPut .xPos
   503                                  +tmsPut .pattInd
   504                                  +tmsPut .color
   505                          }
   506                          
   507                          ; -----------------------------------------------------------------------------
   508                          ; tmsSpritePos: Set a sprite position
   509                          ; -----------------------------------------------------------------------------
   510                          !macro tmsSpritePos .ind, .xPos, .yPos {
   511                                  
   512                          
   513                                  ; sprite attr table
   514                                  +tmsSetAddrSpriteAttrTable .ind
   515                          
   516                                  +tmsPut .yPos
   517                                  +tmsPut .xPos        
   518                          }
   519                          
   520                          
   521                          ; -----------------------------------------------------------------------------
   522                          ; tmsSetLastSprite: Mark a sprite as the last sprite (set next ypos to )
   523                          ; -----------------------------------------------------------------------------
   524                          !macro tmsSetLastSprite .ind {
   525                                  +tmsSpritePos .ind + 1, 0, $d0
   526                          }
   527                          
   528                          
   529                          ; -----------------------------------------------------------------------------
   530                          ; tmsSpritePosXYReg: Set a sprite position from x/y registers
   531                          ; -----------------------------------------------------------------------------
   532                          !macro tmsSpritePosXYReg .ind {
   533                                  
   534                          
   535                                  ; sprite attr table
   536                                  +tmsSetAddrSpriteAttrTable .ind
   537                          
   538                                  tya
   539                                  +tmsPut 
   540                                  txa
   541                                  +tmsPut 
   542                          }
   543                          
   544                          
   545                          ; -----------------------------------------------------------------------------
   546                          ; tmsSetAddrSpriteColor: Change a sprite color
   547                          ; -----------------------------------------------------------------------------
   548                          !macro tmsSetAddrSpriteColor .ind {
   549                          
   550                                  ; sprite attr table
   551                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + (.ind * 4) + 3
   552                          }
   553                          ; -----------------------------------------------------------------------------
   554                          ; tmsSpriteColor: Change a sprite color
   555                          ; -----------------------------------------------------------------------------
   556                          !macro tmsSpriteColor .ind, .color {
   557                          
   558                                  +tmsSetAddrSpriteColor .ind
   559                          
   560                                  +tmsPut .color
   561                          }
   562                          
   563                          
   564                          ; -----------------------------------------------------------------------------
   565                          ; tmsSetPosWrite: Set cursor position
   566                          ; -----------------------------------------------------------------------------
   567                          !macro tmsSetPosWrite .x, .y {
   568                                  +tmsSetAddressWrite (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   569                          }
   570                          
   571                          ; -----------------------------------------------------------------------------
   572                          ; tmsSetPosRead: Set read cursor position
   573                          ; -----------------------------------------------------------------------------
   574                          !macro tmsSetPosRead .x, .y {
   575                                  +tmsSetAddressRead (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   576                          }
   577                          
   578                          ; -----------------------------------------------------------------------------
   579                          ; tmsPrint: Print immediate text
   580                          ; -----------------------------------------------------------------------------
   581                          ; Inputs:
   582                          ;  str: String to print
   583                          ;  x: x position
   584                          ;  y: y position
   585                          ; -----------------------------------------------------------------------------
   586                          !macro tmsPrint .str, .x, .y {
   587                                  jmp .afterText
   588                          .textAddr
   589                                  !text .str,0
   590                          .afterText        
   591                          
   592                                  +tmsSetPosWrite .x, .y
   593                          
   594                                  lda #<.textAddr
   595                                  sta STR_ADDR_L
   596                                  lda #>.textAddr
   597                                  sta STR_ADDR_H
   598                                  jsr tmsPrint        
   599                          }
   600                          
   601                          
   602                          ; -----------------------------------------------------------------------------
   603                          ; tmsPrintCentre: Print centre-aligned immediate text
   604                          ; -----------------------------------------------------------------------------
   605                          ; Inputs:
   606                          ;  str: String to print
   607                          ;  y: y position
   608                          ; -----------------------------------------------------------------------------
   609                          !macro tmsPrintCentre .str, .y {
   610                                  jmp .afterText
   611                          .textAddr
   612                                  !text .str,0
   613                          .afterText        
   614                          
   615                                  +tmsSetPosWrite (32 - ((.afterText - 1) - .textAddr)) / 2, .y
   616                          
   617                                  lda #<.textAddr
   618                                  sta STR_ADDR_L
   619                                  lda #>.textAddr
   620                                  sta STR_ADDR_H
   621                                  jsr tmsPrint        
   622                          }
   623                          
   624                          
   625                          ; -----------------------------------------------------------------------------
   626                          ; tmsPrintZ: Print text
   627                          ; -----------------------------------------------------------------------------
   628                          ; Inputs:
   629                          ;  str: Address of zero-terminated string to print
   630                          ;  x: x position
   631                          ;  y: y position
   632                          ; -----------------------------------------------------------------------------
   633                          !macro tmsPrintZ .textAddr, .x, .y {
   634                                  +tmsSetPosWrite .x, .y
   635                          
   636                                  lda #<.textAddr
   637                                  sta STR_ADDR_L
   638                                  lda #>.textAddr
   639                                  sta STR_ADDR_H
   640                                  jsr tmsPrint        
   641                          }

; ******** Source: ../lib\gfx\tms9918.asm
    13                          
    14                          
    15                          TMS_FONT_DATA:

; ******** Source: ../lib\gfx\fonts\hbc56font.asm
     1                          ; 6502 - HBC-56 Font
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          
    13                          
    14                          
    15                          
    16                          
    17                          
    18                          
    19                          
    20                          
    21                          
    22                          
    23                          
    24                          
    25                          
    26                          
    27                          
    28                          
    29                          
    30                          
    31                          
    32  e271 0000000000000000   !byte $00,$00,$00,$00,$00,$00,$00,$00 ; <SPACE>
    33  e279 1818181818001800   !byte $18,$18,$18,$18,$18,$00,$18,$00 ; !
    34  e281 6c6c6c0000000000   !byte $6C,$6C,$6C,$00,$00,$00,$00,$00 ; "
    35  e289 6c6cfe6cfe6c6c00   !byte $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; #
    36  e291 187ec07c06fc1800   !byte $18,$7E,$C0,$7C,$06,$FC,$18,$00 ; $
    37  e299 00c6cc183066c600   !byte $00,$C6,$CC,$18,$30,$66,$C6,$00 ; %
    38  e2a1 386c3876dccc7600   !byte $38,$6C,$38,$76,$DC,$CC,$76,$00 ; &
    39  e2a9 3030600000000000   !byte $30,$30,$60,$00,$00,$00,$00,$00 ; '
    40  e2b1 0c18303030180c00   !byte $0C,$18,$30,$30,$30,$18,$0C,$00 ; (
    41  e2b9 30180c0c0c183000   !byte $30,$18,$0C,$0C,$0C,$18,$30,$00 ; )
    42  e2c1 00663cff3c660000   !byte $00,$66,$3C,$FF,$3C,$66,$00,$00 ; *
    43  e2c9 0018187e18180000   !byte $00,$18,$18,$7E,$18,$18,$00,$00 ; +
    44  e2d1 0000000000181830   !byte $00,$00,$00,$00,$00,$18,$18,$30 ; ,
    45  e2d9 0000007e00000000   !byte $00,$00,$00,$7E,$00,$00,$00,$00 ; -
    46  e2e1 0000000000181800   !byte $00,$00,$00,$00,$00,$18,$18,$00 ; .
    47  e2e9 060c183060c08000   !byte $06,$0C,$18,$30,$60,$C0,$80,$00 ; /
    48  e2f1 7ccedef6e6c67c00   !byte $7C,$CE,$DE,$F6,$E6,$C6,$7C,$00 ; 0
    49  e2f9 1838181818187e00   !byte $18,$38,$18,$18,$18,$18,$7E,$00 ; 1
    50  e301 7cc6067cc0c0fe00   !byte $7C,$C6,$06,$7C,$C0,$C0,$FE,$00 ; 2
    51  e309 fc06063c0606fc00   !byte $FC,$06,$06,$3C,$06,$06,$FC,$00 ; 3
    52  e311 0cccccccfe0c0c00   !byte $0C,$CC,$CC,$CC,$FE,$0C,$0C,$00 ; 4
    53  e319 fec0fc0606c67c00   !byte $FE,$C0,$FC,$06,$06,$C6,$7C,$00 ; 5
    54  e321 7cc0c0fcc6c67c00   !byte $7C,$C0,$C0,$FC,$C6,$C6,$7C,$00 ; 6
    55  e329 fe06060c18303000   !byte $FE,$06,$06,$0C,$18,$30,$30,$00 ; 7
    56  e331 7cc6c67cc6c67c00   !byte $7C,$C6,$C6,$7C,$C6,$C6,$7C,$00 ; 8
    57  e339 7cc6c67e06067c00   !byte $7C,$C6,$C6,$7E,$06,$06,$7C,$00 ; 9
    58  e341 0018180000181800   !byte $00,$18,$18,$00,$00,$18,$18,$00 ; :
    59  e349 0018180000181830   !byte $00,$18,$18,$00,$00,$18,$18,$30 ; ;
    60  e351 0c18306030180c00   !byte $0C,$18,$30,$60,$30,$18,$0C,$00 ; <
    61  e359 00007e007e000000   !byte $00,$00,$7E,$00,$7E,$00,$00,$00 ; =
    62  e361 30180c060c183000   !byte $30,$18,$0C,$06,$0C,$18,$30,$00 ; >
    63  e369 3c660c1818001800   !byte $3C,$66,$0C,$18,$18,$00,$18,$00 ; ?
    64  e371 7cc6dededec07e00   !byte $7C,$C6,$DE,$DE,$DE,$C0,$7E,$00 ; @
    65  e379 386cc6c6fec6c600   !byte $38,$6C,$C6,$C6,$FE,$C6,$C6,$00 ; A
    66  e381 fcc6c6fcc6c6fc00   !byte $FC,$C6,$C6,$FC,$C6,$C6,$FC,$00 ; B
    67  e389 7cc6c0c0c0c67c00   !byte $7C,$C6,$C0,$C0,$C0,$C6,$7C,$00 ; C
    68  e391 f8ccc6c6c6ccf800   !byte $F8,$CC,$C6,$C6,$C6,$CC,$F8,$00 ; D
    69  e399 fec0c0f8c0c0fe00   !byte $FE,$C0,$C0,$F8,$C0,$C0,$FE,$00 ; E
    70  e3a1 fec0c0f8c0c0c000   !byte $FE,$C0,$C0,$F8,$C0,$C0,$C0,$00 ; F
    71  e3a9 7cc6c0c0cec67c00   !byte $7C,$C6,$C0,$C0,$CE,$C6,$7C,$00 ; G
    72  e3b1 c6c6c6fec6c6c600   !byte $C6,$C6,$C6,$FE,$C6,$C6,$C6,$00 ; H
    73  e3b9 7e18181818187e00   !byte $7E,$18,$18,$18,$18,$18,$7E,$00 ; I
    74  e3c1 0606060606c67c00   !byte $06,$06,$06,$06,$06,$C6,$7C,$00 ; J
    75  e3c9 c6ccd8f0d8ccc600   !byte $C6,$CC,$D8,$F0,$D8,$CC,$C6,$00 ; K
    76  e3d1 c0c0c0c0c0c0fe00   !byte $C0,$C0,$C0,$C0,$C0,$C0,$FE,$00 ; L
    77  e3d9 c6eefefed6c6c600   !byte $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; M
    78  e3e1 c6e6f6decec6c600   !byte $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; N
    79  e3e9 7cc6c6c6c6c67c00   !byte $7C,$C6,$C6,$C6,$C6,$C6,$7C,$00 ; O
    80  e3f1 fcc6c6fcc0c0c000   !byte $FC,$C6,$C6,$FC,$C0,$C0,$C0,$00 ; P
    81  e3f9 7cc6c6c6d6de7c06   !byte $7C,$C6,$C6,$C6,$D6,$DE,$7C,$06 ; Q
    82  e401 fcc6c6fcd8ccc600   !byte $FC,$C6,$C6,$FC,$D8,$CC,$C6,$00 ; R
    83  e409 7cc6c07c06c67c00   !byte $7C,$C6,$C0,$7C,$06,$C6,$7C,$00 ; S
    84  e411 ff18181818181800   !byte $FF,$18,$18,$18,$18,$18,$18,$00 ; T
    85  e419 c6c6c6c6c6c6fe00   !byte $C6,$C6,$C6,$C6,$C6,$C6,$FE,$00 ; U
    86  e421 c6c6c6c6c67c3800   !byte $C6,$C6,$C6,$C6,$C6,$7C,$38,$00 ; V
    87  e429 c6c6c6c6d6fe6c00   !byte $C6,$C6,$C6,$C6,$D6,$FE,$6C,$00 ; W
    88  e431 c6c66c386cc6c600   !byte $C6,$C6,$6C,$38,$6C,$C6,$C6,$00 ; X
    89  e439 c6c6c67c1830e000   !byte $C6,$C6,$C6,$7C,$18,$30,$E0,$00 ; Y
    90  e441 fe060c183060fe00   !byte $FE,$06,$0C,$18,$30,$60,$FE,$00 ; Z
    91  e449 3c30303030303c00   !byte $3C,$30,$30,$30,$30,$30,$3C,$00 ; [
    92  e451 c06030180c060200   !byte $C0,$60,$30,$18,$0C,$06,$02,$00 ; \
    93  e459 3c0c0c0c0c0c3c00   !byte $3C,$0C,$0C,$0C,$0C,$0C,$3C,$00 ; ]
    94  e461 10386cc600000000   !byte $10,$38,$6C,$C6,$00,$00,$00,$00 ; ^
    95  e469 00000000000000ff   !byte $00,$00,$00,$00,$00,$00,$00,$FF ; _
    96  e471 18180c0000000000   !byte $18,$18,$0C,$00,$00,$00,$00,$00 ; `
    97  e479 00007c067ec67e00   !byte $00,$00,$7C,$06,$7E,$C6,$7E,$00 ; a
    98  e481 c0c0c0fcc6c6fc00   !byte $C0,$C0,$C0,$FC,$C6,$C6,$FC,$00 ; b
    99  e489 00007cc6c0c67c00   !byte $00,$00,$7C,$C6,$C0,$C6,$7C,$00 ; c
   100  e491 0606067ec6c67e00   !byte $06,$06,$06,$7E,$C6,$C6,$7E,$00 ; d
   101  e499 00007cc6fec07c00   !byte $00,$00,$7C,$C6,$FE,$C0,$7C,$00 ; e
   102  e4a1 1c36307830307800   !byte $1C,$36,$30,$78,$30,$30,$78,$00 ; f
   103  e4a9 00007ec6c67e06fc   !byte $00,$00,$7E,$C6,$C6,$7E,$06,$FC ; g
   104  e4b1 c0c0fcc6c6c6c600   !byte $C0,$C0,$FC,$C6,$C6,$C6,$C6,$00 ; h
   105  e4b9 1800381818183c00   !byte $18,$00,$38,$18,$18,$18,$3C,$00 ; i
   106  e4c1 060006060606c67c   !byte $06,$00,$06,$06,$06,$06,$C6,$7C ; j
   107  e4c9 c0c0ccd8f8ccc600   !byte $C0,$C0,$CC,$D8,$F8,$CC,$C6,$00 ; k
   108  e4d1 3818181818183c00   !byte $38,$18,$18,$18,$18,$18,$3C,$00 ; l
   109  e4d9 0000ccfefed6d600   !byte $00,$00,$CC,$FE,$FE,$D6,$D6,$00 ; m
   110  e4e1 0000fcc6c6c6c600   !byte $00,$00,$FC,$C6,$C6,$C6,$C6,$00 ; n
   111  e4e9 00007cc6c6c67c00   !byte $00,$00,$7C,$C6,$C6,$C6,$7C,$00 ; o
   112  e4f1 0000fcc6c6fcc0c0   !byte $00,$00,$FC,$C6,$C6,$FC,$C0,$C0 ; p
   113  e4f9 00007ec6c67e0606   !byte $00,$00,$7E,$C6,$C6,$7E,$06,$06 ; q
   114  e501 0000fcc6c0c0c000   !byte $00,$00,$FC,$C6,$C0,$C0,$C0,$00 ; r
   115  e509 00007ec07c06fc00   !byte $00,$00,$7E,$C0,$7C,$06,$FC,$00 ; s
   116  e511 18187e1818180e00   !byte $18,$18,$7E,$18,$18,$18,$0E,$00 ; t
   117  e519 0000c6c6c6c67e00   !byte $00,$00,$C6,$C6,$C6,$C6,$7E,$00 ; u
   118  e521 0000c6c6c67c3800   !byte $00,$00,$C6,$C6,$C6,$7C,$38,$00 ; v
   119  e529 0000c6c6d6fe6c00   !byte $00,$00,$C6,$C6,$D6,$FE,$6C,$00 ; w
   120  e531 0000c66c386cc600   !byte $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; x
   121  e539 0000c6c6c67e06fc   !byte $00,$00,$C6,$C6,$C6,$7E,$06,$FC ; y
   122  e541 0000fe0c3860fe00   !byte $00,$00,$FE,$0C,$38,$60,$FE,$00 ; z
   123  e549 0e18187018180e00   !byte $0E,$18,$18,$70,$18,$18,$0E,$00 ; {
   124  e551 1818180018181800   !byte $18,$18,$18,$00,$18,$18,$18,$00 ; |
   125  e559 7018180e18187000   !byte $70,$18,$18,$0E,$18,$18,$70,$00 ; }
   126  e561 76dc000000000000   !byte $76,$DC,$00,$00,$00,$00,$00,$00 ; ~

; ******** Source: ../lib\gfx\tms9918.asm
    16  e569 ffffffffffffffff   
    17                          
    18                          HAVE_TMS9918 = 1
    19                          
    20                          ; -------------------------
    21                          ; Constants
    22                          ; -------------------------
    23                          !ifndef TMS9918_IO_PORT { TMS9918_IO_PORT = $10
    24                                  !warn "TMS9918_IO_PORT not provided. Defaulting to ", TMS9918_IO_PORT
    25                          }
    26                          
    27                          !ifndef TMS9918_ZP_START { TMS9918_ZP_START = $30
    28                                  !warn "TMS9918_ZP_START not provided. Defaulting to ", TMS9918_ZP_START
    29                          }
    30                          
    31                          !ifndef TMS9918_RAM_START { TMS9918_RAM_START = $7ba0
    32                                  !warn "TMS9918_RAM_START not provided. Defaulting to ", TMS9918_RAM_START
    33                          }
    34                          
    35                          ; -----------------------------------------------------------------------------
    36                          ; Zero page
    37                          ; -----------------------------------------------------------------------------
    38                          TMS_TMP_ADDRESS         = TMS9918_ZP_START      ; 2 bytes
    39                          TMS9918_ZP_SIZE         = 2                     ; LAST ZP ADDRESS
    40                          
    41                          ; -----------------------------------------------------------------------------
    42                          ; High RAM
    43                          ; -----------------------------------------------------------------------------
    44                          .TMS9918_REG0_SHADOW_ADDR = TMS9918_RAM_START
    45                          .TMS9918_REG1_SHADOW_ADDR = TMS9918_RAM_START + 1
    46                          
    47                          TMS9918_CONSOLE_X         = TMS9918_RAM_START + 2
    48                          TMS9918_CONSOLE_Y         = TMS9918_RAM_START + 3
    49                          TMS9918_CONSOLE_SIZE_X    = TMS9918_RAM_START + 4
    50                          TMS9918_CONSOLE_LINE_LEN  = TMS9918_RAM_START + 5
    51                          .TMS9918_REGX             = TMS9918_RAM_START + 6
    52                          .TMS9918_REGY             = TMS9918_RAM_START + 7
    53                          .TMS9918_TMP_READ_ROW     = TMS9918_RAM_START + 8
    54                          .TMS9918_TMP_WRITE_ROW    = TMS9918_RAM_START + 9
    55                          
    56                          TMS9918_TMP_BUFFER        = TMS9918_RAM_START + 10 ; 40 bytes 
    57                          TMS9918_RAM_SIZE          = 50
    58                          
    59                          
    60                          
    61                          !if TMS9918_ZP_END < (TMS9918_ZP_START + TMS9918_ZP_SIZE) {
    62                                  !error "TMS9918_ZP requires ",TMS9918_ZP_SIZE," bytes. Allocated ",TMS9918_ZP_END - TMS9918_ZP_START
    63                          }
    64                          
    65                          !if TMS9918_RAM_END < (TMS9918_RAM_START + TMS9918_RAM_SIZE) {
    66                                  !error "TMS9918_RAM requires ",.TMS9918_RAM_SIZE," bytes. Allocated ",TMS9918_RAM_END - TMS9918_RAM_START
    67                          }
    68                          
    69                          
    70                          ; IO Ports
    71                          TMS9918_RAM     = IO_PORT_BASE_ADDRESS | TMS9918_IO_PORT
    72                          TMS9918_REG     = IO_PORT_BASE_ADDRESS | TMS9918_IO_PORT | $01
    73                          
    74                          
    75                          ; -----------------------------------------------------------------------------
    76                          ; VRAM addresses
    77                          ; -----------------------------------------------------------------------------
    78                          TMS_VRAM_NAME_ADDRESS           = $3800
    79                          TMS_VRAM_COLOR_ADDRESS          = $0000
    80                          TMS_VRAM_PATT_ADDRESS           = $2000
    81                          TMS_VRAM_SPRITE_ATTR_ADDRESS    = $3B00
    82                          TMS_VRAM_SPRITE_PATT_ADDRESS    = $1800
    83                          
    84                          ; -----------------------------------------------------------------------------
    85                          ; Register values
    86                          ; -----------------------------------------------------------------------------
    87                          TMS_R0_MODE_GRAPHICS_I          = $00
    88                          TMS_R0_MODE_GRAPHICS_II         = $02
    89                          TMS_R0_MODE_MULTICOLOR          = $00
    90                          TMS_R0_MODE_TEXT                = $00
    91                          TMS_R0_EXT_VDP_ENABLE           = $01
    92                          TMS_R0_EXT_VDP_DISABLE          = $00
    93                          
    94                          TMS_R1_RAM_16K                  = $80
    95                          TMS_R1_RAM_4K                   = $00
    96                          TMS_R1_DISP_BLANK               = $00
    97                          TMS_R1_DISP_ACTIVE              = $40
    98                          TMS_R1_INT_ENABLE               = $20
    99                          TMS_R1_INT_DISABLE              = $00
   100                          TMS_R1_MODE_GRAPHICS_I          = $00
   101                          TMS_R1_MODE_GRAPHICS_II         = $00
   102                          TMS_R1_MODE_MULTICOLOR          = $08
   103                          TMS_R1_MODE_TEXT                = $10
   104                          TMS_R1_SPRITE_8                 = $00
   105                          TMS_R1_SPRITE_16                = $02
   106                          TMS_R1_SPRITE_MAG1              = $00
   107                          TMS_R1_SPRITE_MAG2              = $01
   108                          
   109                          ; -----------------------------------------------------------------------------
   110                          ; Color palette
   111                          ; -----------------------------------------------------------------------------
   112                          TMS_TRANSPARENT         = $00
   113                          TMS_BLACK               = $01
   114                          TMS_MED_GREEN           = $02
   115                          TMS_LT_GREEN            = $03
   116                          TMS_DK_BLUE             = $04
   117                          TMS_LT_BLUE             = $05
   118                          TMS_DK_RED              = $06
   119                          TMS_CYAN                = $07
   120                          TMS_MED_RED             = $08
   121                          TMS_LT_RED              = $09
   122                          TMS_DK_YELLOW           = $0a
   123                          TMS_LT_YELLOW           = $0b
   124                          TMS_DK_GREEN            = $0c
   125                          TMS_MAGENTA             = $0d
   126                          TMS_GREY                = $0e
   127                          TMS_WHITE               = $0f
   128                          
   129                          TMS_GFX_TILE_WIDTH      = 8
   130                          TMS_GFX_TILE_HEIGHT     = 8
   131                          TMS_GFX_TILES_X         = 32
   132                          TMS_GFX_TILES_Y         = 24
   133                          TMS_GFX_PIXELS_X        = TMS_GFX_TILES_X * TMS_GFX_TILE_WIDTH
   134                          TMS_GFX_PIXELS_Y        = TMS_GFX_TILES_Y * TMS_GFX_TILE_HEIGHT
   135                          
   136                          TMS_TXT_TILE_WIDTH      = 6
   137                          TMS_TXT_TILE_HEIGHT     = 8
   138                          TMS_TXT_TILES_X         = 40
   139                          TMS_TXT_TILES_Y         = 24
   140                          TMS_TXT_PIXELS_X        = TMS_TXT_TILES_X * TMS_TXT_TILE_WIDTH
   141                          TMS_TXT_PIXELS_Y        = TMS_TXT_TILES_Y * TMS_TXT_TILE_HEIGHT
   142                          
   143                          TMS_SPRITE_SIZE         = 8
   144                          TMS_SPRITE_SIZE2X       = TMS_SPRITE_SIZE * 2
   145                          
   146                          !ifndef TMS_MODEL {
   147                                  !warn "Set TMS_MODEL to one of: 9918, 9929. Defaulting to 9918"
   148                                  TMS_MODEL = 9918
   149                          } 
   150                          
   151                          ; -------------------------
   152                          ; Constants
   153                          ; -------------------------
   154                          
   155                          !if TMS_MODEL = 9918 {
   156                                  TMS_FPS = 60
   157                          } else { !if TMS_MODEL = 9929 {
   158                                  TMS_FPS = 50
   159                          } else {
   160                                  !error "Unknown TMS_MODEL. Must be one of: 9918 or 9929"
   161                          }}
   162                          
   163                          ; -----------------------------------------------------------------------------
   164                          ; Default register values
   165                          ; -----------------------------------------------------------------------------
   166                          TMS_REGISTER_DATA:
   167  e571 00                 !byte TMS_R0_EXT_VDP_DISABLE
   168  e572 80                 !byte TMS_R1_RAM_16K
   169  e573 0e                 !byte TMS_VRAM_NAME_ADDRESS >> 10
   170  e574 00                 !byte TMS_VRAM_COLOR_ADDRESS >> 6
   171  e575 04                 !byte TMS_VRAM_PATT_ADDRESS >> 11
   172  e576 76                 !byte TMS_VRAM_SPRITE_ATTR_ADDRESS >> 7
   173  e577 03                 !byte TMS_VRAM_SPRITE_PATT_ADDRESS >> 11
   174  e578 11                 !byte TMS_BLACK << 4 | TMS_BLACK
   175                          
   176                          
   177                          ; -----------------------------------------------------------------------------
   178                          ; Delay subroutines required for TMS9918 CPU access windows
   179                          ; -----------------------------------------------------------------------------
   180                          ;      CONDITION          MODE    VDP DELAY       WAIT TIME          TOTAL TIME
   181                          ; -----------------------------------------------------------------------------
   182                          ;  Active Display Area   Text        2uS          0 - 1.1uS           2 - 3.1uS      
   183                          ;  Active Display Area   GFX I, II   2uS          0 - 5.95uS          2 - 8uS      
   184                          ;  4300uS after VSYNC    All         2uS             0uS                2uS      
   185                          ;  Reg 1 Blank Bit 0     All         2uS             0uS                2uS      
   186                          ;  Active Display Area   Multicolor  2uS          0 - 1.5uS           2 - 3.5uS      
   187                          ; -----------------------------------------------------------------------------
   188                          _tmsWaitData:
   189  e579 ea                         nop
   190  e57a ea                         nop
   191  e57b ea                         nop
   192  e57c ea                         nop
   193  e57d ea                         nop
   194  e57e ea                         nop
   195  e57f ea                         nop
   196  e580 ea                         nop
   197  e581 ea                         nop
   198                          _tmsWaitReg:
   199  e582 ea                         nop
   200  e583 ea                         nop
   201  e584 ea                         nop
   202  e585 60                         rts
   203                          
   204                          tmsSetAddressNextRow:
   205  e586 a524                       lda TMS_TMP_ADDRESS
   206  e588 18                         clc
   207  e589 6920                       adc #32
   208  e58b 8524                       sta TMS_TMP_ADDRESS
   209  e58d 9002                       bcc +
   210  e58f e625                       inc TMS_TMP_ADDRESS + 1
   211                          +
   212  e591 60                         rts
   213                          
   214                          ; -----------------------------------------------------------------------------
   215                          ; tmsSetAddressWrite: Set an address in the TMS9918 
   216                          ; -----------------------------------------------------------------------------
   217                          ; TMS_TMP_ADDRESS: Address to set
   218                          ; -----------------------------------------------------------------------------
   219                          tmsSetAddressWrite:
   220  e592 08                         php
   221  e593 78                         sei                     ; we can't be interrupted here
   222  e594 a524                       lda TMS_TMP_ADDRESS
   223  e596 8d117f                     sta TMS9918_REG
   224  e599 2082e5                     +tmsWaitReg
   225  e59c a525                       lda TMS_TMP_ADDRESS + 1
   226  e59e 0940                       ora #$40
   227  e5a0 8d117f                     sta TMS9918_REG
   228  e5a3 2082e5                     +tmsWaitReg
   229  e5a6 28                         plp
   230  e5a7 60                         rts
   231                          
   232                          ; -----------------------------------------------------------------------------
   233                          ; tmsSetAddressRead: Set an address to read from the TMS9918 
   234                          ; -----------------------------------------------------------------------------
   235                          ; TMS_TMP_ADDRESS: Address to read
   236                          ; -----------------------------------------------------------------------------
   237                          tmsSetAddressRead:
   238  e5a8 08                         php
   239  e5a9 78                         sei                     ; we can't be interrupted here
   240  e5aa a524                       lda TMS_TMP_ADDRESS
   241  e5ac 8d117f                     sta TMS9918_REG
   242  e5af 2082e5                     +tmsWaitReg
   243  e5b2 a525                       lda TMS_TMP_ADDRESS + 1
   244  e5b4 8d117f                     sta TMS9918_REG
   245  e5b7 2082e5                     +tmsWaitReg
   246  e5ba 28                         plp
   247  e5bb 60                         rts
   248                          
   249                          
   250                          ; -----------------------------------------------------------------------------
   251                          ; tmsSetRegister: Set a register value
   252                          ; -----------------------------------------------------------------------------
   253                          ; Inputs:
   254                          ;  A: The value to set
   255                          ;  X: The register (0 - 7)
   256                          ; -----------------------------------------------------------------------------
   257                          tmsSetRegister:
   258  e5bc 08                         php
   259  e5bd 78                         sei             ; we can't be interrupted here
   260  e5be 8d117f                     sta TMS9918_REG
   261  e5c1 2082e5                     +tmsWaitReg
   262  e5c4 8a                         txa
   263  e5c5 0980                       ora #$80
   264  e5c7 8d117f                     sta TMS9918_REG
   265  e5ca 2082e5                     +tmsWaitReg
   266  e5cd 28                         plp
   267  e5ce 60                         rts
   268                          
   269                          ; -----------------------------------------------------------------------------
   270                          ; tmsSetBackground: Set the background color (R7)
   271                          ; -----------------------------------------------------------------------------
   272                          ; Outputs:
   273                          ;  A: Color. High nibble = FG. Low nibble = BG
   274                          ; -----------------------------------------------------------------------------
   275                          tmsSetBackground:
   276  e5cf a207                       ldx #7
   277  e5d1 d0e9                       bne tmsSetRegister
   278                          
   279                          ; -----------------------------------------------------------------------------
   280                          ; tmsReg0Set: Set register 0
   281                          ; -----------------------------------------------------------------------------
   282                          ; Outputs:
   283                          ;  A: Field values to set (will be OR'd with existing Reg0)
   284                          ; -----------------------------------------------------------------------------
   285                          tmsReg0SetFields:
   286  e5d3 0d267b                     ora .TMS9918_REG0_SHADOW_ADDR
   287                          .tmsReg0SetFields:
   288  e5d6 8d267b                     sta .TMS9918_REG0_SHADOW_ADDR
   289  e5d9 a200                       ldx #0
   290  e5db f0df                       beq tmsSetRegister
   291                                  
   292                          ; -----------------------------------------------------------------------------
   293                          ; tmsReg0Clear: Clear register 0 
   294                          ; -----------------------------------------------------------------------------
   295                          ; Outputs:
   296                          ;  A: Field values to cleared (will be XOR'd with existing Reg0)
   297                          ; -----------------------------------------------------------------------------
   298                          tmsReg0ClearFields:
   299  e5dd 49ff                       eor #$ff
   300  e5df 2d267b                     and .TMS9918_REG0_SHADOW_ADDR
   301  e5e2 4cd6e5                     jmp .tmsReg0SetFields
   302                          
   303                          
   304                          ; -----------------------------------------------------------------------------
   305                          ; tmsReg1Set: Set register 0
   306                          ; -----------------------------------------------------------------------------
   307                          ; Outputs:
   308                          ;  A: Field values to set (will be OR'd with existing Reg1)
   309                          ; -----------------------------------------------------------------------------
   310                          tmsReg1SetFields:
   311  e5e5 0d277b                     ora .TMS9918_REG1_SHADOW_ADDR
   312                          .tmsReg1SetFields:
   313  e5e8 8d277b                     sta .TMS9918_REG1_SHADOW_ADDR
   314  e5eb a201                       ldx #1
   315  e5ed d0cd                       bne tmsSetRegister
   316                                  
   317                          ; -----------------------------------------------------------------------------
   318                          ; tmsReg1Clear: Clear register 1
   319                          ; -----------------------------------------------------------------------------
   320                          ; Outputs:
   321                          ;  A: Field values to cleared (will be XOR'd with existing Reg1)
   322                          ; -----------------------------------------------------------------------------
   323                          tmsReg1ClearFields:
   324  e5ef 49ff                       eor #$ff
   325  e5f1 2d277b                     and .TMS9918_REG1_SHADOW_ADDR
   326  e5f4 4ce8e5                     jmp .tmsReg1SetFields
   327                          
   328                          
   329                          ; -----------------------------------------------------------------------------
   330                          ; tmsModeReset: Reset graphics Mode
   331                          ; -----------------------------------------------------------------------------
   332                          tmsModeReset:
   333  e5f7 a903                       lda #$03
   334  e5f9 20dde5                     jsr tmsReg0ClearFields
   335                          
   336  e5fc a918                       lda #$18
   337  e5fe 20efe5                     jsr tmsReg1ClearFields
   338                          
   339                                  ; if we were in Graphics II, then we need to reset
   340                                  ; the color and pattern table addresses
   341  e601 a900                       lda #0;(TMS_VRAM_COLOR_ADDRESS >> 6)
   342  e603 a203                       ldx #3
   343  e605 20bce5                     jsr tmsSetRegister
   344                          
   345  e608 a904                       lda #TMS_VRAM_PATT_ADDRESS >> 11
   346  e60a a204                       ldx #4
   347  e60c 20bce5                     jsr tmsSetRegister
   348  e60f 60                         rts
   349                          
   350                          ; -----------------------------------------------------------------------------
   351                          ; tmsModeGraphicsI: Set up for Graphics I mode
   352                          ; -----------------------------------------------------------------------------
   353                          tmsModeGraphicsI:
   354  e610 20f7e5                     jsr tmsModeReset
   355                          
   356  e613 a900                       lda #TMS_R0_MODE_GRAPHICS_I
   357  e615 20d3e5                     jsr tmsReg0SetFields
   358                          
   359  e618 a900                       lda #TMS_R1_MODE_GRAPHICS_I
   360  e61a 20e5e5                     jsr tmsReg1SetFields
   361                          
   362  e61d a920                       lda #32
   363  e61f 8d2a7b                     sta TMS9918_CONSOLE_SIZE_X
   364  e622 60                         rts
   365                          
   366                          ; -----------------------------------------------------------------------------
   367                          ; tmsModeGraphicsII: Set up for Graphics II mode
   368                          ; -----------------------------------------------------------------------------
   369                          tmsModeGraphicsII:
   370  e623 20f7e5                     jsr tmsModeReset
   371                          
   372  e626 a902                       lda #TMS_R0_MODE_GRAPHICS_II
   373  e628 20d3e5                     jsr tmsReg0SetFields
   374                          
   375  e62b a900                       lda #TMS_R1_MODE_GRAPHICS_II
   376  e62d 20e5e5                     jsr tmsReg1SetFields
   377                          
   378                                  ; in Graphics II, Registers 3 and 4 work differently
   379                                  ;
   380                                  ; reg3 - Color table
   381                                  ;   $7f = $0000
   382                                  ;   $ff = $2000
   383                                  ;
   384                                  ; reg4 - Pattern table
   385                                  ;  $03 = $0000
   386                                  ;  $07 = $2000
   387                          
   388                                  ; set color table to $0000
   389  e630 a97f                       lda #$7f
   390  e632 a203                       ldx #3
   391  e634 20bce5                     jsr tmsSetRegister
   392                          
   393                                  ; set pattern table to $2000
   394  e637 a907                       lda #$07
   395  e639 a204                       ldx #4
   396  e63b 20bce5                     jsr tmsSetRegister
   397                          
   398  e63e a920                       lda #32
   399  e640 8d2a7b                     sta TMS9918_CONSOLE_SIZE_X
   400                          
   401  e643 60                         rts
   402                          
   403                          ; -----------------------------------------------------------------------------
   404                          ; tmsModeText: Set up for Text mode
   405                          ; -----------------------------------------------------------------------------
   406                          tmsModeText:
   407  e644 20f7e5                     jsr tmsModeReset
   408                          
   409  e647 a900                       lda #TMS_R0_MODE_TEXT
   410  e649 20d3e5                     jsr tmsReg0SetFields
   411                          
   412  e64c a910                       lda #TMS_R1_MODE_TEXT
   413  e64e 20e5e5                     jsr tmsReg1SetFields
   414                          
   415  e651 a928                       lda #40
   416  e653 8d2a7b                     sta TMS9918_CONSOLE_SIZE_X
   417                          
   418  e656 60                         rts
   419                          
   420                          ; -----------------------------------------------------------------------------
   421                          ; tmsModeMulticolor: Set up for Multicolor mode
   422                          ; -----------------------------------------------------------------------------
   423                          tmsModeMulticolor:
   424  e657 20f7e5                     jsr tmsModeReset
   425                          
   426  e65a a900                       lda #TMS_R0_MODE_MULTICOLOR
   427  e65c 20d3e5                     jsr tmsReg0SetFields
   428                          
   429  e65f a908                       lda #TMS_R1_MODE_MULTICOLOR
   430  e661 20e5e5                     jsr tmsReg1SetFields
   431  e664 60                         rts
   432                          
   433                          ; -----------------------------------------------------------------------------
   434                          ; tmsInit: Initialise the registers
   435                          ; -----------------------------------------------------------------------------
   436                          tmsInit:
   437  e665 08                         php
   438  e666 78                         sei                             ; we can't be interrupted here
   439  e667 ad71e5                     lda TMS_REGISTER_DATA
   440  e66a 8d267b                     sta .TMS9918_REG0_SHADOW_ADDR
   441  e66d ad72e5                     lda TMS_REGISTER_DATA + 1
   442  e670 8d277b                     sta .TMS9918_REG1_SHADOW_ADDR
   443                          
   444  e673 a900                       lda #0
   445  e675 8d287b                     sta TMS9918_CONSOLE_X
   446  e678 8d297b                     sta TMS9918_CONSOLE_Y
   447                          
   448                                  ; set up the registers
   449  e67b a200                       ldx #0
   450                          
   451                          @regLoop
   452  e67d bd71e5                             lda TMS_REGISTER_DATA, x
   453  e680 8d117f                             sta TMS9918_REG
   454  e683 2082e5                             +tmsWaitReg
   455  e686 8a                                 txa
   456  e687 0980                               ora #$80
   457  e689 8d117f                             sta TMS9918_REG
   458  e68c 2082e5                             +tmsWaitReg
   459  e68f e8                                 inx
   460  e690 e008                               cpx #8
   461  e692 d0e9                               bne @regLoop
   462                                  
   463  e694 2010e6                     jsr tmsModeGraphicsI
   464                          
   465                                  ; load all data into VRAM
   466  e697 20f9e6                     jsr tmsInitPattTable
   467                          
   468  e69a 2039e7                     jsr tmsInitTextTable
   469                                  
   470  e69d a917                       +tmsColorFgBg TMS_BLACK, TMS_CYAN
   471  e69f 2054e7                     jsr tmsInitEntireColorTable
   472                          
   473  e6a2 2075e7                     jsr tmsInitSpriteTable
   474                          
   475  e6a5 28                         plp
   476                                  
   477  e6a6 60                         rts
   478                          
   479                          ; -----------------------------------------------------------------------------
   480                          ; _tmsSendPage: Send A for a kilobyte
   481                          ; -----------------------------------------------------------------------------
   482                          _tmsSendKb
   483  e6a7 20b0e6                     jsr _tmsSendPage
   484  e6aa 20b0e6                     jsr _tmsSendPage
   485  e6ad 20b0e6                     jsr _tmsSendPage
   486                                  ; flow through
   487                                  
   488                          ; -----------------------------------------------------------------------------
   489                          ; _tmsSendPage: Send A for a whole page
   490                          ; -----------------------------------------------------------------------------
   491                          _tmsSendPage:
   492  e6b0 a220                       ldx #32
   493                          _tmsSendX8:
   494  e6b2 8d107f2079e5               +tmsPut
   495  e6b8 8d107f2079e5               +tmsPut
   496  e6be 8d107f2079e5               +tmsPut
   497  e6c4 8d107f2079e5               +tmsPut
   498  e6ca 8d107f2079e5               +tmsPut
   499  e6d0 8d107f2079e5               +tmsPut
   500  e6d6 8d107f2079e5               +tmsPut
   501  e6dc 8d107f2079e5               +tmsPut
   502  e6e2 ca                         dex
   503  e6e3 d0cd                       bne _tmsSendX8
   504  e6e5 60                         rts
   505                          
   506                          ; -----------------------------------------------------------------------------
   507                          ; _tmsSendEmptyPage: Send an empty page of data
   508                          ; -----------------------------------------------------------------------------
   509                          _tmsSendEmptyPage:
   510  e6e6 a900                       lda #0
   511  e6e8 f0c6                       beq _tmsSendPage ; rts in here
   512                          
   513                          ; -----------------------------------------------------------------------------
   514                          ; tmsSendBytes: Send bytes to the TMS (up to 1 page)
   515                          ; -----------------------------------------------------------------------------
   516                          ; Inputs:
   517                          ;   TMS_TMP_ADDRESS:    Holds source address
   518                          ;   X:                  Number of bytes (1 to 256)
   519                          ; -----------------------------------------------------------------------------
   520                          tmsSendBytes:
   521  e6ea a000                       ldy #0
   522                          -
   523  e6ec b124                       lda (TMS_TMP_ADDRESS), Y
   524  e6ee 8d107f2079e5               +tmsPut
   525  e6f4 c8                         iny
   526  e6f5 ca                         dex
   527  e6f6 d0f4                       bne -
   528  e6f8 60                         rts
   529                          
   530                          ; -----------------------------------------------------------------------------
   531                          ; tmsInitPattTable: Initialise the pattern table
   532                          ; -----------------------------------------------------------------------------
   533                          tmsInitPattTable:
   534                                  
   535                          
   536                                  ; pattern table
   537  e6f9 0878a9008d117f20...        +tmsSetAddrPattTable
   538                          
   539                                  ; (0 - 31) all empty
   540  e70c 20e6e6                     jsr _tmsSendEmptyPage
   541                          
   542  e70f a9718524a9e28525...        +tmsSendData TMS_FONT_DATA, $300
   543                          
   544                                  ; (128 - 159) all empty
   545  e72c 20e6e6                     jsr _tmsSendEmptyPage
   546                          
   547                                  ; (160 - 191) all empty
   548  e72f 20e6e6                     jsr _tmsSendEmptyPage
   549                          
   550                                  ; (192 - 223) all empty
   551  e732 20e6e6                     jsr _tmsSendEmptyPage
   552                          
   553                                  ; (224 - 255) all empty
   554  e735 20e6e6                     jsr _tmsSendEmptyPage
   555                          
   556                                  
   557                          
   558  e738 60                         rts
   559                          
   560                          ; -----------------------------------------------------------------------------
   561                          ; tmsInitTextTable: Initialise the text (tilemap) table
   562                          ; -----------------------------------------------------------------------------
   563                          tmsInitTextTable:
   564                                  
   565                          
   566                                  ; text table table
   567  e739 0878a9008d117f20...        +tmsSetAddrNameTable
   568                          
   569                          
   570  e74c a900                       lda #0
   571  e74e a27e                       ldx #(42 * 3)
   572  e750 20b2e6                     jsr _tmsSendX8
   573                          
   574  e753 60                         rts
   575                          
   576                          
   577                          ; -----------------------------------------------------------------------------
   578                          ; tmsInitEntireColorTable: Initialise the full color table
   579                          ; -----------------------------------------------------------------------------
   580                          ; Inputs:
   581                          ;   A: Color (fg/bg) to initialise
   582                          
   583                          tmsInitEntireColorTable:
   584  e754 a220                       ldx #32
   585                          
   586                          ; tmsInitColorTable: Initialise the color table
   587                          
   588                          ; Inputs:
   589                          ;   A: Color (fg/bg) to initialise
   590                          ;   X: Number of elements to initialise (1 to 32)
   591                          ; -----------------------------------------------------------------------------
   592                          tmsInitColorTable:
   593                                  
   594  e756 48                         pha
   595                          
   596                                  ; color table
   597  e757 0878a9008d117f20...        +tmsSetAddrColorTable
   598                          
   599  e76a 68                         pla
   600                          -
   601  e76b 8d107f2079e5               +tmsPut
   602  e771 ca                         dex
   603  e772 d0f7                       bne -
   604                          
   605  e774 60                         rts
   606                          
   607                          ; -----------------------------------------------------------------------------
   608                          ; tmsInitSpriteTable: Initialise the sprite table
   609                          ; -----------------------------------------------------------------------------
   610                          tmsInitSpriteTable:
   611                                  
   612                          
   613                                  ; sprites table
   614  e775 0878a9008d117f20...        +tmsSetAddrSpriteAttrTable
   615                          
   616  e788 a220                       ldx #32
   617                          -
   618                                  ; Vertical position
   619  e78a a9d08d107f2079e5           +tmsPut $D0        ; 208 ($D0) stops processing of sprites
   620  e792 a9008d107f2079e5           +tmsPut $00        ; Horizontal position
   621                          
   622                                  ; Index (A still 0)
   623  e79a 8d107f2079e5               +tmsPut
   624                                  ; Early Clock / Color  (A still 0)
   625  e7a0 8d107f2079e5               +tmsPut
   626  e7a6 ca                         dex
   627  e7a7 d0e1                       bne -
   628                          
   629                                  
   630                          
   631  e7a9 60                         rts
   632                          
   633                          ; -----------------------------------------------------------------------------
   634                          ; tmsTileXyAtPixelXy: Return tile position at pixel position
   635                          ; -----------------------------------------------------------------------------
   636                          ; Inputs:
   637                          ;  X: Pixel position X
   638                          ;  Y: Pixel position Y
   639                          ; Outputs:
   640                          ;  X: Tile position X
   641                          ;  Y: Tile position Y
   642                          ; -----------------------------------------------------------------------------
   643                          tmsTileXyAtPixelXy:
   644  e7aa 48                         pha
   645  e7ab 8a                         txa
   646  e7ac 4a4a4a                     +div8
   647  e7af aa                         tax
   648                          
   649  e7b0 98                         tya
   650  e7b1 4a4a4a                     +div8
   651  e7b4 a8                         tay
   652  e7b5 68                         pla
   653  e7b6 60                         rts
   654                          
   655                          ; -----------------------------------------------------------------------------
   656                          ; tmsHex8: Output an 8-bit byte as hexadecimal
   657                          ; -----------------------------------------------------------------------------
   658                          ; Inputs:
   659                          ;  A: The value to output
   660                          ; -----------------------------------------------------------------------------
   661                          tmsHex8:
   662  e7b7 48                         pha
   663  e7b8 4a4a4a4a                   +lsr4
   664  e7bc aa                         tax
   665  e7bd bdd4e7                     lda .H2, x
   666  e7c0 8d107f2079e5               +tmsPut 
   667  e7c6 68                         pla
   668  e7c7 290f                       and #$0f
   669  e7c9 aa                         tax
   670  e7ca bdd4e7                     lda .H2, x
   671  e7cd 8d107f2079e5               +tmsPut 
   672                                  
   673  e7d3 60                         rts
   674                          
   675  e7d4 3031323334353637....H2 !text "0123456789abcdef"
   676                          
   677                          
   678                          ; -----------------------------------------------------------------------------
   679                          ; tmsSetSpriteTmpAddress: Set TMS_TMP_ADDRESS for a given sprite attributes
   680                          ; -----------------------------------------------------------------------------
   681                          ; Inputs:
   682                          ;   A: sprite index (0-31)
   683                          ; -----------------------------------------------------------------------------
   684                          tmsSetSpriteTmpAddress:
   685  e7e4 0a                         asl
   686  e7e5 0a                         asl
   687  e7e6 8524                       sta TMS_TMP_ADDRESS
   688                          
   689  e7e8 a93b                       lda #>TMS_VRAM_SPRITE_ATTR_ADDRESS
   690  e7ea 8525                       sta TMS_TMP_ADDRESS + 1
   691  e7ec 60                         rts
   692                          
   693                          ; -----------------------------------------------------------------------------
   694                          ; tmsSetPosTmpAddress: Set TMS_TMP_ADDRESS for a given text position
   695                          ; -----------------------------------------------------------------------------
   696                          ; Inputs:
   697                          ;   X: X position (0 - 31)
   698                          ;   Y: Y position (0 - 23)
   699                          ; -----------------------------------------------------------------------------
   700                          tmsSetPosTmpAddress:
   701  e7ed a938                       lda #>TMS_VRAM_NAME_ADDRESS
   702  e7ef 8525                       sta TMS_TMP_ADDRESS + 1
   703                                  
   704                                  ; this can be better. rotate and save, perhaps
   705                          
   706  e7f1 98                         tya
   707  e7f2 4a4a4a                     +div8
   708  e7f5 18                         clc
   709  e7f6 6525                       adc TMS_TMP_ADDRESS + 1
   710  e7f8 8525                       sta TMS_TMP_ADDRESS + 1
   711  e7fa 98                         tya
   712  e7fb 2907                       and #$07
   713  e7fd 0a0a0a0a0a                 +mul32
   714  e802 8524                       sta TMS_TMP_ADDRESS
   715  e804 8a                         txa
   716  e805 0524                       ora TMS_TMP_ADDRESS
   717  e807 8524                       sta TMS_TMP_ADDRESS
   718  e809 60                         rts
   719                          
   720                          ; -----------------------------------------------------------------------------
   721                          ; tmsSetPosTmpAddressText: Set TMS_TMP_ADDRESS for a given text position
   722                          ; -----------------------------------------------------------------------------
   723                          ; Inputs:
   724                          ;   X: X position (0 - 39)
   725                          ;   Y: Y position (0 - 23)
   726                          ; -----------------------------------------------------------------------------
   727                          tmsSetPosTmpAddressText:
   728  e80a a938                       lda #>TMS_VRAM_NAME_ADDRESS
   729  e80c 8525                       sta TMS_TMP_ADDRESS + 1
   730  e80e a900                       lda #<TMS_VRAM_NAME_ADDRESS
   731  e810 8524                       sta TMS_TMP_ADDRESS
   732                          
   733                          .tmsSetPosTmpAddressTextLoop
   734  e812 c000                       cpy #0
   735  e814 f00e                       beq ++
   736  e816 18                         clc
   737  e817 a524                       lda TMS_TMP_ADDRESS
   738  e819 6928                       adc #40
   739  e81b 8524                       sta TMS_TMP_ADDRESS
   740  e81d 9002                       bcc +
   741  e81f e625                       inc TMS_TMP_ADDRESS + 1
   742                          +
   743  e821 88                         dey
   744  e822 d0ee                       bne .tmsSetPosTmpAddressTextLoop
   745                          ++
   746  e824 18                         clc
   747  e825 8a                         txa
   748  e826 6524                       adc TMS_TMP_ADDRESS
   749  e828 8524                       sta TMS_TMP_ADDRESS
   750  e82a 9002                       bcc +
   751  e82c e625                       inc TMS_TMP_ADDRESS + 1
   752                          +
   753  e82e 60                         rts
   754                          
   755                          
   756                          tmsConsoleScrollLine:
   757  e82f a900                       lda #0
   758  e831 8d2f7b                     sta .TMS9918_TMP_WRITE_ROW
   759  e834 a901                       lda #1
   760  e836 8d2e7b                     sta .TMS9918_TMP_READ_ROW
   761                          .nextRow:
   762                          
   763  e839 ac2e7b                     ldy .TMS9918_TMP_READ_ROW
   764  e83c a200                       ldx #0
   765  e83e a928                       lda #40
   766  e840 cd2a7b                     cmp TMS9918_CONSOLE_SIZE_X
   767  e843 f006                       beq +
   768  e845 20ede7                     jsr tmsSetPosTmpAddress
   769  e848 4c4ee8                     jmp ++
   770                          +
   771  e84b 200ae8                     jsr tmsSetPosTmpAddressText
   772                          ++
   773  e84e 20a8e5                     jsr tmsSetAddressRead
   774                          
   775  e851 207fe8                     jsr .tmsBufferIn
   776                          
   777  e854 a200                       ldx #0
   778  e856 ac2f7b                     ldy .TMS9918_TMP_WRITE_ROW
   779  e859 a200                       ldx #0
   780  e85b a928                       lda #40
   781  e85d cd2a7b                     cmp TMS9918_CONSOLE_SIZE_X
   782  e860 f006                       beq +
   783  e862 20ede7                     jsr tmsSetPosTmpAddress
   784  e865 4c6be8                     jmp ++
   785                          +
   786  e868 200ae8                     jsr tmsSetPosTmpAddressText
   787                          ++
   788  e86b 2092e5                     jsr tmsSetAddressWrite
   789                          
   790  e86e 2091e8                     jsr .tmsBufferOut
   791                          
   792                          
   793  e871 ee2f7b                     inc .TMS9918_TMP_WRITE_ROW
   794  e874 ee2e7b                     inc .TMS9918_TMP_READ_ROW
   795                          
   796  e877 ad2e7b                     lda .TMS9918_TMP_READ_ROW
   797  e87a c919                       cmp #25
   798                          
   799  e87c d0bb                       bne .nextRow
   800                          
   801                          
   802                                  ; copy to buffer 32 bytes at a time, write back  24 rows for gfx, 30 "rows" for text
   803  e87e 60                         rts
   804                          
   805                          .tmsBufferIn:
   806  e87f a200                       ldx #0
   807                          -
   808  e881 ad107f2079e5               +tmsGet
   809  e887 9d307b                     sta TMS9918_TMP_BUFFER, x
   810  e88a e8                         inx
   811  e88b ec2a7b                     cpx TMS9918_CONSOLE_SIZE_X
   812  e88e d0f1                       bne -
   813  e890 60                         rts
   814                          
   815                          .tmsBufferOut:
   816  e891 a200                       ldx #0
   817                          
   818                          -
   819  e893 bd307b                     lda TMS9918_TMP_BUFFER, x
   820  e896 8d107f2079e5               +tmsPut
   821  e89c e8                         inx
   822  e89d ec2a7b                     cpx TMS9918_CONSOLE_SIZE_X
   823  e8a0 d0f1                       bne -
   824  e8a2 60                         rts
   825                          
   826                          ; -----------------------------------------------------------------------------
   827                          ; tmsIncPosConsole: Increment console position
   828                          ; -----------------------------------------------------------------------------
   829                          tmsIncPosConsole:
   830  e8a3 ee287b                     inc TMS9918_CONSOLE_X
   831  e8a6 ad287b                     lda TMS9918_CONSOLE_X
   832  e8a9 cd2a7b                     cmp TMS9918_CONSOLE_SIZE_X
   833  e8ac d008                       bne +
   834  e8ae a900                       lda #0
   835  e8b0 8d287b                     sta TMS9918_CONSOLE_X
   836  e8b3 ee297b                     inc TMS9918_CONSOLE_Y
   837                          +
   838  e8b6 ad297b                     lda TMS9918_CONSOLE_Y
   839  e8b9 c918                       cmp #24
   840  e8bb 9006                       bcc +
   841  e8bd ce297b                     dec TMS9918_CONSOLE_Y
   842  e8c0 4c2fe8                     jmp tmsConsoleScrollLine
   843                          +
   844  e8c3 60                         rts
   845                          
   846                          
   847                          ; -----------------------------------------------------------------------------
   848                          ; tmsDecPosConsole: Increment console position
   849                          ; -----------------------------------------------------------------------------
   850                          tmsDecPosConsole:
   851  e8c4 ce287b                     dec TMS9918_CONSOLE_X
   852  e8c7 1017                       bpl ++
   853  e8c9 ad2a7b                     lda TMS9918_CONSOLE_SIZE_X
   854  e8cc 8d287b                     sta TMS9918_CONSOLE_X
   855  e8cf ce287b                     dec TMS9918_CONSOLE_X
   856  e8d2 a900                       lda #0
   857  e8d4 cd297b                     cmp TMS9918_CONSOLE_Y
   858  e8d7 d004                       bne +
   859  e8d9 8d287b                     sta TMS9918_CONSOLE_X
   860  e8dc 60                         rts        
   861                          +
   862  e8dd ce297b                     dec TMS9918_CONSOLE_Y
   863                          ++
   864  e8e0 60                         rts
   865                          
   866                          
   867                          ; -----------------------------------------------------------------------------
   868                          ; tmsConsoleHome: Set cursor position top left
   869                          ; -----------------------------------------------------------------------------
   870                          tmsConsoleHome:
   871  e8e1 9c287b                     stz TMS9918_CONSOLE_X
   872  e8e4 9c297b                     stz TMS9918_CONSOLE_Y
   873                          
   874                                  ; flow through
   875                          
   876                          ; -----------------------------------------------------------------------------
   877                          ; tmsSetPosConsole: Set cursor position to console position
   878                          ; -----------------------------------------------------------------------------
   879                          tmsSetPosConsole:
   880  e8e7 ae287b                     ldx TMS9918_CONSOLE_X
   881  e8ea ac297b                     ldy TMS9918_CONSOLE_Y
   882                          
   883                                  ; flow through
   884                          
   885                          ; -----------------------------------------------------------------------------
   886                          ; tmsSetPosWrite: Set cursor position
   887                          ; -----------------------------------------------------------------------------
   888                          ; Inputs:
   889                          ;   X: X position (0 - 31)
   890                          ;   Y: Y position (0 - 23)
   891                          ; -----------------------------------------------------------------------------
   892                          tmsSetPosWrite:
   893  e8ed a910                       lda #TMS_R1_MODE_TEXT
   894  e8ef 2c277b                     bit .TMS9918_REG1_SHADOW_ADDR
   895  e8f2 d006                       bne tmsSetPosWriteText
   896  e8f4 20ede7                     jsr tmsSetPosTmpAddress
   897  e8f7 4c92e5                     jmp tmsSetAddressWrite
   898                          
   899                          ; -----------------------------------------------------------------------------
   900                          ; tmsSetPosWrite: Set cursor position (text mode)
   901                          ; -----------------------------------------------------------------------------
   902                          ; Inputs:
   903                          ;   X: X position (0 - 39)
   904                          ;   Y: Y position (0 - 23)
   905                          ; -----------------------------------------------------------------------------
   906                          tmsSetPosWriteText:
   907  e8fa 200ae8                     jsr tmsSetPosTmpAddressText
   908  e8fd 4c92e5                     jmp tmsSetAddressWrite
   909                          
   910                          ; -----------------------------------------------------------------------------
   911                          ; tmsSetPosRead: Set cursor position to read from
   912                          ; -----------------------------------------------------------------------------
   913                          ; Inputs:
   914                          ;   X: X position (0 - 31)
   915                          ;   Y: Y position (0 - 23)
   916                          ; -----------------------------------------------------------------------------
   917                          tmsSetPosRead:
   918  e900 20ede7                     jsr tmsSetPosTmpAddress
   919  e903 4ca8e5                     jmp tmsSetAddressRead
   920                          
   921                          
   922                          ; -----------------------------------------------------------------------------
   923                          ; tmsSetPatternTmpAddress: Set TMS_TMP_ADDRESS for a given pattern definition
   924                          ; -----------------------------------------------------------------------------
   925                          ; Inputs:
   926                          ;   A: Pattern number
   927                          ;   Y: Y offset (row) in the pattern
   928                          ; -----------------------------------------------------------------------------
   929                          tmsSetPatternTmpAddressBank0:
   930                          tmsSetPatternTmpAddress:
   931  e906 48                         pha
   932  e907 a920                       lda #>TMS_VRAM_PATT_ADDRESS
   933  e909 8525                       sta TMS_TMP_ADDRESS + 1
   934                                  
   935  e90b 68                         pla
   936  e90c 48                         pha
   937                          
   938  e90d 4a4a4a4a4a                 +div32
   939  e912 18                         clc
   940  e913 6525                       adc TMS_TMP_ADDRESS + 1
   941  e915 8525                       sta TMS_TMP_ADDRESS + 1
   942  e917 68                         pla
   943  e918 291f                       and #$1f
   944  e91a 0a0a0a                     +mul8
   945  e91d 8524                       sta TMS_TMP_ADDRESS
   946  e91f 98                         tya
   947  e920 0524                       ora TMS_TMP_ADDRESS
   948  e922 8524                       sta TMS_TMP_ADDRESS
   949  e924 60                         rts
   950                          
   951                          ; -----------------------------------------------------------------------------
   952                          ; tmsSetPatternTmpAddressBank1: Set TMS_TMP_ADDRESS for a given pattern 
   953                          ;                               definition in bank 1 (GFX II)
   954                          ; -----------------------------------------------------------------------------
   955                          ; Inputs:
   956                          ;   A: Pattern number
   957                          ;   Y: Y offset (row) in the pattern
   958                          ; -----------------------------------------------------------------------------
   959                          tmsSetPatternTmpAddressBank1:
   960  e925 2006e9                     jsr tmsSetPatternTmpAddress
   961  e928 a525                       lda TMS_TMP_ADDRESS + 1
   962  e92a 18                         clc
   963  e92b 6908                       adc #8
   964  e92d 8525                       sta TMS_TMP_ADDRESS + 1
   965  e92f 60                         rts
   966                          
   967                          ; -----------------------------------------------------------------------------
   968                          ; tmsSetPatternTmpAddressBank2: Set TMS_TMP_ADDRESS for a given pattern 
   969                          ;                               definition in bank 2 (GFX II)
   970                          ; -----------------------------------------------------------------------------
   971                          ; Inputs:
   972                          ;   A: Pattern number
   973                          ;   Y: Y offset (row) in the pattern
   974                          ; -----------------------------------------------------------------------------
   975                          tmsSetPatternTmpAddressBank2:
   976  e930 2006e9                     jsr tmsSetPatternTmpAddress
   977  e933 a525                       lda TMS_TMP_ADDRESS + 1
   978  e935 18                         clc
   979  e936 6910                       adc #16
   980  e938 8525                       sta TMS_TMP_ADDRESS + 1
   981  e93a 60                         rts        
   982                          
   983                          ; -----------------------------------------------------------------------------
   984                          ; tmsSetPatternWrite: Set pattern definition to write to
   985                          ; -----------------------------------------------------------------------------
   986                          ; Inputs:
   987                          ;   A: Pattern number
   988                          ;   Y: Y offset (row) in the pattern
   989                          ; -----------------------------------------------------------------------------
   990                          tmsSetPatternWrite:
   991  e93b 2006e9                     jsr tmsSetPatternTmpAddress
   992  e93e 4c92e5                     jmp tmsSetAddressWrite
   993                          
   994                          ; -----------------------------------------------------------------------------
   995                          ; tmsSetPatternRead: Set pattern definition to read from
   996                          ; -----------------------------------------------------------------------------
   997                          ; Inputs:
   998                          ;   A: Pattern number
   999                          ;   Y: Y offset (row) in the pattern
  1000                          ; -----------------------------------------------------------------------------
  1001                          tmsSetPatternRead:
  1002  e941 2006e9                     jsr tmsSetPatternTmpAddress
  1003  e944 4ca8e5                     jmp tmsSetAddressRead
  1004                          
  1005                          
  1006                          ; -----------------------------------------------------------------------------
  1007                          ; tmsPrint: Print a null-terminated string
  1008                          ; -----------------------------------------------------------------------------
  1009                          ; Inputs:
  1010                          ;  STR_ADDR: Contains address of null-terminated string
  1011                          ; Prerequisites:
  1012                          ;  TMS address already set using +tmsSetAddressWrite
  1013                          ; -----------------------------------------------------------------------------
  1014                          tmsPrint:
  1015  e947 a000                       ldy #0
  1016                          -
  1017  e949 2079e5                     +tmsWaitData
  1018  e94c b132                       lda (STR_ADDR), y
  1019  e94e f009                       beq +
  1020  e950 8d107f2079e5               +tmsPut 
  1021  e956 c8                         iny
  1022  e957 d0f0                       bne -
  1023                          +
  1024  e959 60                         rts
  1025                          
  1026                          
  1027                          ; -----------------------------------------------------------------------------
  1028                          ; tmsConsoleOut: Print a null-terminated string
  1029                          ; -----------------------------------------------------------------------------
  1030                          ; Inputs:
  1031                          ;  'A': Character to output to console
  1032                          ; -----------------------------------------------------------------------------
  1033                          tmsConsoleOut:
  1034  e95a 8e2c7b                     stx .TMS9918_REGX
  1035  e95d 8c2d7b                     sty .TMS9918_REGY
  1036  e960 08                         php
  1037  e961 78                         sei
  1038  e962 c90d                       cmp #$0d ; enter
  1039  e964 f021                       beq .tmsConsoleNewline
  1040  e966 c90a                       cmp #$0a ; enter
  1041  e968 f01d                       beq .tmsConsoleNewline
  1042                          
  1043  e96a c908                       cmp #$08 ; backspace
  1044  e96c f01f                       beq .tmsConsoleBackspace
  1045                          
  1046  e96e 48                         pha
  1047  e96f 20e7e8                     jsr tmsSetPosConsole
  1048  e972 68                         pla
  1049  e973 8d107f2079e5               +tmsPut
  1050  e979 20a3e8                     jsr tmsIncPosConsole
  1051  e97c ee2b7b                     inc TMS9918_CONSOLE_LINE_LEN
  1052                          
  1053                          .endConsoleOut
  1054  e97f 28                         plp
  1055  e980 ac2d7b                     ldy .TMS9918_REGY
  1056  e983 ae2c7b                     ldx .TMS9918_REGX
  1057  e986 60                         rts
  1058                          
  1059                          .tmsConsoleNewline
  1060  e987 20a3e9                     jsr tmsConsoleNewline
  1061  e98a 4c7fe9                     jmp .endConsoleOut
  1062                          
  1063                          .tmsConsoleBackspace
  1064  e98d 20cae9                     jsr tmsConsoleBackspace
  1065  e990 4c7fe9                     jmp .endConsoleOut
  1066                          
  1067                          
  1068                          ; -----------------------------------------------------------------------------
  1069                          ; tmsConsolePrint: Print a null-terminated string (console mode)
  1070                          ; -----------------------------------------------------------------------------
  1071                          ; Inputs:
  1072                          ;  STR_ADDR: Contains address of null-terminated string
  1073                          ; Prerequisites:
  1074                          ;  TMS address already set using +tmsSetAddressWrite
  1075                          ; -----------------------------------------------------------------------------
  1076                          tmsConsolePrint:
  1077  e993 a000                       ldy #0
  1078                          -
  1079  e995 2079e5                     +tmsWaitData
  1080  e998 b132                       lda (STR_ADDR), y
  1081  e99a f006                       beq +
  1082  e99c 205ae9                     jsr tmsConsoleOut
  1083  e99f c8                         iny
  1084  e9a0 d0f3                       bne -
  1085                          +
  1086  e9a2 60                         rts
  1087                          
  1088                          ; -----------------------------------------------------------------------------
  1089                          ; tmsConsoleNewline: Output a newline to the console (scrolls if on last line)
  1090                          ; -----------------------------------------------------------------------------
  1091                          tmsConsoleNewline:
  1092  e9a3 20e7e8                     jsr tmsSetPosConsole
  1093  e9a6 a9208d107f2079e5           +tmsPut ' '
  1094  e9ae ad287b                     lda TMS9918_CONSOLE_X
  1095  e9b1 d008                       bne +
  1096  e9b3 ad2b7b                     lda TMS9918_CONSOLE_LINE_LEN
  1097  e9b6 f003                       beq +
  1098  e9b8 60                         rts
  1099  e9b9 f000                       beq +
  1100                          +
  1101  e9bb ad2a7b                     lda TMS9918_CONSOLE_SIZE_X
  1102  e9be 8d287b                     sta TMS9918_CONSOLE_X
  1103  e9c1 ce287b                     dec TMS9918_CONSOLE_X
  1104  e9c4 9c2b7b                     stz TMS9918_CONSOLE_LINE_LEN
  1105  e9c7 4ca3e8                     jmp tmsIncPosConsole
  1106                          
  1107                          
  1108                          ; -----------------------------------------------------------------------------
  1109                          ; tmsConsoleBackspace: Output a backspace to the console
  1110                          ; -----------------------------------------------------------------------------
  1111                          tmsConsoleBackspace:
  1112  e9ca 20c4e8                     jsr tmsDecPosConsole
  1113  e9cd a920205ae9                 +tmsConsoleOut ' '
  1114  e9d2 a9208d107f2079e5           +tmsPut ' '
  1115  e9da ce2b7b                     dec TMS9918_CONSOLE_LINE_LEN
  1116  e9dd 4cc4e8                     jmp tmsDecPosConsole

; ******** Source: kernel.asm
   158                          
   159                          }
   160                          
   161                          !ifndef HBC56_DISABLE_SFXMAN {
   162                                  !src "sfx/sfxman.asm"
   163                          }
   164                          
   165                          !ifndef HBC56_DISABLE_LCD {
   166                                  !ifndef LCD_MODEL { LCD_MODEL = 12864 }
   167                                  !src "gfx/bitmap.asm"
   168                                  !src "lcd/lcd.asm"
   169                                  !src "gfx/tilemap.asm"
   170                          }
   171                          
   172                          !ifndef HBC56_DISABLE_UART {

; ******** Source: ../lib\ser\uart.asm
     1                          ; 6502 - MC68B50 UART
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          HAVE_UART = 1
    11                          
    12                          ; -------------------------
    13                          ; Constants
    14                          ; -------------------------
    15                          !ifndef UART_IO_PORT { UART_IO_PORT = $20
    16                                  !warn "UART_IO_PORT not provided. Defaulting to ", UART_IO_PORT
    17                          }
    18                          
    19                          !ifndef UART_ZP_START { UART_ZP_START = $40
    20                                  !warn "UART_ZP_START not provided. Defaulting to ", UART_ZP_START
    21                          }
    22                          
    23                          !ifndef UART_RAM_START { UART_RAM_START = $7c80
    24                                  !warn "UART_RAM_START not provided. Defaulting to ", UART_RAM_START
    25                          }
    26                          
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; Zero page
    30                          ; -----------------------------------------------------------------------------
    31                          UART_RX_BUFFER_HEAD  = UART_ZP_START            ; head of circular buffer
    32                          UART_RX_BUFFER_TAIL  = UART_ZP_START + 1        ; tail of circular buffer
    33                          UART_RX_BUFFER_BYTES = UART_ZP_START + 2        ; bytes in buffer
    34                          UART_RX_FLAGS        = UART_ZP_START + 3        ; flags
    35                          @UART_ZP_END         = UART_ZP_START + 4
    36                          
    37                          !if (.UART_ZP_SIZE < @UART_ZP_END - UART_ZP_START) {
    38                                  !error "UART ZP allocation insufficient. Allocated: ", .UART_ZP_SIZE, " Require: ", (@UART_ZP_END - UART_ZP_START)
    39                          }
    40                          
    41                          ; -----------------------------------------------------------------------------
    42                          ; High RAM
    43                          ; -----------------------------------------------------------------------------
    44                          UART_RX_BUFFER       = UART_RAM_START
    45                          UART_RX_BUFFER_SIZE  = $100
    46                          
    47                          @UART_RAM_END        = UART_RAM_START + UART_RX_BUFFER_SIZE
    48                          
    49                          !if (.UART_RAM_SIZE < @UART_RAM_END - UART_RAM_START) {
    50                                  !error "UART RAM allocation insufficient. Allocated: ", .UART_RAM_SIZE, " Require: ", (@UART_RAM_END - UART_RAM_START)
    51                          }
    52                          
    53                          
    54                          ; IO Ports
    55                          UART_REG      = IO_PORT_BASE_ADDRESS | UART_IO_PORT
    56                          UART_DATA     = IO_PORT_BASE_ADDRESS | UART_IO_PORT | $01
    57                          
    58                          ; -----------------------------------------------------------------------------
    59                          ; Constants
    60                          ; -----------------------------------------------------------------------------
    61                          UART_CTL_MASTER_RESET       = %00000011
    62                          UART_CTL_CLOCK_DIV_16       = %00000001
    63                          UART_CTL_CLOCK_DIV_64       = %00000010
    64                          UART_CTL_WORD_7BIT_EPB_2SB  = %00000000
    65                          UART_CTL_WORD_7BIT_OPB_2SB  = %00000100
    66                          UART_CTL_WORD_7BIT_EPB_1SB  = %00001000
    67                          UART_CTL_WORD_7BIT_OPB_1SB  = %00001100
    68                          UART_CTL_WORD_8BIT_2SB      = %00010000
    69                          UART_CTL_WORD_8BIT_1SB      = %00010100
    70                          UART_CTL_WORD_8BIT_EPAR_1SB = %00011000
    71                          UART_CTL_WORD_8BIT_OPAR_1SB = %00011100
    72                          UART_CTL_RX_INT_ENABLE      = %10000000
    73                          
    74                          UART_STATUS_RX_REG_FULL     = %00000001
    75                          UART_STATUS_TX_REG_EMPTY    = %00000010
    76                          UART_STATUS_CARRIER_DETECT  = %00000100
    77                          UART_STATUS_CLEAR_TO_SEND   = %00001000
    78                          UART_STATUS_FRAMING_ERROR   = %00010000
    79                          UART_STATUS_RCVR_OVERRUN    = %00100000
    80                          UART_STATUS_PARITY_ERROR    = %01000000
    81                          UART_STATUS_IRQ             = %10000000
    82                          
    83                          UART_FLOWCTRL_XON           = $11
    84                          UART_FLOWCTRL_XOFF          = $13
    85                          
    86                          UART_RX_BUFFER_XOFF_SIZE    = 192
    87                          UART_RX_BUFFER_XON_SIZE     = 4
    88                          
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; uartInit: Initialise the UART
    92                          ; -----------------------------------------------------------------------------
    93                          uartInit:
    94  e9e0 a900                       lda #0
    95  e9e2 8528                       sta UART_RX_BUFFER_HEAD
    96  e9e4 8529                       sta UART_RX_BUFFER_TAIL
    97  e9e6 852a                       sta UART_RX_BUFFER_BYTES
    98  e9e8 852b                       sta UART_RX_FLAGS
    99                          
   100  e9ea a903                       lda #UART_CTL_MASTER_RESET
   101  e9ec 8d207f                     sta UART_REG
   102  e9ef ea                         nop
   103  e9f0 ea                         nop
   104                          
   105  e9f1 a992                       lda #(UART_CTL_CLOCK_DIV_64 | UART_CTL_WORD_8BIT_2SB | UART_CTL_RX_INT_ENABLE)
   106  e9f3 8d207f                     sta UART_REG
   107  e9f6 ea                         nop
   108  e9f7 ea                         nop
   109                          
   110  e9f8 2020ea                     jsr uartFlowCtrlXon
   111                          
   112  e9fb 60                         rts
   113                          
   114                          ; -----------------------------------------------------------------------------
   115                          ; uartIrq: Standard UART IRQ handler
   116                          ; -----------------------------------------------------------------------------
   117                          uartIrq:
   118  e9fc a901                       lda #UART_STATUS_RX_REG_FULL
   119  e9fe 2c207f                     bit UART_REG
   120  ea01 f01c                       beq @endFlowControlCheck
   121  ea03 ea                         nop
   122  ea04 ea                         nop
   123                          
   124  ea05 da                         phx
   125  ea06 a628                       ldx UART_RX_BUFFER_HEAD
   126  ea08 ad217f                     lda UART_DATA
   127  ea0b 9d587b                     sta UART_RX_BUFFER, x
   128  ea0e e628                       inc UART_RX_BUFFER_HEAD
   129  ea10 e62a                       inc UART_RX_BUFFER_BYTES
   130  ea12 fa                         plx
   131                          
   132                          @flowControlCheck
   133                                  ; check flow control
   134  ea13 ff2b09                     bbs7 UART_RX_FLAGS, @endFlowControlCheck    ; if already xoff, just leave
   135  ea16 a9c0                       lda #UART_RX_BUFFER_XOFF_SIZE               ; otherwise, should we ask for xoff?
   136  ea18 c52a                       cmp UART_RX_BUFFER_BYTES
   137  ea1a b003                       bcs @endFlowControlCheck                    ; all good
   138  ea1c 202bea                     jsr uartFlowCtrlXoff                        ; stop please.
   139                          
   140                          @endFlowControlCheck
   141  ea1f 60                         rts
   142                          
   143                          ; -----------------------------------------------------------------------------
   144                          ; uartFlowCtrlXon: Allow client to send data
   145                          ; -----------------------------------------------------------------------------
   146                          uartFlowCtrlXon:
   147  ea20 772b                       rmb7 UART_RX_FLAGS        
   148  ea22 a911                       lda #UART_FLOWCTRL_XON
   149  ea24 ea                         nop
   150  ea25 ea                         nop
   151  ea26 ea                         nop
   152  ea27 ea                         nop
   153  ea28 4c61ea                     jmp uartOut
   154                          
   155                          ; -----------------------------------------------------------------------------
   156                          ; uartFlowCtrlXoff: Stop client to sending data
   157                          ; -----------------------------------------------------------------------------
   158                          uartFlowCtrlXoff
   159  ea2b f72b                       smb7 UART_RX_FLAGS
   160  ea2d a913                       lda #UART_FLOWCTRL_XOFF
   161  ea2f ea                         nop
   162  ea30 ea                         nop
   163  ea31 4c67ea                     jmp uartOutNoBsCheck
   164                          
   165                          ; -----------------------------------------------------------------------------
   166                          ; uartInWait: Input a byte from the UART (wait forever)
   167                          ; -----------------------------------------------------------------------------
   168                          ; Outputs:
   169                          ;   A: Value of the buffer
   170                          ; -----------------------------------------------------------------------------
   171                          uartInWait:
   172  ea34 a528                       lda UART_RX_BUFFER_HEAD
   173  ea36 c529                       cmp UART_RX_BUFFER_TAIL
   174  ea38 f0fa                       beq uartInWait
   175  ea3a 08                         php
   176  ea3b 78                         sei
   177  ea3c 8008                       bra .uartIncheckFlowControl
   178                          
   179                          ; -----------------------------------------------------------------------------
   180                          ; uartInNoWait: Input a byte from the UART (don't wait)
   181                          ; -----------------------------------------------------------------------------
   182                          ; Outputs:
   183                          ;   A: Value of the buffer
   184                          ;   C: Set if a byte is read
   185                          ; -----------------------------------------------------------------------------
   186                          uartInNoWait:
   187  ea3e 08                         php
   188  ea3f 78                         sei
   189  ea40 a528                       lda UART_RX_BUFFER_HEAD
   190  ea42 c529                       cmp UART_RX_BUFFER_TAIL
   191  ea44 f018                       beq @noData
   192                          
   193                          .uartIncheckFlowControl
   194                                  ; check flow control
   195  ea46 7f2b09                     bbr7 UART_RX_FLAGS, @readUartValue  ; if already xon, just exit again
   196  ea49 a904                       lda #UART_RX_BUFFER_XON_SIZE        ; otherwise, should we ask for xon?
   197  ea4b c52a                       cmp UART_RX_BUFFER_BYTES
   198  ea4d 9003                       bcc @readUartValue                  ; all good
   199  ea4f 2020ea                     jsr uartFlowCtrlXon                 ; continue sending please.
   200                          
   201                          @readUartValue
   202  ea52 a629                       ldx UART_RX_BUFFER_TAIL
   203  ea54 bd587b                     lda UART_RX_BUFFER, x
   204  ea57 e629                       inc UART_RX_BUFFER_TAIL
   205  ea59 c62a                       dec UART_RX_BUFFER_BYTES
   206  ea5b 28                         plp
   207  ea5c 38                         sec
   208  ea5d 60                         rts
   209                          @noData
   210  ea5e 28                         plp
   211  ea5f 18                         clc
   212  ea60 60                         rts
   213                          
   214                          
   215                          ; -----------------------------------------------------------------------------
   216                          ; uartOut: Output a byte to the UART
   217                          ; -----------------------------------------------------------------------------
   218                          ; Inputs:
   219                          ;   A: Value to output
   220                          ; -----------------------------------------------------------------------------
   221                          uartOut:
   222  ea61 c908                       cmp #$08        ; bs
   223  ea63 d002                       bne uartOutNoBsCheck
   224  ea65 a97f                       lda #$7f        ; del
   225                          uartOutNoBsCheck:
   226  ea67 48                         pha
   227  ea68 a902                       lda #UART_STATUS_TX_REG_EMPTY
   228                          
   229                          @aciaTestSend
   230  ea6a 2c207f                     bit UART_REG
   231  ea6d ea                         nop
   232  ea6e ea                         nop
   233  ea6f d002                       bne +
   234  ea71 80f7                       bra @aciaTestSend
   235                          
   236                          +
   237  ea73 68                         pla
   238  ea74 8d217f                     sta UART_DATA
   239  ea77 60                         rts
   240                          
   241                          
   242                          ; -----------------------------------------------------------------------------
   243                          ; uartOutString: Output a string to the UART
   244                          ; -----------------------------------------------------------------------------
   245                          ; Inputs:
   246                          ;   A: Value to output
   247                          ; -----------------------------------------------------------------------------
   248                          uartOutString:
   249  ea78 a000                       ldy #0
   250                          -
   251  ea7a b132                       lda (STR_ADDR), y
   252  ea7c f006                       beq +
   253  ea7e 2067ea                     jsr uartOutNoBsCheck
   254  ea81 c8                         iny
   255  ea82 d0f6                       bne -
   256                          +
   257  ea84 60                         rts

; ******** Source: kernel.asm
   173                          
   174                          }
   175                          
   176                          !ifndef HBC56_DISABLE_NES {

; ******** Source: ../lib\inp\nes.asm
     1                          ; 6502 NES Controllers - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          !ifndef NES_IO_PORT { NES_IO_PORT = $82
    12                                  !warn "NES_IO_PORT not provided. Defaulting to ", NES_IO_PORT
    13                          }
    14                          
    15                          !ifndef NES_RAM_START { NES_RAM_START = $7ea1
    16                                  !warn "NES_RAM_START not provided. Defaulting to ", NES_RAM_START
    17                          }
    18                          
    19                          ; -------------------------
    20                          ; High RAM
    21                          ; -------------------------
    22                          NES_TMP        = NES_RAM_START
    23                          NES_RAM_SIZE   = 1
    24                          
    25                          
    26                          !if NES_RAM_END < (NES_RAM_START + NES_RAM_SIZE) {
    27                                  !error "NES_RAM requires ",NES_RAM_SIZE," bytes. Allocated ",NES_RAM_END - NES_RAM_START
    28                          }
    29                          
    30                          
    31                          ; IO Ports
    32                          NES1_IO_ADDR     = IO_PORT_BASE_ADDRESS | NES_IO_PORT
    33                          NES2_IO_ADDR     = IO_PORT_BASE_ADDRESS | NES_IO_PORT | $01
    34                          
    35                          
    36                          NES_RIGHT       = %00000001
    37                          NES_LEFT        = %00000010
    38                          NES_DOWN        = %00000100
    39                          NES_UP          = %00001000
    40                          NES_START       = %00010000
    41                          NES_SELECT      = %00100000
    42                          NES_B           = %01000000
    43                          NES_A           = %10000000
    44                          
    45                          ; -----------------------------------------------------------------------------
    46                          ; nesWaitForPress: Wait for a NES button press (either port)
    47                          ; -----------------------------------------------------------------------------
    48                          nesWaitForPress:
    49  ea85 a9ff                       lda #$ff
    50                          @notPressed
    51  ea87 cd827f                     cmp NES1_IO_ADDR
    52  ea8a d005                       bne @pressed
    53  ea8c cd837f                     cmp NES2_IO_ADDR
    54  ea8f f0f6                       beq @notPressed
    55                          @pressed
    56  ea91 60                         rts
    57                          
    58                          ; -----------------------------------------------------------------------------
    59                          ; nes1Pressed: Is a button pressed?
    60                          ; -----------------------------------------------------------------------------
    61                          ; Inputs:
    62                          ;   A: Button to test
    63                          ; Outputs:
    64                          ;   Carry set if pressed, Carry clear if not
    65                          nes1Pressed:
    66  ea92 2c827f                     bit NES1_IO_ADDR
    67  ea95 18                         clc
    68  ea96 d001                       bne +
    69  ea98 38                         sec
    70                          +
    71  ea99 60                         rts
    72                          
    73                          ; -----------------------------------------------------------------------------
    74                          ; nes2Pressed: Is a button pressed?
    75                          ; -----------------------------------------------------------------------------
    76                          ; Inputs:
    77                          ;   A: Button to test
    78                          ; Outputs:
    79                          ;   Carry set if pressed, Carry clear if not
    80                          nes2Pressed:
    81  ea9a 2c837f                     bit NES2_IO_ADDR
    82  ea9d 18                         clc
    83  ea9e d001                       bne +
    84  eaa0 38                         sec
    85                          +
    86  eaa1 60                         rts
    87                          
    88                          
    89                          
    90                          

; ******** Source: kernel.asm
   177                          
   178                          }
   179                          
   180                          !ifndef HBC56_DISABLE_KEYBOARD {

; ******** Source: ../lib\inp\keyboard.asm
     1                          ; 6502 KB Controller - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github@com/visrealm/hbc-56
     8                          ;
     9                          
    10                          !ifndef HAVE_MATH_INC { !src "ut/math.inc" }
    11                          
    12                          HAVE_KEYBOARD = 1
    13                          
    14                          ; -------------------------
    15                          ; Constants
    16                          ; -------------------------
    17                          !ifndef KB_IO_PORT { KB_IO_PORT = $80
    18                                  !warn "KB_IO_PORT not provided@ Defaulting to ", KB_IO_PORT
    19                          }
    20                          
    21                          !ifndef KB_RAM_START { KB_RAM_START = $7ea1
    22                                  !warn "KB_RAM_START not provided@ Defaulting to ", KB_RAM_START
    23                          }
    24                          
    25                          ; -------------------------
    26                          ; High RAM
    27                          ; -------------------------
    28                          KB_FLAGS          = KB_RAM_START
    29                          KB_TMP_X          = KB_RAM_START + 1
    30                          KB_TMP_Y          = KB_RAM_START + 2
    31                          KB_CB_PRESSED     = KB_RAM_START + 3
    32                          KB_CB_RELEASED    = KB_RAM_START + 5
    33                          KB_CURRENT_STATE  = KB_RAM_START + 7
    34                          KB_BUFFER_HEAD    = KB_RAM_START + 8         ; head of circular buffer
    35                          KB_BUFFER_TAIL    = KB_RAM_START + 9         ; tail of circular buffer
    36                          KB_BUFFER         = KB_RAM_START + 10
    37                          KB_BUFFER_SIZE    = (1 << 4)
    38                          KB_BUFFER_MASK    = KB_BUFFER_SIZE - 1
    39                          KB_PRESSED_MAP    = KB_BUFFER + KB_BUFFER_SIZE
    40                          
    41                          KB_PRESSED_MAP_SIZE = $fd + 1
    42                          KB_PRESSED_MAP_BYTES = 32
    43                          
    44                          KB_RAM_SIZE     = (KB_PRESSED_MAP + KB_PRESSED_MAP_BYTES) - KB_RAM_START
    45                          
    46                          
    47                          !if KB_RAM_END < (KB_RAM_START + KB_RAM_SIZE) {
    48                                  !error "KB_RAM requires ",KB_RAM_SIZE," bytes@ Allocated ",KB_RAM_END - KB_RAM_START
    49                          }
    50                          
    51                          ; -------------------------
    52                          ; Contants
    53                          ; -------------------------
    54                          KB_SHIFT_DOWN   = %00000001
    55                          KB_CTRL_DOWN    = %00000010
    56                          KB_ALT_DOWN     = %00000100
    57                          KB_CAPS_LOCK    = %00001000
    58                          KB_NUM_LOCK     = %00010000
    59                          
    60                          KB_RELEASE      = $f0
    61                          KB_EXT_KEY      = $e0
    62                          KB_PAUSE_KEY    = $e1
    63                          
    64                          KB_SCANCODE_0 = $45
    65                          KB_SCANCODE_1 = $16
    66                          KB_SCANCODE_2 = $1E
    67                          KB_SCANCODE_3 = $26
    68                          KB_SCANCODE_4 = $25
    69                          KB_SCANCODE_5 = $2E
    70                          KB_SCANCODE_6 = $36
    71                          KB_SCANCODE_7 = $3D
    72                          KB_SCANCODE_8 = $3E
    73                          KB_SCANCODE_9 = $46
    74                          KB_SCANCODE_A = $1C
    75                          KB_SCANCODE_B = $32
    76                          KB_SCANCODE_C = $21
    77                          KB_SCANCODE_D = $23
    78                          KB_SCANCODE_E = $24
    79                          KB_SCANCODE_F = $2B
    80                          KB_SCANCODE_G = $34
    81                          KB_SCANCODE_H = $33
    82                          KB_SCANCODE_I = $43
    83                          KB_SCANCODE_J = $3B
    84                          KB_SCANCODE_K = $42
    85                          KB_SCANCODE_L = $4B
    86                          KB_SCANCODE_M = $3A
    87                          KB_SCANCODE_N = $31
    88                          KB_SCANCODE_O = $44
    89                          KB_SCANCODE_P = $4D
    90                          KB_SCANCODE_Q = $15
    91                          KB_SCANCODE_R = $2D
    92                          KB_SCANCODE_S = $1B
    93                          KB_SCANCODE_T = $2C
    94                          KB_SCANCODE_U = $3C
    95                          KB_SCANCODE_V = $2A
    96                          KB_SCANCODE_W = $1D
    97                          KB_SCANCODE_X = $22
    98                          KB_SCANCODE_Y = $35
    99                          KB_SCANCODE_Z = $1A
   100                          KB_SCANCODE_F1 = $05
   101                          KB_SCANCODE_F2 = $06
   102                          KB_SCANCODE_F3 = $04
   103                          KB_SCANCODE_F4 = $0C
   104                          KB_SCANCODE_F5 = $03
   105                          KB_SCANCODE_F6 = $0B
   106                          KB_SCANCODE_F7 = $83
   107                          KB_SCANCODE_F8 = $0A
   108                          KB_SCANCODE_F9 = $01
   109                          KB_SCANCODE_F10 = $09
   110                          KB_SCANCODE_F11 = $78
   111                          KB_SCANCODE_F12 = $07
   112                          KB_SCANCODE_NUMPAD_0 = $70
   113                          KB_SCANCODE_NUMPAD_1 = $69
   114                          KB_SCANCODE_NUMPAD_2 = $72
   115                          KB_SCANCODE_NUMPAD_3 = $7A
   116                          KB_SCANCODE_NUMPAD_4 = $6B
   117                          KB_SCANCODE_NUMPAD_5 = $73
   118                          KB_SCANCODE_NUMPAD_6 = $74
   119                          KB_SCANCODE_NUMPAD_7 = $6C
   120                          KB_SCANCODE_NUMPAD_8 = $75
   121                          KB_SCANCODE_NUMPAD_9 = $7D
   122                          KB_SCANCODE_NUMPAD_DIVIDE = $CA
   123                          KB_SCANCODE_NUMPAD_ENTER = $DA
   124                          KB_SCANCODE_NUMPAD_MINUS = $7B
   125                          KB_SCANCODE_NUMPAD_MULTIPLY = $7C
   126                          KB_SCANCODE_NUMPAD_PERIOD = $71
   127                          KB_SCANCODE_NUMPAD_PLUS = $79
   128                          KB_SCANCODE_NUM_LOCK = $77
   129                          KB_SCANCODE_ALT_LEFT = $11
   130                          KB_SCANCODE_ALT_RIGHT_ = $91
   131                          KB_SCANCODE_APOS = $52
   132                          KB_SCANCODE_ARROW_DOWN = $F2
   133                          KB_SCANCODE_ARROW_LEFT = $EB
   134                          KB_SCANCODE_ARROW_RIGHT = $F4
   135                          KB_SCANCODE_ARROW_UP = $F5
   136                          KB_SCANCODE_BACKSPACE = $66
   137                          KB_SCANCODE_CAPS_LOCK = $58
   138                          KB_SCANCODE_COMMA = $41
   139                          KB_SCANCODE_CTRL_LEFT = $14
   140                          KB_SCANCODE_CTRL_RIGHT = $94
   141                          KB_SCANCODE_DELETE = $F1
   142                          KB_SCANCODE_END = $E9
   143                          KB_SCANCODE_ENTER = $5A
   144                          KB_SCANCODE_EQUAL = $55
   145                          KB_SCANCODE_ESC = $76
   146                          KB_SCANCODE_HOME = $EC
   147                          KB_SCANCODE_INSERT = $F0
   148                          KB_SCANCODE_MENU = $AF
   149                          KB_SCANCODE_MINUS = $4E
   150                          KB_SCANCODE_PAGE_DOWN = $FA
   151                          KB_SCANCODE_PAGE_UP = $FD
   152                          KB_SCANCODE_PAUSE = $E1
   153                          KB_SCANCODE_PERIOD = $49
   154                          KB_SCANCODE_PRTSCR = $92
   155                          KB_SCANCODE_SCROLL_LOCK = $7E
   156                          KB_SCANCODE_SEMICOLON = $4C
   157                          KB_SCANCODE_SHIFT_LEFT = $12
   158                          KB_SCANCODE_SHIFT_RIGHT = $59
   159                          KB_SCANCODE_SLASH_BACK = $5D
   160                          KB_SCANCODE_SLASH_FORWARD = $4A
   161                          KB_SCANCODE_SPACEBAR = $29
   162                          KB_SCANCODE_SQUARE_LEFT = $54
   163                          KB_SCANCODE_SQUARE_RIGHT = $5B
   164                          KB_SCANCODE_TAB = $0D
   165                          KB_SCANCODE_TILDE = $0E
   166                          KB_SCANCODE_WINDOWS_LEFT = $9F
   167                          KB_SCANCODE_WINDOWS_RIGHT = $A7
   168                          
   169                          
   170                          KB_SHIFT_LEFT_MAP_BYTE = KB_SCANCODE_SHIFT_LEFT >> 3
   171                          KB_SHIFT_LEFT_MAP_BIT  = $80 >> (KB_SCANCODE_SHIFT_LEFT & $07)
   172                          
   173                          KB_SHIFT_RIGHT_MAP_BYTE = KB_SCANCODE_SHIFT_RIGHT >> 3
   174                          KB_SHIFT_RIGHT_MAP_BIT  = $80 >> (KB_SCANCODE_SHIFT_RIGHT & $07)
   175                          
   176                          
   177                          ; IO Ports
   178                          KB_IO_ADDR         = IO_PORT_BASE_ADDRESS | KB_IO_PORT
   179                          KB_STATUS_ADDR     = IO_PORT_BASE_ADDRESS | KB_IO_PORT | $01
   180                          
   181                          ; -----------------------------------------------------------------------------
   182                          ; kbInit: Initialise the keyboard
   183                          ; -----------------------------------------------------------------------------
   184                          kbInit:
   185  eaa2 a900                       lda #$00
   186  eaa4 8d5c7c                     sta KB_FLAGS
   187                          
   188  eaa7 a210                       ldx #16 ;buffer size
   189                                  
   190                                  ; ensure the hardware keyboard buffer is clear
   191                          -
   192  eaa9 8e5d7c                     stx KB_TMP_X
   193  eaac 205deb                     jsr .kbReadByte
   194  eaaf ae5d7c                     ldx KB_TMP_X
   195  eab2 ca                         dex
   196  eab3 d0f4                       bne -
   197                          
   198  eab5 a220a900ca9d767c...        +memset KB_PRESSED_MAP, 0, KB_PRESSED_MAP_BYTES
   199                          
   200  eac1 9c647c                     stz KB_BUFFER_HEAD
   201  eac4 9c657c                     stz KB_BUFFER_TAIL
   202                          
   203  eac7 a900                       lda #.KB_STATE_DEFAULT
   204  eac9 8d637c                     sta KB_CURRENT_STATE
   205                          
   206                                  ; flow through
   207                          
   208                          kbResetCallbacks:
   209  eacc a9dc                       lda #<.kbDummyCb
   210  eace 8d5f7c                     sta KB_CB_PRESSED
   211  ead1 8d617c                     sta KB_CB_RELEASED
   212                                  
   213  ead4 a9ea                       lda #>.kbDummyCb
   214  ead6 8d607c                     sta KB_CB_PRESSED + 1
   215  ead9 8d627c                     sta KB_CB_RELEASED + 1
   216                          
   217                                  ; flow through
   218                          
   219                          .kbDummyCb:
   220  eadc 60                         rts
   221                          
   222                          ; -----------------------------------------------------------------------------
   223                          ; kbIntHandler: Standard keyboard interrupt handler
   224                          ; -----------------------------------------------------------------------------
   225                          kbIntHandler:
   226  eadd 205deb                     jsr .kbReadByte
   227  eae0 e000                       cpx #0
   228  eae2 f0f8                       beq .kbDummyCb
   229                          
   230  eae4 8a                         txa     ; acc now holds scancode
   231                          
   232  eae5 ae637c                     ldx KB_CURRENT_STATE
   233                          
   234  eae8 7cebea                     jmp (.kbStateHandlers, x)
   235                          
   236                          .KB_STATE_DEFAULT          = 0
   237                          .KB_STATE_RELEASE          = 2
   238                          .KB_STATE_EXTENDED         = 4
   239                          .KB_STATE_EXTENDED_RELEASE = 6
   240                          .KB_STATE_PAUSE_SEQ        = 8
   241                          
   242                          .kbStateHandlers:
   243  eaeb f5ea1beb28eb19eb...!word .stdKeyHandler, .relKeyHandler, .extKeyHandler, .extRelKeyHandler, .pauseKeyHandler
   244                          
   245                          ; default scancode handler
   246                          .stdKeyHandler
   247  eaf5 c9f0                       cmp #KB_RELEASE
   248  eaf7 d006                       bne +
   249  eaf9 a902                       lda #.KB_STATE_RELEASE
   250  eafb 8d637c                     sta KB_CURRENT_STATE
   251  eafe 60                         rts
   252                          +
   253  eaff c9e0                       cmp #KB_EXT_KEY
   254  eb01 d006                       bne +
   255  eb03 a904                       lda #.KB_STATE_EXTENDED
   256  eb05 8d637c                     sta KB_CURRENT_STATE
   257  eb08 60                         rts
   258                          +
   259  eb09 c9e1                       cmp #KB_PAUSE_KEY
   260  eb0b d006                       bne +
   261  eb0d a908                       lda #.KB_STATE_PAUSE_SEQ
   262  eb0f 8d637c                     sta KB_CURRENT_STATE
   263  eb12 60                         rts
   264                          +
   265                                  ; a regular key was pressed 
   266                                  ; TODO: bit field rather than a byte per key?
   267  eb13 206feb                     jsr .kbSetKey
   268                          
   269  eb16 6c5f7c                     jmp (KB_CB_PRESSED)
   270                                  ; subroutine returns above
   271                          
   272                          ; extended release scancode handler
   273                          .extRelKeyHandler:
   274  eb19 0980                       ora #$80
   275                                  ; flow through
   276                          
   277                          ;  release scancode handler
   278                          .relKeyHandler:
   279  eb1b aa                         tax
   280  eb1c 20a4eb                     jsr .kbClearKey
   281                          
   282  eb1f a900                       lda #.KB_STATE_DEFAULT
   283  eb21 8d637c                     sta KB_CURRENT_STATE
   284  eb24 8a                         txa
   285                          
   286  eb25 6c617c                     jmp (KB_CB_RELEASED)
   287                          
   288                          ; extended scancode handler
   289                          .extKeyHandler:
   290  eb28 c9f0                       cmp #KB_RELEASE
   291  eb2a d006                       bne +
   292  eb2c a906                       lda #.KB_STATE_EXTENDED_RELEASE
   293  eb2e 8d637c                     sta KB_CURRENT_STATE
   294  eb31 60                         rts
   295                          +
   296  eb32 0980                       ora #$80
   297                                  
   298  eb34 206feb                     jsr .kbSetKey
   299                          
   300  eb37 a900                       lda #.KB_STATE_DEFAULT
   301  eb39 8d637c                     sta KB_CURRENT_STATE
   302  eb3c 8a                         txa
   303                          
   304  eb3d 6c5f7c                     jmp (KB_CB_PRESSED)
   305                          
   306                          ; pause/break sequence scancode handler
   307                          .pauseKeyHandler:
   308  eb40 c977                       cmp #$77
   309  eb42 d018                       bne @notLastByte
   310  eb44 aa                         tax
   311  eb45 ad577d                     lda KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   312  eb48 d006                       bne +
   313  eb4a 8e577d                     stx KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   314  eb4d 6c5f7c                     jmp (KB_CB_PRESSED)
   315                          +
   316  eb50 9c577d                     stz KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   317                          
   318  eb53 a900                       lda #.KB_STATE_DEFAULT
   319  eb55 8d637c                     sta KB_CURRENT_STATE
   320  eb58 8a                         txa
   321                          
   322  eb59 6c617c                     jmp (KB_CB_RELEASED)
   323                          
   324                          @notLastByte
   325  eb5c 60                         rts
   326                          
   327                          ; -----------------------------------------------------------------------------
   328                          ; Outputs:
   329                          ;   A: Value of the KB Status (0 if no key)
   330                          ;   X: PS/2 Scancode byte
   331                          ; -----------------------------------------------------------------------------
   332                          .kbReadByte:        
   333  eb5d a200                       ldx #0
   334  eb5f a904                       lda #$04
   335  eb61 2c817f                     bit KB_STATUS_ADDR
   336  eb64 f008                       beq @end
   337                          
   338  eb66 a020                       ldy #32         ; TODO: this could probably be smaller
   339                          -
   340  eb68 88                         dey
   341  eb69 d0fd                       bne -
   342                          
   343  eb6b ae807f                     ldx KB_IO_ADDR
   344                          @end
   345  eb6e 60                         rts
   346                          
   347                          
   348                          ; -----------------------------------------------------------------------------
   349                          ; .kbSetKey: Set a key is pressed in KB_PRESSED_MAP
   350                          ; Inputs:
   351                          ;    A - scancode
   352                          ; -----------------------------------------------------------------------------
   353                          .kbSetKey:
   354  eb6f ae647c                     ldx KB_BUFFER_HEAD      ; store at head of buffer
   355  eb72 9d667c                     sta KB_BUFFER, x
   356                          
   357  eb75 8d5d7c                     sta KB_TMP_X            ; find byte in map
   358  eb78 4a4a4a                     +lsr3
   359  eb7b aa                         tax
   360  eb7c ad5d7c                     lda KB_TMP_X
   361  eb7f 2907                       and #$07
   362  eb81 a8                         tay
   363  eb82 bd767c                     lda KB_PRESSED_MAP, x
   364  eb85 1930e1                     ora tableBitFromLeft, y ; set bit in map byte
   365  eb88 9d767c                     sta KB_PRESSED_MAP, x   ; update map
   366                          
   367                                  ; check for toggle keys
   368  eb8b ae5d7c                     ldx KB_TMP_X
   369  eb8e e058                       cpx #KB_SCANCODE_CAPS_LOCK
   370  eb90 d008                       bne +
   371  eb92 a908                       lda #KB_CAPS_LOCK
   372  eb94 4d5c7c                     eor KB_FLAGS
   373  eb97 8d5c7c                     sta KB_FLAGS
   374                          +
   375                          
   376  eb9a ad647c                     lda KB_BUFFER_HEAD      ; increment (and mask) buffer head
   377  eb9d 1a                         inc
   378  eb9e 290f                       and #KB_BUFFER_MASK
   379  eba0 8d647c                     sta KB_BUFFER_HEAD
   380  eba3 60                         rts
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; .kbClearKey: Clear a key is pressed in KB_PRESSED_MAP
   384                          ; Inputs:
   385                          ;    A - scancode
   386                          ; -----------------------------------------------------------------------------
   387                          .kbClearKey:
   388  eba4 8d5d7c                     sta KB_TMP_X
   389  eba7 4a4a4a                     +lsr3
   390  ebaa aa                         tax
   391  ebab ad5d7c                     lda KB_TMP_X
   392  ebae 2907                       and #$07
   393  ebb0 a8                         tay
   394  ebb1 bd767c                     lda KB_PRESSED_MAP, x
   395  ebb4 3938e1                     and tableInvBitFromLeft, y
   396  ebb7 9d767c                     sta KB_PRESSED_MAP, x
   397  ebba 60                         rts
   398                          
   399                          
   400                          ; -----------------------------------------------------------------------------
   401                          ; .kbPopTail: Pop a scancode from the tail of the buffer
   402                          ; Inputs:
   403                          ;    A - scancode
   404                          ; -----------------------------------------------------------------------------
   405                          .kbPopTail:
   406  ebbb ad657c                     lda KB_BUFFER_TAIL
   407  ebbe aa                         tax
   408  ebbf 1a                         inc
   409  ebc0 290f                       and #KB_BUFFER_MASK
   410  ebc2 8d657c                     sta KB_BUFFER_TAIL
   411  ebc5 bd667c                     lda KB_BUFFER, x
   412  ebc8 60                         rts
   413                          
   414                          ; -----------------------------------------------------------------------------
   415                          ; kbIsPressed: Is a key pressed right now?
   416                          ; Inputs:
   417                          ;    X - scancode
   418                          ; Returns:
   419                          ;    Z - clear if pressed, set if not pressed
   420                          ; -----------------------------------------------------------------------------
   421                          kbIsPressed:
   422  ebc9 08                         php
   423  ebca 78                         sei
   424  ebcb 8e5d7c                     stx KB_TMP_X
   425  ebce 8a                         txa
   426  ebcf 4a4a4a                     +lsr3
   427  ebd2 aa                         tax
   428  ebd3 ad5d7c                     lda KB_TMP_X
   429  ebd6 2907                       and #$07
   430  ebd8 a8                         tay
   431  ebd9 b930e1                     lda tableBitFromLeft, y
   432  ebdc 3d767c                     and KB_PRESSED_MAP, x
   433  ebdf ae5d7c                     ldx KB_TMP_X
   434  ebe2 28                         plp
   435  ebe3 c900                       cmp #0
   436  ebe5 60                         rts
   437                          
   438                          
   439                          ; -----------------------------------------------------------------------------
   440                          ; kbWaitForScancode: Wait for a key press
   441                          ; Returns:
   442                          ;    A - scancode
   443                          ; -----------------------------------------------------------------------------
   444                          kbWaitForScancode:
   445  ebe6 08                         php
   446  ebe7 78                         sei        
   447  ebe8 38                         sec
   448  ebe9 ad647c                     lda KB_BUFFER_HEAD
   449  ebec ed657c                     sbc KB_BUFFER_TAIL
   450  ebef 28                         plp
   451  ebf0 c900                       cmp #0
   452  ebf2 f0f2                       beq kbWaitForScancode
   453  ebf4 08                         php
   454  ebf5 78                         sei
   455  ebf6 20bbeb                     jsr .kbPopTail
   456  ebf9 28                         plp
   457  ebfa 60                         rts
   458                          
   459                          ; -----------------------------------------------------------------------------
   460                          ; kbNextScancode: Return the next scancode in the buffer or zero if empty
   461                          ; Returns:
   462                          ;    A - scancode (or zero)
   463                          ; -----------------------------------------------------------------------------
   464                          kbNextScancode:
   465  ebfb 08                         php
   466  ebfc 78                         sei
   467  ebfd ad647c                     lda KB_BUFFER_HEAD
   468  ec00 cd657c                     cmp KB_BUFFER_TAIL
   469  ec03 f007                       beq @noScancode
   470  ec05 20bbeb                     jsr .kbPopTail
   471  ec08 28                         plp
   472  ec09 c900                       cmp #0
   473  ec0b 60                         rts
   474                          
   475                          @noScancode
   476  ec0c 28                         plp
   477  ec0d a900                       lda #0
   478  ec0f 60                         rts
   479                          
   480                          ; -----------------------------------------------------------------------------
   481                          ; kbScancodeToAscii: Convert a scancode to ascii. shift/caps lock is honoured
   482                          ; Inputs:
   483                          ;    A - scancode (or zero)
   484                          ; Returns:
   485                          ;    A - ascii character
   486                          ;    C - set if valid character in A
   487                          ; -----------------------------------------------------------------------------
   488                          kbScancodeToAscii:
   489  ec10 da                         phx
   490  ec11 8d5d7c                     sta KB_TMP_X
   491  ec14 18                         clc
   492  ec15 1002                       bpl +
   493  ec17 fa                         plx
   494  ec18 60                         rts
   495                          +
   496  ec19 08                         php
   497  ec1a 78                         sei
   498  ec1b a202                       ldx #KB_SHIFT_LEFT_MAP_BYTE
   499  ec1d a920                       lda #KB_SHIFT_LEFT_MAP_BIT
   500  ec1f 3c767c                     bit KB_PRESSED_MAP, x
   501  ec22 f003                       beq +
   502  ec24 38                         sec
   503  ec25 800a                       bra @doneShiftCheck
   504                          +
   505                          
   506  ec27 a20b                       ldx #KB_SHIFT_RIGHT_MAP_BYTE
   507  ec29 a940                       lda #KB_SHIFT_RIGHT_MAP_BIT
   508  ec2b 3c767c                     bit KB_PRESSED_MAP, x
   509  ec2e f001                       beq +
   510  ec30 38                         sec
   511                          +
   512                          
   513                          @doneShiftCheck:
   514  ec31 b008                       bcs @shiftedKeys:
   515  ec33 ae5d7c                     ldx KB_TMP_X
   516  ec36 bd74ec                     lda KEY_MAP, x
   517  ec39 8006                       bra @end
   518                          
   519                          @shiftedKeys:
   520  ec3b ae5d7c                     ldx KB_TMP_X
   521  ec3e bdf4ec                     lda KEY_MAP_SHIFTED, x
   522                          
   523                          @end
   524  ec41 2018e0                     jsr isAlpha
   525  ec44 9014                       bcc @afterAlphaCheck
   526  ec46 8d5d7c                     sta KB_TMP_X
   527  ec49 a908                       lda #KB_CAPS_LOCK
   528  ec4b 2d5c7c                     and KB_FLAGS
   529  ec4e f007                       beq +
   530  ec50 ad5d7c                     lda KB_TMP_X
   531  ec53 4920                       eor #$20
   532  ec55 8003                       bra @afterAlphaCheck
   533                          +
   534  ec57 ad5d7c                     lda KB_TMP_X
   535                          @afterAlphaCheck
   536  ec5a 28                         plp
   537  ec5b fa                         plx
   538  ec5c c9ff                       cmp #$ff
   539  ec5e 38                         sec
   540  ec5f d001                       bne +
   541  ec61 18                         clc
   542                          +        
   543  ec62 60                         rts
   544                          
   545                          ; -----------------------------------------------------------------------------
   546                          ; kbReadAscii: Read an ASCII caharacter from the keyboard queue
   547                          ; Returns:
   548                          ;    A - ascii character
   549                          ;    C - set if valid character in A
   550                          ; -----------------------------------------------------------------------------
   551                          kbReadAscii:
   552  ec63 08                         php
   553  ec64 78                         sei
   554  ec65 da                         phx
   555  ec66 20fbeb                     jsr kbNextScancode
   556  ec69 f005                       beq @noKey
   557  ec6b fa                         plx
   558  ec6c 28                         plp
   559  ec6d 4c10ec                     jmp kbScancodeToAscii
   560                          @noKey
   561  ec70 fa                         plx
   562  ec71 28                         plp
   563  ec72 18                         clc
   564  ec73 60                         rts
   565                          
   566                          
   567                          KEY_MAP:
   568                          ;      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
   569  ec74 ffffffffffffffff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$09,$60,$ff; 0
   570  ec84 ffffffffff7131ff...!byte $ff,$ff,$ff,$ff,$ff,$71,$31,$ff,$ff,$ff,$7a,$73,$61,$77,$32,$ff; 1
   571  ec94 ff637864653433ff...!byte $ff,$63,$78,$64,$65,$34,$33,$ff,$ff,$20,$76,$66,$74,$72,$35,$ff; 2
   572  eca4 ff6e6268677936ff...!byte $ff,$6e,$62,$68,$67,$79,$36,$ff,$ff,$ff,$6d,$6a,$75,$37,$38,$ff; 3
   573  ecb4 ff2c6b696f3039ff...!byte $ff,$2c,$6b,$69,$6f,$30,$39,$ff,$ff,$2e,$2f,$6c,$3b,$70,$2d,$ff; 4
   574  ecc4 ffff27ff5b3dffff...!byte $ff,$ff,$27,$ff,$5b,$3d,$ff,$ff,$ff,$ff,$0d,$5d,$ff,$5c,$ff,$ff; 5
   575  ecd4 ffffffffffff08ff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$08,$ff,$ff,$31,$ff,$34,$37,$ff,$ff,$ff; 6
   576  ece4 30ff323536381bff...!byte $30,$ff,$32,$35,$36,$38,$1b,$ff,$ff,$ff,$33,$2d,$ff,$39,$ff,$ff; 7
   577                          
   578                          KEY_MAP_SHIFTED:
   579                          ;      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
   580  ecf4 ffffffffffffffff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$09,$7e,$ff; 0
   581  ed04 ffffffffff5121ff...!byte $ff,$ff,$ff,$ff,$ff,$51,$21,$ff,$ff,$ff,$5a,$53,$41,$57,$40,$ff; 1
   582  ed14 ff435844452423ff...!byte $ff,$43,$58,$44,$45,$24,$23,$ff,$ff,$20,$56,$46,$54,$52,$25,$ff; 2
   583  ed24 ff4e424847595eff...!byte $ff,$4e,$42,$48,$47,$59,$5e,$ff,$ff,$ff,$4d,$4a,$55,$26,$2a,$ff; 3
   584  ed34 ff3c4b494f2928ff...!byte $ff,$3c,$4b,$49,$4f,$29,$28,$ff,$ff,$3e,$3f,$4c,$3a,$50,$5f,$ff; 4
   585  ed44 ffff22ff7b2bffff...!byte $ff,$ff,$22,$ff,$7b,$2b,$ff,$ff,$ff,$ff,$0d,$7d,$ff,$7c,$ff,$ff; 5
   586  ed54 ffffffffffff08ff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$08,$ff,$ff,$31,$ff,$34,$37,$ff,$ff,$ff; 6
   587  ed64 30ff323536381bff...!byte $30,$ff,$32,$35,$36,$38,$1b,$ff,$ff,$ff,$33,$2d,$ff,$39,$ff,$ff; 7

; ******** Source: kernel.asm
   181                          
   182                          }
   183                          

; ******** Source: ../lib\io\via.asm
     1                          ; 65(C)22 VIA - HBC-56
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          !ifndef VIA_IO_PORT { VIA_IO_PORT = $f0
    12                                  !warn "VIA_IO_PORT not provided. Defaulting to ", VIA_IO_PORT
    13                          }
    14                          
    15                          !ifndef VIA_RAM_START { VIA_RAM_START = $7d80
    16                                  !warn "VIA_RAM_START not provided. Defaulting to ", VIA_RAM_START
    17                          }
    18                          
    19                          ; -------------------------
    20                          ; High RAM
    21                          ; -------------------------
    22                          VIA_TMP        = VIA_RAM_START
    23                          VIA_RAM_SIZE   = 1
    24                          
    25                          
    26                          !if VIA_RAM_END < (VIA_RAM_START + VIA_RAM_SIZE) {
    27                                  !error "VIA_RAM requires ",VIA_RAM_SIZE," bytes. Allocated ",VIA_RAM_END - VIA_RAM_START
    28                          }
    29                          
    30                          
    31                          VIA_REG_PORT_B  = $00
    32                          VIA_REG_PORT_A  = $01
    33                          VIA_REG_DDR_B   = $02
    34                          VIA_REG_DDR_A   = $03
    35                          VIA_REG_T1C_L   = $04
    36                          VIA_REG_T1C_H   = $05
    37                          VIA_REG_T1L_L   = $06
    38                          VIA_REG_T1L_H   = $07
    39                          VIA_REG_T2C_L   = $08
    40                          VIA_REG_T2C_H   = $09
    41                          VIA_REG_ACR     = $0b
    42                          VIA_REG_IFR     = $0d
    43                          VIA_REG_IER     = $0e
    44                          
    45                          ; IO Ports
    46                          VIA_IO_ADDR     = IO_PORT_BASE_ADDRESS | VIA_IO_PORT
    47                          
    48                          VIA_IO_ADDR_PORT_B      = VIA_IO_ADDR | VIA_REG_PORT_B
    49                          VIA_IO_ADDR_PORT_A      = VIA_IO_ADDR | VIA_REG_PORT_A
    50                          VIA_IO_ADDR_DDR_B       = VIA_IO_ADDR | VIA_REG_DDR_B
    51                          VIA_IO_ADDR_DDR_A       = VIA_IO_ADDR | VIA_REG_DDR_A
    52                          VIA_IO_ADDR_T1C_L       = VIA_IO_ADDR | VIA_REG_T1C_L
    53                          VIA_IO_ADDR_T1C_H       = VIA_IO_ADDR | VIA_REG_T1C_H
    54                          VIA_IO_ADDR_T1L_L       = VIA_IO_ADDR | VIA_REG_T1L_L
    55                          VIA_IO_ADDR_T1L_H       = VIA_IO_ADDR | VIA_REG_T1L_H
    56                          VIA_IO_ADDR_T2C_L       = VIA_IO_ADDR | VIA_REG_T2C_L
    57                          VIA_IO_ADDR_T2C_H       = VIA_IO_ADDR | VIA_REG_T2C_H
    58                          VIA_IO_ADDR_ACR         = VIA_IO_ADDR | VIA_REG_ACR
    59                          VIA_IO_ADDR_IFR         = VIA_IO_ADDR | VIA_REG_IFR
    60                          VIA_IO_ADDR_IER         = VIA_IO_ADDR | VIA_REG_IER
    61                          
    62                          ; Constants
    63                          VIA_DIR_INPUT   = $00
    64                          VIA_DIR_OUTPUT  = $ff
    65                          
    66                          
    67                          
    68                          viaIntHandler:
    69  ed74 6cbb7c                     jmp (HBC56_VIA_CALLBACK)

; ******** Source: kernel.asm
   184                          
   185                          
   186  ed77 6769746875622e63...+hbc56Title "github.com/visrealm/hbc-56"
   187                          

; ******** Source: bootscreen.asm
     1                          ; 6502 - HBC-56 - Memory tests
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; can be anywhere. we own the place at this stage
    12                          LOGO_BUFFER = $3000     
    13                          
    14                          !ifdef HAVE_TMS9918 {
    15                                  HBC56_BORDER     = TMS_DK_BLUE 
    16                                  HBC56_BACKGROUND = TMS_WHITE
    17                                  HBC56_LOGO       = TMS_DK_BLUE 
    18                                  HBC56_TEXT       = TMS_DK_BLUE
    19                          }
    20                          
    21                          !ifdef HBC56_TITLE_TEXT {
    22                                  HBC56_TITLE     = HBC56_TITLE_TEXT
    23                                  HBC56_TITLE_LEN = HBC56_TITLE_TEXT_LEN
    24                          }
    25                          
    26                          .HBC56_PRESS_ANY_KEY_TEXT:
    27  ed92 505245535320414e...        !text "PRESS ANY KEY...",0
    28                          .HBC56_PRESS_ANY_KEY_TEXT_LEN = *-.HBC56_PRESS_ANY_KEY_TEXT-1
    29                          
    30                          .HBC56_PRESS_ANY_NES_TEXT:
    31  eda3 5052455353204120...        !text "PRESS A TO BEGIN...",0
    32                          .HBC56_PRESS_ANY_NES_TEXT_LEN = *-.HBC56_PRESS_ANY_NES_TEXT-1
    33                          
    34                          !ifdef HAVE_GRAPHICS_LCD {
    35                                  !align 255, 0
    36                          hbc56FontLcd:
    37                                  !bin "lcd/fonts/c64-alnum.bin"
    38                          hbc56LogoLcd:
    39                                  !bin "res/hbc56lcd.bin"
    40                          }
    41                          
    42                          !ifdef HAVE_TMS9918 {
    43                          hbc56LogoInd:
    44  edb7 c8c9cacbcccdcecf...        !bin "res/hbc56boot.ind"
    45                          hbc56LogoPatt:
    46  edf9 fefefefefefefefe...        !bin "res/hbc56boot.patt"
    47                          hbc56LogoPattEnd:        
    48                          }
    49                          
    50                          hbc56BootScreen:
    51                          
    52                          !ifdef HAVE_TMS9918 {
    53  ef71 0878a9108d117f20...        +tmsSetAddrColorTable 16
    54  ef84 a94f                       +tmsColorFgBg HBC56_LOGO, HBC56_BACKGROUND
    55  ef86 a202                       ldx #2
    56  ef88 20b2e6                     jsr _tmsSendX8
    57  ef8b a94f                       +tmsColorFgBg HBC56_TEXT, HBC56_BACKGROUND
    58  ef8d a210                       ldx #16
    59  ef8f 2056e7                     jsr tmsInitColorTable
    60                          
    61  ef92 0878a9a58d117f20...        +tmsSetPosWrite 5,5
    62  efa5 a9b78524a9ed8525...        +tmsSendData hbc56LogoInd, 22
    63  efb2 0878a9c58d117f20...        +tmsSetPosWrite 5,6
    64  efc5 a9cd8524a9ed8525...        +tmsSendData hbc56LogoInd + 22, 22
    65  efd2 0878a9e58d117f20...        +tmsSetPosWrite 5,7
    66  efe5 a9e38524a9ed8525...        +tmsSendData hbc56LogoInd + 44, 22
    67                          
    68  eff2 0878a9408d117f20...        +tmsSetAddrPattTable 200
    69  f005 a9f98524a9ed8525...        +tmsSendData hbc56LogoPatt, $178
    70                          
    71  f01b 0878a9c88d117f20...        +tmsPrintZ HBC56_META_TITLE, 8, 14
    72                          
    73                          
    74                                  !ifdef HBC56_TITLE_TEXT {
    75  f039 0878a9c38d117f20...                +tmsPrintZ HBC56_TITLE, (32 - HBC56_TITLE_LEN) / 2, 22
    76                                  }
    77                          
    78  f057 a9e4                       +tmsColorFgBg TMS_GREY, HBC56_BORDER
    79  f059 20cfe5                     jsr tmsSetBackground
    80                          }
    81                          
    82                          !ifdef HAVE_LCD {
    83                                  jsr lcdDetect
    84                                  bcc @noLcd
    85                                  !ifdef HAVE_GRAPHICS_LCD {
    86                                          jsr lcdGraphicsMode
    87                                          +memset LOGO_BUFFER, $00, 1024
    88                                          +memcpy LOGO_BUFFER + 128, hbc56LogoLcd, 256
    89                                          lda #>LOGO_BUFFER
    90                                          sta BITMAP_ADDR_H
    91                                          jsr lcdImage
    92                          
    93                                          +memset LOGO_BUFFER, $0, 128
    94                                          +tilemapCreateDefault (TILEMAP_SIZE_X_16 | TILEMAP_SIZE_Y_8), hbc56FontLcd-(32*8)
    95                                          +memset TILEMAP_DEFAULT_BUFFER_ADDRESS, ' ', 128
    96                          
    97                                          +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*4, HBC56_META_TITLE, 16
    98                          
    99                                          ldy #4
   100                                          jsr tilemapRenderRowToLcd
   101                          
   102                                  } else {
   103                                          !if LCD_ROWS > 2 { +lcdPrint "\n" }
   104                                          !if LCD_COLUMNS > 16 { +lcdPrint "  " }
   105                                          +lcdPrint "     HBC-56\n"
   106                                          !if LCD_COLUMNS > 16 { +lcdPrint "  " }
   107                                          lda #<HBC56_META_TITLE
   108                                          sta STR_ADDR_L
   109                                          lda #>HBC56_META_TITLE
   110                                          sta STR_ADDR_H
   111                                          !if LCD_ROWS = 2 {
   112                                                  jsr lcdLineTwo
   113                                          }                
   114                                          jsr lcdPrint
   115                                          !if LCD_ROWS = 2 {
   116                                                  jsr lcdLineTwo
   117                                          } else {
   118                                                  jsr lcdLineThree
   119                                          }                
   120                                          !if LCD_COLUMNS > 16 { +lcdConsolePrint "  " }
   121                                  }
   122                          @noLcd:
   123                          }
   124  f05c 60                         rts

; ******** Source: kernel.asm
   188                          

; ******** Source: kernel.inc
     1                          ; 6502 - HBC-56 Kernel Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !macro setIntHandler .address {
    12                                  lda #<.address
    13                                  sta HBC56_INT_VECTOR + 1
    14                                  lda #>.address
    15                                  sta HBC56_INT_VECTOR + 2
    16                                  lda #JMP_OPCODE
    17                                  sta HBC56_INT_VECTOR
    18                          }
    19                          
    20                          !macro setNmiHandler .address {
    21                                  lda #<.address
    22                                  sta HBC56_NMI_VECTOR + 1
    23                                  lda #>.address
    24                                  sta HBC56_NMI_VECTOR + 2
    25                                  lda #JMP_OPCODE
    26                                  sta HBC56_NMI_VECTOR
    27                          }
    28                          
    29                          !macro setHbcMetaNES {
    30                                  lda #HBC56_CONSOLE_FLAG_NES
    31                                  ora HBC56_CONSOLE_FLAGS
    32                                  sta HBC56_CONSOLE_FLAGS
    33                          }
    34                          
    35                          !macro setHbcMetaNoWait {
    36                                  lda #HBC56_CONSOLE_FLAG_NOWAIT
    37                                  ora HBC56_CONSOLE_FLAGS
    38                                  sta HBC56_CONSOLE_FLAGS
    39                          }
    40                          
    41                          
    42                          !macro hbc56SetVsyncCallback .vsync {
    43                                  lda #<.vsync
    44                                  sta HBC56_VSYNC_CALLBACK
    45                                  lda #>.vsync
    46                                  sta HBC56_VSYNC_CALLBACK + 1
    47                          }
    48                          
    49                          !macro hbc56SetViaCallback .cb {
    50                                  lda #<.cb
    51                                  sta HBC56_VIA_CALLBACK
    52                                  lda #>.cb
    53                                  sta HBC56_VIA_CALLBACK + 1
    54                          }
    55                          
    56                          
    57                          !macro setHbcMetaTitle .titleStr {
    58                                  jmp .hbcMetaTitleOut
    59                          .titleStrLabel:
    60                                  !text .titleStr
    61                          .titleStrLabelLen = * - .titleStrLabel
    62                                  !byte 0 ; nul terminator for game name
    63                          
    64                          !if .titleStrLabelLen > HBC56_META_TITLE_MAX_LEN {
    65                                  !error "setHbcMetaTitle: Title metadata limited to ",HBC56_META_TITLE_MAX_LEN,"bytes"
    66                          }
    67                          .hbcMetaTitleOut:
    68                                  +memcpy HBC56_META_TITLE + (HBC56_META_TITLE_MAX_LEN-.titleStrLabelLen)/2, .titleStrLabel, .titleStrLabelLen
    69                                  lda #.titleStrLabelLen
    70                                  sta HBC56_META_TITLE_LEN
    71                          }
    72                          
    73                          !macro consoleEnableCursor {
    74                                  lda HBC56_CONSOLE_FLAGS
    75                                  ora #HBC56_CONSOLE_FLAG_CURSOR
    76                                  sta HBC56_CONSOLE_FLAGS
    77                          }
    78                          
    79                          !macro consoleDisableCursor {
    80                                  lda HBC56_CONSOLE_FLAGS
    81                                  and #!HBC56_CONSOLE_FLAG_CURSOR & $ff
    82                                  sta HBC56_CONSOLE_FLAGS
    83                          }
    84                          
    85                          !macro consoleLCDMode {
    86                                  lda HBC56_CONSOLE_FLAGS
    87                                  ora #HBC56_CONSOLE_FLAG_LCD
    88                                  sta HBC56_CONSOLE_FLAGS
    89                          }
    90                          
    91                          !macro setBreakpoint {
    92                                 !byte $db 
    93                          }
    94                          
    95                          !macro hbc56CustomDelay .delay {
    96                                  ldy #.delay
    97                                  jsr hbc56CustomDelay
    98                          }
    99                          
   100                          !macro hbc56DelayUs .us {
   101                          !if .us = 1 {
   102                                  nop
   103                                  nop
   104                          }
   105                          }
   106                          !macro hbc56DelayMs .ms {
   107                                  lda #<.ms
   108                                  sta DELAY_L
   109                                  lda #>.ms
   110                                  sta DELAY_H
   111                          
   112                                  jsr hbc56CustomDelayMs

; ******** Source: kernel.asm
   189                          

; ******** Source: interrupts.asm
     1                          ; 6502 - HBC-56 Kernel Interrupt Handling
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; -------------------------
    12                          ; Interrupts
    13                          ; -------------------------
    14                          TMS9918_IRQ            = 1      ; /INT
    15                          KB_IRQ                 = 2      ; RES1
    16                          UART_IRQ               = 3      ; RES2
    17                          VIA_IRQ                = 5      ; Onboard
    18                          
    19                          TMS9918_IRQ_BIT = (1 << (TMS9918_IRQ - 1))
    20                          KB_IRQ_BIT      = (1 << (KB_IRQ - 1))
    21                          UART_IRQ_BIT    = (1 << (UART_IRQ - 1))
    22                          VIA_IRQ_BIT     = (1 << (VIA_IRQ - 1))
    23                          
    24                          INT_CTRL_ADDRESS    = IO_PORT_BASE_ADDRESS | INT_IO_PORT
    25                          
    26                          ; -----------------------------------------------------------------------------
    27                          ; HBC-56 Interrupt handler
    28                          ; -----------------------------------------------------------------------------
    29                          hbc56IntHandler:
    30  f05d 48                         pha
    31  f05e da                         phx
    32  f05f 5a                         phy
    33                          
    34  f060 addf7f                     lda INT_CTRL_ADDRESS
    35                          
    36                          !ifdef HAVE_UART {
    37  f063 8904                       bit #UART_IRQ_BIT
    38  f065 f005                       beq +
    39  f067 20fce9                     jsr uartIrq        
    40  f06a 801e                       bra @endIntHandler
    41                          +
    42                          }
    43                          
    44                          !ifdef HAVE_TMS9918 {
    45  f06c 8901                       bit #TMS9918_IRQ_BIT
    46  f06e f008                       beq +
    47  f070 208ef0                     jsr hbc56Tms9918Int
    48  f073 2c117f                     +tmsReadStatus
    49  f076 8012                       bra @endIntHandler
    50                          +
    51                          }
    52                          
    53  f078 8910                       bit #VIA_IRQ_BIT
    54  f07a f005                       beq +
    55  f07c 2074ed                     jsr viaIntHandler
    56  f07f 8009                       bra @endIntHandler
    57                          +
    58                          
    59                          !ifdef HAVE_KEYBOARD {
    60  f081 8902                       bit #KB_IRQ_BIT
    61  f083 f005                       beq +
    62  f085 20ddea                     jsr kbIntHandler
    63  f088 8000                       bra @endIntHandler
    64                          +
    65                          }
    66                                  
    67                          @endIntHandler:
    68  f08a 7a                         ply
    69  f08b fa                         plx
    70  f08c 68                         pla      
    71  f08d 40                         rti
    72                          
    73                          
    74                          
    75                          ; -----------------------------------------------------------------------------
    76                          ; HBC-56 TMS9918 VSYNC Interrupt handler
    77                          ; -----------------------------------------------------------------------------
    78                          !ifdef HAVE_TMS9918 {
    79                          hbc56Tms9918Int:
    80                          
    81                                  ; update ticks and seconds
    82  f08e ee9f7c                     inc HBC56_TICKS
    83  f091 ad9f7c                     lda HBC56_TICKS
    84  f094 c93c                       cmp #TMS_FPS
    85  f096 d00d                       bne +
    86  f098 a900                       lda #0
    87  f09a 8d9f7c                     sta HBC56_TICKS
    88  f09d eea07cd003eea17c           +inc16 HBC56_SECONDS_L
    89                          +
    90                                  ; "tick" for sfx manager
    91                                  !ifdef HAVE_SFX_MAN {
    92                                          jsr sfxManTick
    93                                  }
    94                          
    95                                  ; handle console if enabled
    96  f0a5 2ca37c                     bit HBC56_CONSOLE_FLAGS
    97  f0a8 1003                       bpl +
    98  f0aa 20b0f0                     jsr .consoleVsyncCallback
    99                          +
   100                          
   101                                  ; rely on callback rts to return
   102  f0ad 6cb97c                     jmp (HBC56_VSYNC_CALLBACK)
   103                          
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; HBC-56 TMS9918 Console update
   107                          ; -----------------------------------------------------------------------------
   108                          .consoleVsyncCallback:
   109                          
   110  f0b0 ad9f7c                     lda HBC56_TICKS
   111  f0b3 f007                       beq .doCursor
   112  f0b5 c91e                       cmp #30
   113  f0b7 f003                       beq .doCursor
   114  f0b9 4ce3f0                     jmp @endConsoleCallback
   115                          
   116                          .doCursor:
   117  f0bc 8ea47c                     stx HBC56_TMP_X
   118  f0bf 8ca57c                     sty HBC56_TMP_Y
   119  f0c2 20e7e8                     jsr tmsSetPosConsole
   120  f0c5 aea47c                     ldx HBC56_TMP_X
   121  f0c8 aca57c                     ldy HBC56_TMP_Y
   122  f0cb ad9f7c                     lda HBC56_TICKS
   123  f0ce f00b                       beq +
   124  f0d0 a920                       lda #' '
   125  f0d2 8d107f2079e5               +tmsPut
   126  f0d8 4ce3f0                     jmp @endConsoleCallback
   127                          + 
   128  f0db a97f                       lda #$7f
   129  f0dd 8d107f2079e5               +tmsPut
   130                          
   131                          @endConsoleCallback
   132                          
   133                          .nullCallbackFunction:
   134  f0e3 60                         rts
   135                          }

; ******** Source: kernel.asm
   190                          
   191                          
   192                          ; -----------------------------------------------------------------------------
   193                          ; HBC-56 Main entry point (reset vector)
   194                          ; -----------------------------------------------------------------------------
   195                          kernelMain:
   196  f0e4 78                         sei
   197  f0e5 d8                         cld     ; make sure we're not in decimal mode
   198  f0e6 a2ff                       ldx #$ff
   199  f0e8 9a                         txs
   200                                  
   201  f0e9 a940                       lda #RTI_OPCODE
   202  f0eb 8d007e                     sta HBC56_INT_VECTOR
   203  f0ee 8d047e                     sta HBC56_NMI_VECTOR
   204                          
   205  f0f1 a210a920ca9da67c...        +memset HBC56_META_TITLE, ' ', HBC56_META_TITLE_MAX_LEN
   206                          
   207  f0fd a900                       lda #0
   208  f0ff 8d9f7c                     sta HBC56_TICKS
   209  f102 8da07c                     sta HBC56_SECONDS_L
   210  f105 8da17c                     sta HBC56_SECONDS_H
   211  f108 8da37c                     sta HBC56_CONSOLE_FLAGS
   212                          
   213  f10b 8db67c                     sta HBC56_META_TITLE + HBC56_META_TITLE_MAX_LEN
   214                          
   215                          
   216  f10e 20fcdf                     jsr HBC56_META_VECTOR   ; user program metadata
   217                          
   218                                  !ifdef HAVE_KEYBOARD {
   219  f111 20a2ea                             jsr kbInit
   220                                  }
   221                          
   222                                  !ifdef HAVE_AY3891X {
   223  f114 2058e1                             jsr ayInit
   224                                  }
   225                          
   226                                  !ifdef HAVE_SFXMAN {
   227                                          jsr sfxManInit  ; requires TMS interrupts
   228                                  }
   229                          
   230                                  !ifdef HAVE_TMS9918 {
   231  f117 2065e6                             jsr tmsInit
   232                          
   233  f11a a94020efe5                         +tmsDisableOutput
   234                          
   235                                          ; dummy callback
   236  f11f a9e38db97ca9f08d...                +hbc56SetVsyncCallback .nullCallbackFunction
   237                                  }
   238                          
   239  f129 a9e38dbb7ca9f08d...        +hbc56SetViaCallback .nullCallbackFunction
   240                          
   241                                  !ifdef HAVE_LCD {
   242                                          jsr lcdDetect
   243                                          bcc @noLcd1                
   244                                          jsr lcdInit
   245                                          jsr hbc56Delay
   246                                          jsr lcdDisplayOn
   247                                          jsr hbc56Delay
   248                          @noLcd1:
   249                                  }
   250                          
   251  f133 2071ef                     jsr hbc56BootScreen
   252                          
   253  f136 a95d8d017ea9f08d...        +setIntHandler hbc56IntHandler
   254                          
   255                                  !ifdef HAVE_TMS9918 {
   256  f145 a94020e5e5                         +tmsEnableOutput
   257  f14a a92020efe5                         +tmsDisableInterrupts
   258                                  }
   259                          
   260  f14f a914                       lda #20
   261  f151 8da27c                     sta HBC56_TMP
   262                          -
   263  f154 20e1ff                     jsr hbc56Delay
   264  f157 cea27c                     dec HBC56_TMP
   265  f15a d0f8                       bne -
   266                                 
   267                                  !ifdef HAVE_TMS9918 {
   268  f15c a92020e5e5                         +tmsEnableInterrupts
   269                                  }
   270  f161 58                         cli
   271                          
   272  f162 20cdf1                     jsr hbc56HighBell
   273                          
   274  f165 a910                       lda #HBC56_CONSOLE_FLAG_NOWAIT
   275  f167 2ca37c                     bit HBC56_CONSOLE_FLAGS
   276  f16a d050                       bne .afterInput
   277                          
   278  f16c a940                       lda #HBC56_CONSOLE_FLAG_NES
   279  f16e 2da37c                     and HBC56_CONSOLE_FLAGS
   280  f171 f026                       beq .keyboardInput
   281                          
   282                          
   283                                  ; NES input
   284  f173 78                         sei
   285                                  !ifdef HAVE_TMS9918 {
   286  f174 0878a9268d117f20...                +tmsPrintZ .HBC56_PRESS_ANY_NES_TEXT, (32 - .HBC56_PRESS_ANY_NES_TEXT_LEN) / 2, 17
   287                                  }
   288                          
   289                                  !ifdef HAVE_LCD {
   290                                          jsr lcdDetect
   291                                          bcc @noLcd2
   292                                          !ifdef HAVE_GRAPHICS_LCD {
   293                                                  +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*6, .HBC56_PRESS_ANY_NES_TEXT, 16
   294                                                  ldy #6
   295                                                  jsr tilemapRenderRowToLcd
   296                                          } else {
   297                                                  lda #<.HBC56_PRESS_ANY_NES_TEXT
   298                                                  sta STR_ADDR_L
   299                                                  lda #>.HBC56_PRESS_ANY_NES_TEXT
   300                                                  sta STR_ADDR_H
   301                                                  jsr lcdPrint
   302                                          }
   303                          @noLcd2:
   304                                  }
   305  f192 58                         cli
   306  f193 2085ea                     jsr nesWaitForPress
   307  f196 4cbcf1                     jmp .afterInput
   308                          
   309                          .keyboardInput
   310                          !ifdef HAVE_KEYBOARD {
   311                                  ; Keyboard  input
   312  f199 78                         sei
   313                                  !ifdef HAVE_TMS9918 {
   314  f19a 0878a9288d117f20...                +tmsPrintZ .HBC56_PRESS_ANY_KEY_TEXT, (32 - .HBC56_PRESS_ANY_KEY_TEXT_LEN) / 2, 17
   315                                  }
   316                          
   317                                  !ifdef HAVE_LCD {
   318                                          jsr lcdDetect
   319                                          bcc @noLcd3
   320                                          !ifdef HAVE_GRAPHICS_LCD {
   321                                                  +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*6, .HBC56_PRESS_ANY_KEY_TEXT, 16
   322                                                  ldy #6
   323                                                  jsr tilemapRenderRowToLcd
   324                                          } else {
   325                                                  lda #<.HBC56_PRESS_ANY_KEY_TEXT
   326                                                  sta STR_ADDR_L
   327                                                  lda #>.HBC56_PRESS_ANY_KEY_TEXT
   328                                                  sta STR_ADDR_H
   329                                                  jsr lcdPrint        
   330                                          }
   331                          @noLcd3:
   332                                  }
   333  f1b8 58                         cli
   334  f1b9 20e6eb                     jsr kbWaitForScancode
   335                          }
   336                          
   337                          .afterInput
   338                          
   339                                  !ifdef HAVE_LCD {
   340                                          ;jsr lcdDetect
   341                                          ;bcc @noLcd4
   342                                          jsr lcdInit
   343                                          !ifdef HAVE_GRAPHICS_LCD {
   344                                                  jsr lcdTextMode
   345                                          }
   346                                          jsr lcdClear
   347                                          jsr lcdHome
   348                          @noLcd4:
   349                                  }
   350                          
   351                                  !ifdef HAVE_TMS9918 {
   352  f1bc 2039e7                             jsr tmsInitTextTable ; clear output
   353  f1bf a94020efe5                         +tmsDisableOutput
   354  f1c4 a92020efe5                         +tmsDisableInterrupts
   355                                  }
   356                                  ; no interrupts until the user code says so
   357  f1c9 78                         sei
   358                          
   359  f1ca 200080                     jsr DEFAULT_HBC56_RST_VECTOR
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; Beep (higher tone)
   363                          ; -----------------------------------------------------------------------------
   364                          hbc56HighBell:
   365                                  !ifdef HAVE_AY3891X {
   366  f1cd a9078d407fad427f...                +ayToneEnable AY_PSG0, AY_CHC
   367  f1df a90a8d407fa90f8d...                +aySetVolume AY_PSG0, AY_CHC, $ff
   368  f1e9 a9048d407fa9598d...                +ayPlayNote AY_PSG0, AY_CHC, NOTE_FREQ_F5
   369                                  }
   370  f1fd 8032                       bra .noteTimeout
   371                          
   372                          ; -----------------------------------------------------------------------------
   373                          ; Beep (lower tone)
   374                          ; -----------------------------------------------------------------------------
   375                          hbc56Bell:
   376                                  !ifdef HAVE_AY3891X {
   377  f1ff a9078d407fad427f...                +ayToneEnable AY_PSG0, AY_CHC
   378  f211 a90a8d407fa90f8d...                +aySetVolume AY_PSG0, AY_CHC, $ff
   379  f21b a9048d407fa97b8d...                +ayPlayNote AY_PSG0, AY_CHC, NOTE_FREQ_E3
   380                                  }
   381  f22f 8000                       bra .noteTimeout
   382                          
   383                          .noteTimeout
   384                                  !ifdef HAVE_SFXMAN {
   385                                          lda HBC56_CONSOLE_FLAGS
   386                                          and #HBC56_CONSOLE_FLAG_LCD
   387                                          bne @skipSfxMan
   388                                          +sfxManSetChannelTimeout  AY_PSG0, AY_CHC, 0.16
   389                                          rts
   390                                  }
   391                          @skipSfxMan
   392                                  !ifdef HAVE_AY3891X {
   393  f231 20e1ff                             jsr hbc56Delay
   394  f234 20e1ff                             jsr hbc56Delay
   395  f237 a9048d407fa9008d...                +ayStop AY_PSG0, AY_CHC
   396                                  }
   397                          
   398  f24b 60                         rts
   399                          
   400                          ; -----------------------------------------------------------------------------
   401                          ; Software reset
   402                          ; -----------------------------------------------------------------------------
   403                          hbc56Reset:
   404  f24c 4ce4f0                     jmp kernelMain
   405                          
   406                          ; -----------------------------------------------------------------------------
   407                          ; Stop (loop forever)
   408                          ; -----------------------------------------------------------------------------
   409                          hbc56Stop:
   410  f24f 4c4ff2                     jmp hbc56Stop
   411                          
   412                          ; -----------------------------------------------------------------------------
   413                          ; Delay function
   414                          ; -----------------------------------------------------------------------------
   415                          hbc56CustomDelayMs:
   416  f252 e635                       inc DELAY_H
   417                          -
   418  f254 a003                       ldy #3
   419  f256 20e3ff                     jsr hbc56CustomDelay
   420  f259 c634                       dec DELAY_L
   421  f25b d0f7                       bne -
   422  f25d a900                       lda #0
   423  f25f 8534                       sta DELAY_L
   424  f261 c635                       dec DELAY_H
   425  f263 d0ef                       bne -
   426  f265 60                         rts
   427                          
   428                          
   429                          ;!warn "Kernel size: ", *-$f000
