
; ******** Source: tms9918mctest.asm
     1                          ; Troy's HBC-56 - TMS9918 Multicolor mode test
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          

; ******** Source: ../../kernel\hbc56kernel.inc
     1                          ; 6502 - HBC-56 Kernel Include file for user code
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !cpu w65c02
    12                          !initmem $FF
    13                          cputype = $65c02
    14                          

; ******** Source: ../../kernel\kernel.o.lmap
     1                          	HBC56_RST_VECTOR	= $f177	; ?
     2                          	AY_ENV_SHAPE_SAW1	= $8	; unused
     3                          	tmsConsoleBackspace	= $ea63	; ?
     4                          	NES_RAM_SIZE	= $1
     5                          	UART_ZP_START	= $28
     6                          	TMS_LT_RED	= $9	; unused
     7                          	UART_STATUS_RCVR_OVERRUN	= $20	; unused
     8                          	HBC56_TMP	= $7ca2
     9                          	KB_SCANCODE_ESC	= $76	; unused
    10                          	AY_ENV_SHAPE_SAW2	= $c	; unused
    11                          	TMS_GFX_TILE_WIDTH	= $8
    12                          	LCD_RAM_END	= $7b58
    13                          	TMS_SPRITE_SIZE	= $8
    14                          	KB_SCANCODE_ARROW_RIGHT	= $f4	; unused
    15                          	KB_CAPS_LOCK	= $8
    16                          	KB_EXT_KEY	= $e0
    17                          	VIA_RAM_SIZE	= $1
    18                          	HBC56_VSYNC_CALLBACK	= $7cb9
    19                          	isLower	= $e000
    20                          	TMS_R1_SPRITE_MAG2	= $1	; unused
    21                          	KB_BUFFER_MASK	= $f
    22                          	KB_SCANCODE_SLASH_FORWARD	= $4a	; unused
    23                          	AY_PORTB	= $f	; unused
    24                          	TMS_R1_RAM_16K	= $80
    25                          	AY_PORTA	= $e	; unused
    26                          	TMS_R1_SPRITE_MAG1	= $0	; unused
    27                          	TMS_FPS	= $3c
    28                          	kbInit	= $eb3b
    29                          	VIA_TMP	= $7c58	; unused
    30                          	tmsSetAddressNextRow	= $e586	; unused
    31                          	UART_IRQ_BIT	= $4
    32                          	tmsModeText	= $e6b8	; unused
    33                          	VIA_REG_IFR	= $d
    34                          	_tmsSendKb	= $e71b	; ?
    35                          	UART_STATUS_RX_REG_FULL	= $1
    36                          	tmsReg1SetFields	= $e5e5
    37                          	BITMAP_ZP_START	= $1e
    38                          	JMP_OPCODE	= $4c
    39                          	hbc56IntHandler	= $f0f6
    40                          	TILEMAP_RAM_START	= $7a00
    41                          	KB_SCANCODE_SCROLL_LOCK	= $7e	; unused
    42                          	KB_RAM_END	= $7c9c
    43                          	AY_ENV_SHAPE_HOLD	= $1
    44                          	TMS_R0_MODE_GRAPHICS_II	= $2
    45                          	KB_SHIFT_LEFT_MAP_BYTE	= $2
    46                          	VIA_IO_ADDR_IFR	= $7ffd	; unused
    47                          	VIA_IO_ADDR_T1C_H	= $7ff5	; unused
    48                          	MEMORY_ZP_END	= $32
    49                          	TMS_R1_SPRITE_8	= $0	; unused
    50                          	VIA_REG_T1L_H	= $7
    51                          	KB_SCANCODE_PRTSCR	= $92	; unused
    52                          	KB_SCANCODE_SLASH_BACK	= $5d	; unused
    53                          	VIA_IO_ADDR_T1C_L	= $7ff4	; unused
    54                          	AY_WRITE	= $1
    55                          	UART_STATUS_CARRIER_DETECT	= $4	; unused
    56                          	VIA_REG_T1L_L	= $6
    57                          	KB_PRESSED_MAP	= $7c76
    58                          	TMS9918_ZP_START	= $24
    59                          	tmsDecPosConsole	= $e941
    60                          	UART_CTL_WORD_8BIT_1SB	= $14	; unused
    61                          	HBC56_CONSOLE_FLAG_LCD	= $20	; unused
    62                          	TMS_CYAN	= $7
    63                          	HBC56_TITLE	= $ee10
    64                          	memcpyMultiPage	= $e0bf	; unused
    65                          	KB_SCANCODE_NUM_LOCK	= $77	; unused
    66                          	TILEMAP_RAM_END	= $7b16
    67                          	VIA_DIR_OUTPUT	= $ff	; unused
    68                          	KB_BUFFER_TAIL	= $7c65
    69                          	tmsSetRegister	= $e5bc
    70                          	hbc56Tms9918Int	= $f127	; ?
    71                          	KB_SCANCODE_NUMPAD_ENTER	= $da	; unused
    72                          	UART_STATUS_TX_REG_EMPTY	= $2
    73                          	UART_RX_BUFFER_XOFF_SIZE	= $c0
    74                          	KB_FLAGS	= $7c5c
    75                          	HBC56_NMI_VECTOR	= $7e04
    76                          	KB_SCANCODE_SQUARE_LEFT	= $54	; unused
    77                          	BITMAP_ZP_END	= $24
    78                          	UART_CTL_CLOCK_DIV_64	= $2
    79                          	toUpper	= $e06b	; unused
    80                          	VIA_IO_ADDR	= $7ff0
    81                          	tableBitsFromLeft	= $e150	; unused
    82                          	NES_TMP	= $7c9c	; unused
    83                          	HBC56_META_TITLE_END	= $7cb7
    84                          	uartFlowCtrlXoff	= $eac4	; ?
    85                          	SFXMAN_RAM_START	= $7c59
    86                          	uartInWait	= $eacd
    87                          	uartOutString	= $eb11	; unused
    88                          	RTI_OPCODE	= $40
    89                          	KB_SCANCODE_PAGE_UP	= $fd	; unused
    90                          	AY_ENV_SHAPE_FADE_OUT	= $9	; unused
    91                          	tmsModeBitmap	= $e623	; unused
    92                          	TMS_VRAM_SPRITE_ATTR_ADDRESS	= $3b00
    93                          	NOTE_FREQ_AS8	= 7458.619999999999890860635787248611	; unused
    94                          	HBC56_TMP_Y	= $7ca5
    95                          	KB_SCANCODE_TILDE	= $e	; unused
    96                          	HBC56_TITLE_LEN	= $1a
    97                          	UART_IO_PORT	= $20
    98                          	TMS9918_RAM_END	= $7b58
    99                          	AY_S0_ADDR	= $7f40	; unused
   100                          	TMS9918_ZP_SIZE	= $2
   101                          	HBC56_TMP_X	= $7ca4
   102                          	NOTE_FREQ_AS5	= 932.330000000000040927261579781771	; unused
   103                          	TMS_MED_GREEN	= $2	; unused
   104                          	TMS_WHITE	= $f
   105                          	KB_SCANCODE_WINDOWS_RIGHT	= $a7	; unused
   106                          	HBC56_KERNEL_ZP_END	= $36
   107                          	AY_S1_WRITE	= $7f45	; unused
   108                          	NOTE_FREQ_AS4	= 466.160000000000025011104298755527	; unused
   109                          	VIA_REG_DDR_B	= $2
   110                          	NOTE_FREQ_AS7	= 3729.309999999999945430317893624306	; unused
   111                          	TMS_TMP_ADDRESS	= $24
   112                          	KB_SCANCODE_PERIOD	= $49	; unused
   113                          	VIA_REG_DDR_A	= $3
   114                          	tableBitFromLeft	= $e130
   115                          	NOTE_FREQ_AS6	= 1864.660000000000081854523159563541	; unused
   116                          	AY_NOISE_GEN	= $6	; unused
   117                          	NOTE_FREQ_AS1	= 58.270000000000003126388037344441	; unused
   118                          	AY_S0_WRITE	= $7f41	; unused
   119                          	NOTE_FREQ_AS0	= 29.140000000000000568434188608080	; unused
   120                          	tmsSetAddressRead	= $e5a8
   121                          	VIA_RAM_START	= $7c58
   122                          	NOTE_FREQ_AS3	= 233.080000000000012505552149377763	; unused
   123                          	UART_RX_BUFFER_TAIL	= $29
   124                          	tmsSetPatternRead	= $e9dc	; unused
   125                          	AY_S1_ADDR	= $7f44	; unused
   126                          	NOTE_FREQ_AS2	= 116.540000000000006252776074688882	; unused
   127                          	UART_RX_BUFFER	= $7b58
   128                          	TMS_R1_SPRITE_16	= $2	; unused
   129                          	TMS_GFX_PIXELS_Y	= $c0	; unused
   130                          	TMS_GFX_PIXELS_X	= $100	; unused
   131                          	KB_SCANCODE_NUMPAD_MULTIPLY	= $7c	; unused
   132                          	HBC56_DISABLE_SFXMAN	= $1
   133                          	tmsSetAddressWrite	= $e592
   134                          	TMS_MAGENTA	= $d	; unused
   135                          	LCD_IO_PORT	= $2	; unused
   136                          	tmsConsoleScrollLine	= $e8ac
   137                          	KB_SCANCODE_CTRL_RIGHT	= $94	; unused
   138                          	_tmsSendEmptyPage	= $e75a
   139                          	KB_BUFFER_SIZE	= $10
   140                          	KB_SCANCODE_COMMA	= $41	; unused
   141                          	HBC56_TITLE_TEXT	= $ee10
   142                          	AY_R10	= $a
   143                          	AY_IO_PORT	= $40
   144                          	AY_R11	= $b
   145                          	NES_LEFT	= $2	; unused
   146                          	AY_R12	= $c
   147                          	TMS_R1_DISP_BLANK	= $0	; unused
   148                          	KB_NUM_LOCK	= $10	; unused
   149                          	hbc56LogoPatt	= $ee92
   150                          	kernelMain	= $f177	; ?
   151                          	AY_R13	= $d
   152                          	hbc56LogoPattEnd	= $f00a	; unused
   153                          	ASCII_CR	= $d	; unused
   154                          	AY_R14	= $e
   155                          	KB_SCANCODE_PAGE_DOWN	= $fa	; unused
   156                          	kbIntHandler	= $eb76
   157                          	IO_PORT_BASE_ADDRESS	= $7f00
   158                          	AY_R15	= $f
   159                          	isDigit	= $e01e
   160                          	AY_R16	= $10	; unused
   161                          	HAVE_TMS9918	= $1
   162                          	UART_CTL_MASTER_RESET	= $3
   163                          	AY_R17	= $11	; unused
   164                          	KB_SCANCODE_TAB	= $d	; unused
   165                          	HBC56_KERNEL_ZP_START	= $18
   166                          	TMS9918_IRQ_BIT	= $1
   167                          	HBC56_BORDER	= $4
   168                          	TMS_R1_MODE_MULTICOLOR	= $8
   169                          	TMS_R0_MODE_MULTICOLOR	= $0
   170                          	TMS_DK_BLUE	= $4
   171                          	TMS_VRAM_SPRITE_PATT_ADDRESS	= $1800
   172                          	HBC56_CONSOLE_FLAG_NOWAIT	= $10
   173                          	KB_SCANCODE_ENTER	= $5a	; unused
   174                          	KB_IO_PORT	= $80
   175                          	AY_ENV_SHAPE_ATTACK	= $4
   176                          	UART_STATUS_IRQ	= $80	; unused
   177                          	NES_DOWN	= $4	; unused
   178                          	tmsReg1ClearFields	= $e5ef
   179                          	NES_SELECT	= $20	; unused
   180                          	hbc56Stop	= $f2e2
   181                          	UART_RX_BUFFER_SIZE	= $100
   182                          	KB_BUFFER	= $7c66
   183                          	DEFAULT_HBC56_NMI_VECTOR	= $ffe0	; unused
   184                          	NES1_IO_ADDR	= $7f82
   185                          	UART_CTL_WORD_7BIT_OPB_1SB	= $c	; unused
   186                          	KB_SCANCODE_NUMPAD_PLUS	= $79	; unused
   187                          	NES2_IO_ADDR	= $7f83
   188                          	BITMAP_RAM_END	= $7b26
   189                          	KB_SCANCODE_F2	= $6	; unused
   190                          	HBC56_TITLE_TEXT_LEN	= $1a
   191                          	NES_UP	= $8	; unused
   192                          	KB_SCANCODE_F3	= $4	; unused
   193                          	VIA_DIR_INPUT	= $0	; unused
   194                          	DELAY_L	= $34
   195                          	TMS_TXT_TILES_X	= $28
   196                          	ASCII_BACKSPACE	= $8	; unused
   197                          	TMS_TXT_TILES_Y	= $18
   198                          	KB_SCANCODE_F1	= $5	; unused
   199                          	KB_SCANCODE_SEMICOLON	= $4c	; unused
   200                          	KB_SCANCODE_F6	= $b	; unused
   201                          	TMS_R1_DISP_ACTIVE	= $40
   202                          	tmsInitColorTable	= $e7d3
   203                          	KB_SCANCODE_F7	= $83	; unused
   204                          	KB_SCANCODE_HOME	= $ec	; unused
   205                          	DELAY_H	= $35
   206                          	KB_SCANCODE_F4	= $c	; unused
   207                          	tmsSetPosTmpAddress	= $e86a
   208                          	uartInNoWait	= $ead7	; unused
   209                          	hbc56Reset	= $f2df	; unused
   210                          	KB_SCANCODE_F5	= $3	; unused
   211                          	hbc56CustomDelayMs	= $f2e6	; unused
   212                          	_tmsWaitReg	= $e582
   213                          	uartOut	= $eafa	; ?
   214                          	KB_TMP_X	= $7c5d
   215                          	KB_SCANCODE_F8	= $a	; unused
   216                          	HBC56_KERNEL_RAM_START	= $7a00
   217                          	KB_TMP_Y	= $7c5e	; unused
   218                          	KB_SCANCODE_F9	= $1	; unused
   219                          	tmsConsolePrint	= $ea2c	; unused
   220                          	tmsConsoleCls	= $e95e	; unused
   221                          	uartIrq	= $ea95
   222                          	TMS_BLACK	= $1
   223                          	HBC56_META_TITLE	= $7ca6
   224                          	KB_SCANCODE_SQUARE_RIGHT	= $5b	; unused
   225                          	tmsConsoleNewline	= $ea3c	; ?
   226                          	AY_S1	= $7f44
   227                          	NOTE_FREQ_C8	= 4186.010000000000218278728425502777	; unused
   228                          	KB_IRQ_BIT	= $2
   229                          	tmsModeGraphicsII	= $e697	; unused
   230                          	AY_S0	= $7f40
   231                          	NOTE_FREQ_A8	= $1b80	; unused
   232                          	HBC56_TICKS	= $7c9f
   233                          	HBC56_SECONDS_H	= $7ca1
   234                          	memcpySinglePage	= $e0a3	; unused
   235                          	tmsModeGraphicsI	= $e610
   236                          	NOTE_FREQ_G8	= 6271.930000000000291038304567337036	; unused
   237                          	AY_ADDR	= $0
   238                          	NOTE_FREQ_E8	= 5274.039999999999963620211929082870	; unused
   239                          	TMS_R1_RAM_4K	= $0	; unused
   240                          	AY_ENV_SHAPE_ALTERNATE	= $2
   241                          	NOTE_FREQ_DS8	= 4978.029999999999745341483503580093	; unused
   242                          	tmsInitEntireColorTable	= $e7d1	; ?
   243                          	TMS_GREY	= $e
   244                          	NES_B	= $40	; unused
   245                          	HBC56_SECONDS_L	= $7ca0
   246                          	AY_PSG1	= $4
   247                          	UART_CTL_WORD_7BIT_EPB_1SB	= $8	; unused
   248                          	NES_A	= $80	; unused
   249                          	TMS9918_IO_PORT	= $10
   250                          	UART_RAM_END	= $7c58
   251                          	AY_PSG0	= $0
   252                          	UART_FLOWCTRL_XON	= $11
   253                          	DEFAULT_HBC56_RST_VECTOR	= $8000
   254                          	NOTE_FREQ_C0	= 16.350000000000001421085471520200	; unused
   255                          	NOTE_FREQ_A1	= $37	; unused
   256                          	NOTE_FREQ_G2	= $62	; unused
   257                          	NOTE_FREQ_E3	= 164.810000000000002273736754432321
   258                          	NOTE_FREQ_DS4	= 311.129999999999995452526491135359	; unused
   259                          	KB_SCANCODE_CTRL_LEFT	= $14	; unused
   260                          	NOTE_FREQ_A0	= 27.500000000000000000000000000000	; unused
   261                          	NOTE_FREQ_E2	= 82.409999999999996589394868351519	; unused
   262                          	NOTE_FREQ_DS5	= 622.250000000000000000000000000000	; unused
   263                          	tmsReg0ClearFields	= $e5dd
   264                          	UART_STATUS_CLEAR_TO_SEND	= $8	; unused
   265                          	NOTE_FREQ_G3	= $c4	; unused
   266                          	NOTE_FREQ_C1	= 32.700000000000002842170943040401	; unused
   267                          	NOTE_FREQ_G0	= 24.500000000000000000000000000000	; unused
   268                          	NOTE_FREQ_E1	= 41.200000000000002842170943040401	; unused
   269                          	NOTE_FREQ_DS6	= 1244.509999999999990905052982270718	; unused
   270                          	UART_DATA	= $7f21
   271                          	VIA_IO_ADDR_T2C_H	= $7ff9	; unused
   272                          	NOTE_FREQ_C2	= 65.409999999999996589394868351519	; unused
   273                          	NOTE_FREQ_A3	= $dc	; unused
   274                          	NOTE_FREQ_E0	= 20.600000000000001421085471520200	; unused
   275                          	NOTE_FREQ_DS7	= 2489.019999999999981810105964541435	; unused
   276                          	TMS9918_TMP_BUFFER	= $7b30
   277                          	NOTE_FREQ_G1	= $31	; unused
   278                          	NOTE_FREQ_A2	= $6e	; unused
   279                          	NOTE_FREQ_C3	= 130.810000000000002273736754432321	; unused
   280                          	UART_ZP_END	= $2c
   281                          	NOTE_FREQ_DS0	= 19.449999999999999289457264239900	; unused
   282                          	NOTE_FREQ_C4	= 261.629999999999995452526491135359	; unused
   283                          	NOTE_FREQ_A5	= $370	; unused
   284                          	NOTE_FREQ_G6	= 1567.980000000000018189894035458565	; unused
   285                          	NOTE_FREQ_E7	= 2637.019999999999981810105964541435	; unused
   286                          	NOTE_FREQ_DS1	= 38.890000000000000568434188608080	; unused
   287                          	HAVE_KEYBOARD	= $1
   288                          	NOTE_FREQ_A4	= $1b8	; unused
   289                          	NOTE_FREQ_E6	= 1318.509999999999990905052982270718	; unused
   290                          	hbc56HighBell	= $f260	; ?
   291                          	NOTE_FREQ_G7	= 3135.960000000000036379788070917130	; unused
   292                          	NOTE_FREQ_C5	= 523.250000000000000000000000000000	; unused
   293                          	tmsConsoleHome	= $e961	; unused
   294                          	NOTE_FREQ_DS2	= 77.780000000000001136868377216160	; unused
   295                          	NOTE_FREQ_G4	= $188	; unused
   296                          	NOTE_FREQ_E5	= 659.250000000000000000000000000000	; unused
   297                          	VIA_IO_ADDR_T2C_L	= $7ff8	; unused
   298                          	NOTE_FREQ_C6	= 1046.500000000000000000000000000000	; unused
   299                          	NOTE_FREQ_A7	= $dc0	; unused
   300                          	BCD_RAM_START	= $7c59
   301                          	HBC56_META_TITLE_MAX_LEN	= $10
   302                          	isDigitX	= $e030	; unused
   303                          	NOTE_FREQ_DS3	= 155.560000000000002273736754432321	; unused
   304                          	NOTE_FREQ_E4	= 329.629999999999995452526491135359	; unused
   305                          	NOTE_FREQ_G5	= 783.990000000000009094947017729282	; unused
   306                          	NOTE_FREQ_A6	= $6e0	; unused
   307                          	NOTE_FREQ_C7	= $82d	; unused
   308                          	VIA_RAM_END	= $7c59
   309                          	AY_INACTIVE	= $3	; unused
   310                          	TMS_SPRITE_SIZE2X	= $10	; unused
   311                          	tmsSetPosWriteText	= $e97a	; ?
   312                          	KB_SCANCODE_F11	= $78	; unused
   313                          	AY_S0_READ	= $7f42	; unused
   314                          	tmsInitTextTable	= $e7ad	; ?
   315                          	KB_SCANCODE_F10	= $9	; unused
   316                          	VIA_REG_PORT_A	= $1
   317                          	KB_SCANCODE_NUMPAD_PERIOD	= $71	; unused
   318                          	VIA_REG_PORT_B	= $0
   319                          	KB_SCANCODE_F12	= $7	; unused
   320                          	kbNextScancode	= $ec94
   321                          	KB_SCANCODE_WINDOWS_LEFT	= $9f	; unused
   322                          	BCD_RAM_END	= $7c5c
   323                          	ASCII_RETURN	= $a	; unused
   324                          	TMS_R1_INT_ENABLE	= $20
   325                          	UART_CTL_WORD_8BIT_OPAR_1SB	= $1c	; unused
   326                          	isSpace	= $e049	; unused
   327                          	hbc56BootScreen	= $f00a
   328                          	AY_S1_READ	= $7f46	; unused
   329                          	KB_SCANCODE_END	= $e9	; unused
   330                          	TMS_GFX_TILE_HEIGHT	= $8
   331                          	KB_SCANCODE_SHIFT_RIGHT	= $59
   332                          	TMS_LT_BLUE	= $5	; unused
   333                          	TMS_R0_EXT_VDP_ENABLE	= $1	; unused
   334                          	uartOutNoBsCheck	= $eb00	; ?
   335                          	KB_SCANCODE_ALT_LEFT	= $11	; unused
   336                          	HBC56_INT_VECTOR	= $7e00
   337                          	VIA_REG_IER	= $e
   338                          	tmsIncPosConsole	= $e920
   339                          	INT_IO_PORT	= $df
   340                          	KB_PRESSED_MAP_BYTES	= $20
   341                          	VIA_REG_ACR	= $b
   342                          	STR_ADDR_H	= $33
   343                          	NES_RAM_END	= $7c9f
   344                          	memsetSinglePage	= $e101
   345                          	TMS_FONT_DATA	= $e271
   346                          	tmsSetPatternTmpAddressII	= $e98a	; unused
   347                          	kbWaitForScancode	= $ec7f
   348                          	tmsReg0SetFields	= $e5d3
   349                          	tmsPrint	= $e9e2
   350                          	KB_SCANCODE_APOS	= $52	; unused
   351                          	STR_ADDR_L	= $32
   352                          	tmsSetPosConsole	= $e967
   353                          	KB_SHIFT_RIGHT_MAP_BYTE	= $b
   354                          	AY_CLOCK_FREQ	= $1e8480
   355                          	tmsSetBackground	= $e5cf
   356                          	TMS_R1_MODE_GRAPHICS_II	= $0
   357                          	UART_RX_BUFFER_XON_SIZE	= $4
   358                          	VIA_IO_ADDR_ACR	= $7ffb	; unused
   359                          	uartFlowCtrlXon	= $eab9	; ?
   360                          	VIA_IO_ADDR_IER	= $7ffe	; unused
   361                          	ASCII_BELL	= $7	; unused
   362                          	BCD_TMP3	= $7c5b
   363                          	TMS_MED_RED	= $8	; unused
   364                          	UART_CTL_WORD_8BIT_EPAR_1SB	= $18	; unused
   365                          	BCD_TMP2	= $7c5a
   366                          	LCD_ZP_END	= $28
   367                          	toLower	= $e073	; unused
   368                          	BCD_TMP1	= $7c59
   369                          	MEM_SRC	= $2e
   370                          	AY_ENABLES	= $7
   371                          	UART_CTL_WORD_7BIT_OPB_2SB	= $4	; unused
   372                          	LCD_RAM_START	= $7b58
   373                          	TMS_LT_GREEN	= $3	; unused
   374                          	_tmsWaitData	= $e579
   375                          	tmsSetColorTmpAddressII	= $e986	; unused
   376                          	HAVE_MATH_INC	= $1
   377                          	KB_SCANCODE_B	= $32	; unused
   378                          	hbc56Bell	= $f292	; unused
   379                          	KB_SCANCODE_C	= $21	; unused
   380                          	TMS_TXT_PIXELS_X	= $f0	; unused
   381                          	HBC56_KERNEL_RAM_SIZE	= $2bd	; unused
   382                          	TMS_TXT_PIXELS_Y	= $c0	; unused
   383                          	KB_SCANCODE_A	= $1c	; unused
   384                          	TMS_GFX_TILES_Y	= $18
   385                          	KB_PRESSED_MAP_SIZE	= $fe	; unused
   386                          	KB_SCANCODE_F	= $2b	; unused
   387                          	kbIsPressed	= $ec62	; unused
   388                          	TMS_R0_MODE_TEXT	= $0
   389                          	TMS_GFX_TILES_X	= $20
   390                          	KB_SCANCODE_G	= $34	; unused
   391                          	HBC56_DISABLE_LCD	= $1
   392                          	TMS_R0_MODE_GRAPHICS_I	= $0
   393                          	tmsSetSpriteTmpAddress	= $e861	; unused
   394                          	KB_CB_RELEASED	= $7c61
   395                          	KB_SCANCODE_D	= $23	; unused
   396                          	TMS_R1_MODE_GRAPHICS_I	= $0
   397                          	KB_SCANCODE_E	= $24	; unused
   398                          	TILEMAP_ZP_START	= $18
   399                          	KB_SHIFT_DOWN	= $1	; unused
   400                          	KB_SCANCODE_J	= $3b	; unused
   401                          	KB_CB_PRESSED	= $7c5f
   402                          	KB_SCANCODE_K	= $42	; unused
   403                          	KB_SHIFT_RIGHT_MAP_BIT	= $40
   404                          	HBC56_CONSOLE_FLAGS	= $7ca3
   405                          	AY_ENV_SHAPE	= $d
   406                          	KB_SCANCODE_H	= $33	; unused
   407                          	kbReadAscii	= $ecfc	; unused
   408                          	KB_BUFFER_HEAD	= $7c64
   409                          	KB_SCANCODE_I	= $43	; unused
   410                          	viaIntHandler	= $ee0d
   411                          	KB_SCANCODE_N	= $31	; unused
   412                          	tmsTileXyAtPixelXy	= $e827	; unused
   413                          	UART_CTL_CLOCK_DIV_16	= $1	; unused
   414                          	nesWaitForPress	= $eb1e
   415                          	hbc56LogoInd	= $ee50
   416                          	KB_SCANCODE_O	= $44	; unused
   417                          	memcpyMultiPagePort	= $e0e1	; unused
   418                          	KB_SCANCODE_L	= $4b	; unused
   419                          	bin2bcd8	= $e07b	; unused
   420                          	KB_SCANCODE_M	= $3a	; unused
   421                          	KB_SCANCODE_ARROW_UP	= $f5	; unused
   422                          	UART_RX_BUFFER_HEAD	= $28
   423                          	KB_SCANCODE_R	= $2d	; unused
   424                          	_tmsSendPage	= $e724	; ?
   425                          	tmsSetPosWrite	= $e96d	; unused
   426                          	KB_SCANCODE_S	= $1b	; unused
   427                          	KB_SCANCODE_P	= $4d	; unused
   428                          	TMS_DK_RED	= $6	; unused
   429                          	KB_SCANCODE_Q	= $15	; unused
   430                          	NOTE_FREQ_GS8	= 6644.880000000000109139364212751389	; unused
   431                          	KB_CURRENT_STATE	= $7c63
   432                          	KB_SCANCODE_V	= $2a	; unused
   433                          	NOTE_FREQ_CS8	= 4434.920000000000072759576141834259	; unused
   434                          	KB_SCANCODE_W	= $1d	; unused
   435                          	HBC56_CONSOLE_FLAG_NES	= $40
   436                          	UART_CTL_WORD_7BIT_EPB_2SB	= $0	; unused
   437                          	kbScancodeToAscii	= $eca9
   438                          	KB_SCANCODE_T	= $2c	; unused
   439                          	KB_SHIFT_LEFT_MAP_BIT	= $20
   440                          	TMS_TRANSPARENT	= $0	; unused
   441                          	KB_SCANCODE_U	= $3c	; unused
   442                          	SFXMAN_RAM_END	= $7c59
   443                          	NOTE_FREQ_GS4	= 415.300000000000011368683772161603	; unused
   444                          	tmsSendBytes	= $e75e
   445                          	NOTE_FREQ_CS5	= 554.370000000000004547473508864641	; unused
   446                          	VIA_REG_T2C_H	= $9
   447                          	KB_SCANCODE_Z	= $1a	; unused
   448                          	LCD_ZP_START	= $28
   449                          	NOTE_FREQ_CS4	= 277.180000000000006821210263296962	; unused
   450                          	NOTE_FREQ_GS5	= 830.610000000000013642420526593924	; unused
   451                          	KB_SCANCODE_MINUS	= $4e	; unused
   452                          	isUpper	= $e00c
   453                          	TMS_VRAM_NAME_ADDRESS	= $3800
   454                          	UART_IRQ	= $3
   455                          	NES_RAM_START	= $7c9c
   456                          	NOTE_FREQ_GS6	= 1661.220000000000027284841053187847	; unused
   457                          	NOTE_FREQ_CS7	= 2217.460000000000036379788070917130	; unused
   458                          	KB_SCANCODE_X	= $22	; unused
   459                          	KB_SCANCODE_PAUSE	= $e1
   460                          	KB_IO_ADDR	= $7f80
   461                          	memcpySinglePagePort	= $e0b1	; unused
   462                          	NOTE_FREQ_CS6	= 1108.730000000000018189894035458565	; unused
   463                          	NOTE_FREQ_GS7	= 3322.440000000000054569682106375694	; unused
   464                          	TMS_REGISTER_DATA	= $e571
   465                          	TMS_MODEL	= $26be
   466                          	KB_SCANCODE_Y	= $35	; unused
   467                          	NOTE_FREQ_GS0	= 25.960000000000000852651282912120	; unused
   468                          	NOTE_FREQ_CS1	= 34.649999999999998578914528479800	; unused
   469                          	VIA_REG_T2C_L	= $8
   470                          	ROM_BANK_REG	= $8	; unused
   471                          	HBC56_USER_ZP_START	= $36	; unused
   472                          	NOTE_FREQ_CS0	= 17.320000000000000284217094304040	; unused
   473                          	NOTE_FREQ_GS1	= 51.909999999999996589394868351519	; unused
   474                          	UART_CTL_RX_INT_ENABLE	= $80
   475                          	KB_SCANCODE_CAPS_LOCK	= $58
   476                          	tableInvBitFromRight	= $e148	; unused
   477                          	tmsInitPattTable	= $e76d	; ?
   478                          	TMS9918_IRQ	= $1
   479                          	HBC56_CONSOLE_FLAG_CURSOR	= $80	; unused
   480                          	NOTE_FREQ_GS2	= 103.829999999999998294697434175760	; unused
   481                          	NOTE_FREQ_CS3	= 138.590000000000003410605131648481	; unused
   482                          	tmsModeMulticolor	= $e6cb	; unused
   483                          	NOTE_FREQ_CS2	= 69.299999999999997157829056959599	; unused
   484                          	NOTE_FREQ_GS3	= 207.650000000000005684341886080801	; unused
   485                          	KB_IRQ	= $2
   486                          	VIA_IO_PORT	= $f0
   487                          	HBC56_VIA_CALLBACK	= $7cbb
   488                          	_tmsSendX8	= $e726
   489                          	KB_SCANCODE_NUMPAD_5	= $73	; unused
   490                          	AY_CHA	= $0
   491                          	KB_SCANCODE_ALT_RIGHT_	= $91	; unused
   492                          	KB_SCANCODE_NUMPAD_4	= $6b	; unused
   493                          	AY_CHB	= $1
   494                          	KB_RAM_SIZE	= $3a
   495                          	tmsSetPatternWrite	= $e9d6	; unused
   496                          	KB_SCANCODE_NUMPAD_7	= $6c	; unused
   497                          	UART_RAM_START	= $7b58
   498                          	AY_CHC	= $2
   499                          	KB_SCANCODE_NUMPAD_6	= $74	; unused
   500                          	MEMORY_ZP_SIZE	= $6
   501                          	KB_SCANCODE_NUMPAD_1	= $69	; unused
   502                          	KEY_MAP_SHIFTED	= $ed8d	; ?
   503                          	AY_READ	= $2
   504                          	KB_SCANCODE_NUMPAD_0	= $70	; unused
   505                          	KB_SCANCODE_NUMPAD_3	= $7a	; unused
   506                          	HBC56_LOGO	= $4
   507                          	VIA_IRQ	= $5
   508                          	tableBitFromRight	= $e140	; unused
   509                          	KB_SCANCODE_NUMPAD_2	= $72	; unused
   510                          	TMS9918_CONSOLE_LINE_LEN	= $7b2b
   511                          	KB_SCANCODE_NUMPAD_MINUS	= $7b	; unused
   512                          	BITMAP_RAM_START	= $7b16
   513                          	uartInit	= $ea79	; unused
   514                          	hbc56CustomDelay	= $ffe3
   515                          	UART_STATUS_FRAMING_ERROR	= $10	; unused
   516                          	HBC56_BACKGROUND	= $f
   517                          	AY_ENV_SHAPE_FADE_IN_STOP	= $4	; unused
   518                          	HAVE_UART	= $1
   519                          	MEM_DST	= $2c
   520                          	TMS_DK_YELLOW	= $a	; unused
   521                          	UART_STATUS_PARITY_ERROR	= $40	; unused
   522                          	KB_SCANCODE_NUMPAD_9	= $7d	; unused
   523                          	KB_SCANCODE_NUMPAD_8	= $75	; unused
   524                          	AY_CHN	= $3	; unused
   525                          	AY_ENV_SHAPE_TRIANGLE	= $e	; unused
   526                          	hbc56Delay	= $ffe1
   527                          	tableInvBitFromLeft	= $e138
   528                          	KB_SCANCODE_2	= $1e	; unused
   529                          	AY_CHB_TONE_H	= $3	; unused
   530                          	KB_SCANCODE_3	= $26	; unused
   531                          	kbResetCallbacks	= $eb65	; unused
   532                          	NES_IO_PORT	= $82
   533                          	TMS9918_RAM_SIZE	= $32
   534                          	KB_SCANCODE_0	= $45	; unused
   535                          	TMS9918_RAM_START	= $7b26
   536                          	AY_CHA_TONE_L	= $0
   537                          	AY_CHC_TONE_H	= $5	; unused
   538                          	AY_ENV_SHAPE_CONTINUE	= $8
   539                          	KB_SCANCODE_1	= $16	; unused
   540                          	HBC56_TEXT	= $4
   541                          	HBC56_META_VECTOR	= $dffc
   542                          	cputype	= $65c02	; unused
   543                          	KB_SCANCODE_6	= $36	; unused
   544                          	HBC56_KERNEL_RAM_END	= $7cbd
   545                          	AY_CHB_TONE_L	= $2	; unused
   546                          	KB_SCANCODE_7	= $3d	; unused
   547                          	AY_ENV_SHAPE_FADE_IN	= $d	; unused
   548                          	tmsModeReset	= $e5f7
   549                          	KB_SCANCODE_DELETE	= $f1	; unused
   550                          	KB_SCANCODE_4	= $25	; unused
   551                          	KB_SCANCODE_MENU	= $af	; unused
   552                          	KB_SCANCODE_SPACEBAR	= $29	; unused
   553                          	AY_CHA_TONE_H	= $1
   554                          	AY_CHC_TONE_L	= $4	; unused
   555                          	KB_SCANCODE_5	= $2e	; unused
   556                          	MEMORY_ZP_START	= $2c
   557                          	tmsSetPosRead	= $e980	; unused
   558                          	nes1Pressed	= $eb2b	; unused
   559                          	VIA_REG_T1C_H	= $5
   560                          	INT_CTRL_ADDRESS	= $7fdf
   561                          	STR_ADDR	= $32
   562                          	AY_ENV_PERIOD_H	= $c
   563                          	tmsHex8	= $e834	; unused
   564                          	VIA_IO_ADDR_T1L_H	= $7ff7	; unused
   565                          	TILEMAP_ZP_END	= $1e
   566                          	KEY_MAP	= $ed0d	; ?
   567                          	KB_SCANCODE_8	= $3e	; unused
   568                          	KB_RAM_START	= $7c5c
   569                          	KB_SCANCODE_9	= $46	; unused
   570                          	VIA_REG_T1C_L	= $4
   571                          	AY_ENV_PERIOD_L	= $b
   572                          	KB_CTRL_DOWN	= $2	; unused
   573                          	KB_PAUSE_KEY	= $e1
   574                          	VIA_IO_ADDR_T1L_L	= $7ff6	; unused
   575                          	NES_RIGHT	= $1	; unused
   576                          	nes2Pressed	= $eb33	; unused
   577                          	MEM_LEN	= $30
   578                          	VIA_IO_ADDR_PORT_A	= $7ff1	; unused
   579                          	UART_CTL_WORD_8BIT_2SB	= $10
   580                          	NES_START	= $10	; unused
   581                          	HBC56_META_TITLE_LEN	= $7cb8
   582                          	memsetMultiPage	= $e10d	; unused
   583                          	UART_REG	= $7f20
   584                          	LCD_MODEL	= $3240	; unused
   585                          	KB_SCANCODE_SHIFT_LEFT	= $12
   586                          	VIA_IO_ADDR_PORT_B	= $7ff0	; unused
   587                          	isAlNum	= $e02a	; unused
   588                          	AY_CHA_AMPL	= $8
   589                          	LAST_MODULE_RAM_END	= $7c9f
   590                          	TMS_R1_MODE_TEXT	= $10
   591                          	tmsConsoleOut	= $e9f5
   592                          	TMS9918_REG	= $7f11
   593                          	KB_SCANCODE_NUMPAD_DIVIDE	= $ca	; unused
   594                          	DEFAULT_HBC56_INT_VECTOR	= $ffe0
   595                          	VIA_IRQ_BIT	= $10
   596                          	TMS_VRAM_PATT_ADDRESS	= $2000
   597                          	KB_SCANCODE_EQUAL	= $55	; unused
   598                          	KB_RELEASE	= $f0
   599                          	tmsInitSpriteTable	= $e7f2	; ?
   600                          	KB_SCANCODE_ARROW_DOWN	= $f2	; unused
   601                          	UART_RX_BUFFER_BYTES	= $2a
   602                          	isAlpha	= $e018
   603                          	ayInit	= $e158
   604                          	TMS9918_RAM	= $7f10
   605                          	UART_RX_FLAGS	= $2b
   606                          	AY_R1	= $1
   607                          	NOTE_FREQ_B8	= 7902.130000000000109139364212751389	; unused
   608                          	KB_STATUS_ADDR	= $7f81
   609                          	AY_R0	= $0
   610                          	AY_R3	= $3
   611                          	NOTE_FREQ_F8	= 5587.649999999999636202119290828705	; unused
   612                          	AY_R2	= $2
   613                          	NOTE_FREQ_D8	= 4698.630000000000109139364212751389	; unused
   614                          	TMS_DK_GREEN	= $c	; unused
   615                          	AY_R5	= $5
   616                          	AY_CHC_AMPL	= $a	; unused
   617                          	NOTE_FREQ_FS8	= 5919.909999999999854480847716331482	; unused
   618                          	AY_R4	= $4
   619                          	AY_R7	= $7
   620                          	KB_ALT_DOWN	= $4	; unused
   621                          	AY_R6	= $6
   622                          	TMS_TXT_TILE_HEIGHT	= $8
   623                          	AY_R9	= $9
   624                          	NOTE_FREQ_B0	= 30.870000000000000994759830064140	; unused
   625                          	NOTE_FREQ_F2	= 87.310000000000002273736754432321	; unused
   626                          	NOTE_FREQ_D3	= 146.830000000000012505552149377763	; unused
   627                          	NOTE_FREQ_FS4	= 369.990000000000009094947017729282	; unused
   628                          	TMS_VRAM_COLOR_ADDRESS+2	= $0
   629                          	tmsSetPatternTmpAddressBank1	= $e9c0	; unused
   630                          	VIA_IO_ADDR_DDR_A	= $7ff3	; unused
   631                          	AY_R8	= $8
   632                          	NOTE_FREQ_B1	= 61.740000000000001989519660128281	; unused
   633                          	NOTE_FREQ_D2	= 73.420000000000001705302565824240	; unused
   634                          	NOTE_FREQ_FS5	= 739.990000000000009094947017729282	; unused
   635                          	UART_FLOWCTRL_XOFF	= $13
   636                          	TMS_R0_EXT_VDP_DISABLE	= $0
   637                          	tmsSetPatternTmpAddressBank0	= $e9a3	; unused
   638                          	NOTE_FREQ_F3	= 174.610000000000013642420526593924	; unused
   639                          	NOTE_FREQ_F0	= 21.829999999999998294697434175760	; unused
   640                          	NOTE_FREQ_D1	= 36.710000000000000852651282912120	; unused
   641                          	NOTE_FREQ_FS6	= 1479.980000000000018189894035458565	; unused
   642                          	TMS9918_CONSOLE_Y	= $7b29
   643                          	TMS_LT_YELLOW	= $b	; unused
   644                          	KB_SCANCODE_ARROW_LEFT	= $eb	; unused
   645                          	NOTE_FREQ_B2	= 123.469999999999998863131622783840	; unused
   646                          	NOTE_FREQ_D0	= 18.350000000000001421085471520200	; unused
   647                          	NOTE_FREQ_FS7	= 2959.960000000000036379788070917130	; unused
   648                          	TMS9918_CONSOLE_X	= $7b28
   649                          	tmsSetPatternTmpAddressBank2	= $e9cb	; unused
   650                          	VIA_IO_ADDR_DDR_B	= $7ff2	; unused
   651                          	NOTE_FREQ_F1	= 43.649999999999998578914528479800	; unused
   652                          	NOTE_FREQ_B3	= 246.939999999999997726263245567679	; unused
   653                          	HBC56_KERNEL_START	= $e000
   654                          	TMS9918_ZP_END	= $28
   655                          	HAVE_AY3891X	= $1
   656                          	NOTE_FREQ_FS0	= 23.120000000000000994759830064140	; unused
   657                          	TMS_R1_INT_DISABLE	= $0	; unused
   658                          	AY_CHB_AMPL	= $9	; unused
   659                          	NOTE_FREQ_B4	= 493.879999999999995452526491135359	; unused
   660                          	NOTE_FREQ_F6	= 1396.910000000000081854523159563541	; unused
   661                          	NOTE_FREQ_D7	= 2349.320000000000163709046319127083	; unused
   662                          	NOTE_FREQ_FS1	= 46.250000000000000000000000000000	; unused
   663                          	NOTE_FREQ_B5	= 987.769999999999981810105964541435	; unused
   664                          	NOTE_FREQ_D6	= 1174.660000000000081854523159563541	; unused
   665                          	TMS_TXT_TILE_WIDTH	= $6
   666                          	tmsSetPosTmpAddressText	= $e887
   667                          	tmsSetPatternTmpAddress	= $e9a3
   668                          	NOTE_FREQ_F7	= 2793.829999999999927240423858165741	; unused
   669                          	NOTE_FREQ_FS2	= 92.500000000000000000000000000000	; unused
   670                          	NOTE_FREQ_F4	= 349.230000000000018189894035458565	; unused
   671                          	NOTE_FREQ_D5	= 587.330000000000040927261579781771	; unused
   672                          	LOGO_BUFFER	= $3000	; unused
   673                          	NOTE_FREQ_B6	= 1975.529999999999972715158946812153	; unused
   674                          	TMS9918_CONSOLE_SIZE_X	= $7b2a
   675                          	KB_SCANCODE_BACKSPACE	= $66	; unused
   676                          	NOTE_FREQ_FS3	= $b9	; unused
   677                          	NOTE_FREQ_D4	= 293.660000000000025011104298755527	; unused
   678                          	tmsInit	= $e6d9
   679                          	NOTE_FREQ_F5	= 698.460000000000036379788070917130
   680                          	NOTE_FREQ_B7	= 3951.070000000000163709046319127083	; unused
   681                          	KB_SCANCODE_INSERT	= $f0	; unused

; ******** Source: ../../kernel\hbc56kernel.inc
    15                          
    16                          

; ******** Source: ../../lib\ut\math.inc
     1                          ; 6502
     2                          ;
     3                          ; Math macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          HAVE_MATH_INC = 1
    14                          
    15                          !macro lsr2 {
    16                                  lsr
    17                                  lsr
    18                          }
    19                          
    20                          !macro lsr3 {
    21                                  +lsr2
    22                                  lsr
    23                          }
    24                          
    25                          !macro lsr4 {
    26                                  +lsr3
    27                                  lsr
    28                          }
    29                          
    30                          !macro lsr5 {
    31                                  +lsr4
    32                                  lsr
    33                          }
    34                          
    35                          !macro lsr6 {
    36                                  +lsr5
    37                                  lsr
    38                          }
    39                          
    40                          !macro lsr7 {
    41                                  +lsr6
    42                                  lsr
    43                          }
    44                          
    45                          !macro div2   { lsr }
    46                          !macro div4   { +lsr2 }
    47                          !macro div8   { +lsr3 }
    48                          !macro div16  { +lsr4 }
    49                          !macro div32  { +lsr5 }
    50                          !macro div64  { +lsr6 }
    51                          !macro div128 { +lsr7 }
    52                          
    53                          !macro asl2 {
    54                                  asl
    55                                  asl
    56                          }
    57                          
    58                          !macro asl3 {
    59                                  +asl2
    60                                  asl
    61                          }
    62                          
    63                          !macro asl4 {
    64                                  +asl3
    65                                  asl
    66                          }
    67                          
    68                          !macro asl5 {
    69                                  +asl4
    70                                  asl
    71                          }
    72                          
    73                          !macro asl6 {
    74                                  +asl5
    75                                  asl
    76                          }
    77                          
    78                          !macro asl7 {
    79                                  +asl6
    80                                  asl
    81                          }
    82                          
    83                          !macro mul2   { asl }
    84                          !macro mul4   { +asl2 }
    85                          !macro mul8   { +asl3 }
    86                          !macro mul16  { +asl4 }
    87                          !macro mul32  { +asl5 }
    88                          !macro mul64  { +asl6 }
    89                          !macro mul128 { +asl7 }
    90                          
    91                          
    92                          
    93                          ; -----------------------------------------------------------------------------
    94                          ; +dec16: decement a 16-bit value
    95                          ; -----------------------------------------------------------------------------
    96                          ; Inputs:
    97                          ;  addr: address containing LSB of value to decrement
    98                          ; -----------------------------------------------------------------------------
    99                          !macro dec16 .addr {
   100                            lda .addr
   101                            bne +
   102                            dec .addr + 1
   103                          +
   104                            dec .addr
   105                          }
   106                          
   107                          ; -----------------------------------------------------------------------------
   108                          ; +inc16: increment a 16-bit value
   109                          ; -----------------------------------------------------------------------------
   110                          ; Inputs:
   111                          ;  addr: address containing LSB of value to increment
   112                          ; -----------------------------------------------------------------------------
   113                          !macro inc16 .addr {
   114                            inc .addr
   115                            bne +
   116                            inc .addr + 1
   117                          +
   118                          }
   119                          
   120                          ; -----------------------------------------------------------------------------
   121                          ; +cmp16: compare two 16-bit values in memory
   122                          ; -----------------------------------------------------------------------------
   123                          ; Inputs:
   124                          ;  left:  address containing LSB of left value to comapre
   125                          ;  right: address containing LSB of right value to comapre
   126                          ; Outputs:
   127                          ;  C set if right < left
   128                          ;  Z set if right == left
   129                          ; -----------------------------------------------------------------------------
   130                          !macro cmp16 .left, .right {
   131                            lda .left + 1
   132                            cmp .right + 1
   133                          	bne +
   134                          	lda .left
   135                          	cmp .right
   136                          +
   137                          }
   138                          
   139                          ; -----------------------------------------------------------------------------
   140                          ; +cmp16: compare two 16-bit values in memory
   141                          ; -----------------------------------------------------------------------------
   142                          ; Inputs:
   143                          ;  value: immediate value to compare
   144                          ;  x:     msb
   145                          ;  a:     lsb
   146                          ; -----------------------------------------------------------------------------
   147                          !macro cmp16xa .value {
   148                            cpx #>.value
   149                          	bne .doneCmpXa
   150                          	cmp #<.value
   151                          .doneCmpXa
   152                          }
   153                          
   154                          ; -----------------------------------------------------------------------------
   155                          ; +sub16: subtract 16 bit numbers
   156                          ; -----------------------------------------------------------------------------
   157                          ; Inputs:
   158                          ;  left:  address containing LSB of left value
   159                          ;  right: address containing LSB of right value
   160                          ; Outputs:
   161                          ;  res:   address containing LSB of result
   162                          ; -----------------------------------------------------------------------------
   163                          !macro sub16 .left, .right, .res {
   164                            sec
   165                            lda .left
   166                            sbc .right
   167                            sta .res
   168                            lda .left + 1
   169                            sbc .right + 1
   170                            sta .res + 1
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; +sub16: subtract 16 bit numbers - result in ax registers
   175                          ; -----------------------------------------------------------------------------
   176                          ; Inputs:
   177                          ;  left:  address containing LSB of left value
   178                          ;  right: address containing LSB of right value
   179                          ; Outputs:
   180                          ;  a:     result msb
   181                          ;  x:     result lsb
   182                          ; -----------------------------------------------------------------------------
   183                          !macro sub16 .left, .right {
   184                            sec
   185                            lda .left
   186                            sbc .right
   187                            tax
   188                            lda .left + 1
   189                            sbc .right + 1
   190                          }
   191                          
   192                          
   193                          ; -----------------------------------------------------------------------------
   194                          ; +add16: add 16 bit numbers - result in ax registers
   195                          ; -----------------------------------------------------------------------------
   196                          ; Inputs:
   197                          ;  left:  address containing LSB of left value
   198                          ;  right: address containing LSB of right value
   199                          ; Outputs:
   200                          ;  a:     result msb
   201                          ;  x:     result lsb
   202                          ; -----------------------------------------------------------------------------
   203                          !macro add16 .left, .right {
   204                            clc
   205                            lda .left
   206                            adc .right
   207                            tax
   208                            lda .left + 1
   209                            adc .right + 1
   210                          }
   211                          
   212                          
   213                          ; -----------------------------------------------------------------------------
   214                          ; +add16Imm: add 16 bit numbers - result stored to res
   215                          ; -----------------------------------------------------------------------------
   216                          ; Inputs:
   217                          ;  left:  address containing LSB of left value
   218                          ;  imm:   immediate value to add
   219                          ; Outputs:
   220                          ;  res: address to store result
   221                          ; -----------------------------------------------------------------------------
   222                          !macro add16Imm .left, .imm, .res {
   223                            clc
   224                            lda .left
   225                            adc #<.imm
   226                            sta .res
   227                            lda .left + 1
   228                            adc #>.imm
   229                            sta .res + 1
   230                          }
   231                          
   232                          
   233                          ; -----------------------------------------------------------------------------
   234                          ; +subImm8From16: subtract an 8 bit number from a 16 bit number
   235                          ; -----------------------------------------------------------------------------
   236                          ; Inputs:
   237                          ;  left:  address containing LSB of left value
   238                          ;  right: immediate 8-bit value
   239                          ; Outputs:
   240                          ;  res:   address containing LSB of result
   241                          ; -----------------------------------------------------------------------------
   242                          !macro subImm8From16 .left, .right, .res {
   243                            sec
   244                            lda .left
   245                            sbc #.right
   246                            sta .res
   247                            lda .left + 1
   248                            sbc #0
   249                            sta .res + 1
   250                          }
   251                          
   252                          ; -----------------------------------------------------------------------------
   253                          ; +incBcd: increment a BCD byte (inc instruction doesn't work in bcd mode)
   254                          ; -----------------------------------------------------------------------------
   255                          ; Inputs:
   256                          ;  addr:  address containing BCD value
   257                          ; -----------------------------------------------------------------------------
   258                          !macro incBcd .addr {
   259                            lda .addr
   260                            sed
   261                            clc
   262                            adc #1
   263                            cld
   264                            sta .addr
   265                          }
   266                          
   267                          ; -----------------------------------------------------------------------------
   268                          ; +decBcd: decrement a BCD byte (inc instruction doesn't work in bcd mode)
   269                          ; -----------------------------------------------------------------------------
   270                          ; Inputs:
   271                          ;  addr:  address containing BCD value
   272                          ; -----------------------------------------------------------------------------
   273                          !macro decBcd .addr {
   274                            lda .addr
   275                            sed
   276                            sec
   277                            sbc #1
   278                            cld
   279                            sta .addr

; ******** Source: ../../kernel\hbc56kernel.inc
    17                          

; ******** Source: ../../lib\ut\memory.inc
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; store16: Write a 16-bit immediate value to memory
    15                          ; -----------------------------------------------------------------------------
    16                          ; Inputs:
    17                          ;	.dst: destination address
    18                          ;	.val16: 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          !macro store16 .dst, .val16 {
    21                                  lda #<.val16
    22                                  sta .addr
    23                                  lda #>.val16
    24                                  sta .addr + 1
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; memcpy: Copy a fixed number of bytes from .src to dest
    29                          ; -----------------------------------------------------------------------------
    30                          ; Inputs:
    31                          ;	.src: source address
    32                          ;	.dst: destination address
    33                          ;	.cnt: number of bytes
    34                          ; -----------------------------------------------------------------------------
    35                          !macro memcpy .dst, .src, .cnt {
    36                          !if .cnt <= 0 {
    37                          	!error "memcpy: invalid count: ", .cnt
    38                          } else if .cnt <= 8 {
    39                          	!for i, 0, .cnt - 1 {
    40                          		lda .src + i
    41                          		sta .dst + i
    42                          	}
    43                          } else { !if .cnt <= 256 {
    44                          	ldx #0
    45                          -
    46                          	lda .src, x
    47                          	sta .dst, x
    48                          	inx
    49                          	cpx #(.cnt & $ff)	
    50                          	bne -
    51                          } else {
    52                          	lda #<.src
    53                          	sta MEM_SRC
    54                          	lda #>.src
    55                          	sta MEM_SRC + 1
    56                          
    57                          	lda #<.dst
    58                          	sta MEM_DST
    59                          	lda #>.dst
    60                          	sta MEM_DST + 1
    61                          
    62                          
    63                          		lda #<.cnt
    64                          		sta MEM_LEN
    65                          		lda #>.cnt
    66                          		sta MEM_LEN + 1
    67                          		jsr memcpyMultiPage
    68                          	}
    69                          }
    70                          }
    71                          
    72                          !macro setMemCpySrc .src {
    73                          	lda #<.src
    74                          	sta MEM_SRC
    75                          	lda #>.src
    76                          	sta MEM_SRC + 1
    77                          }
    78                          
    79                          !macro setMemCpyDst .dst {
    80                          	lda #<.dst
    81                          	sta MEM_DST
    82                          	lda #>.dst
    83                          	sta MEM_DST + 1
    84                          }
    85                          
    86                          !macro setMemCpySrcInd .srcRef {
    87                          	lda .srcRef
    88                          	sta MEM_SRC
    89                          	lda .srcRef + 1
    90                          	sta MEM_SRC + 1
    91                          }
    92                          
    93                          !macro setMemCpyDstInd .dstRef {
    94                          	lda .dstRef
    95                          	sta MEM_DST
    96                          	lda .dstRef + 1
    97                          	sta MEM_DST + 1
    98                          }
    99                          
   100                          !macro memcpySinglePage .bytes {
   101                          
   102                          	!if .bytes <= 0 {
   103                          		!error "memcpySinglePage: invalid count: ", .bytes
   104                          	}	
   105                          
   106                          	ldy #.bytes
   107                          	jsr memcpySinglePage
   108                          }
   109                          
   110                          
   111                          ; -----------------------------------------------------------------------------
   112                          ; memcpyPort: Copy a fixed number of bytes from .src ram to dest port
   113                          ; -----------------------------------------------------------------------------
   114                          ; Inputs:
   115                          ;	.src: source address
   116                          ;	.dst: destination address
   117                          ;	.cnt: number of bytes
   118                          ; -----------------------------------------------------------------------------
   119                          !macro memcpyPort .dst, .src, .cnt {
   120                          	!if .cnt <= 0 {
   121                          		!error "memcpyPort: invalid count: ", .cnt
   122                          	}
   123                          	
   124                          	lda #<.src
   125                          	sta MEM_SRC
   126                          	lda #>.src
   127                          	sta MEM_SRC + 1
   128                          
   129                          	lda #<.dst
   130                          	sta MEM_DST
   131                          	lda #>.dst
   132                          	sta MEM_DST + 1
   133                          
   134                          	!if .cnt <= 256 {
   135                          		ldy #<.cnt					
   136                          		jsr memcpySinglePagePort
   137                          	} else {
   138                          		lda #<.cnt
   139                          		sta MEM_LEN
   140                          		lda #>.cnt
   141                          		sta MEM_LEN + 1
   142                          		jsr memcpyMultiPagePort
   143                          	}
   144                          }
   145                          
   146                          !zone {
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; memset: Set a fixed number of bytes to a single value
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;	.dst: destination address
   153                          ;	val: the byte value
   154                          ;	.cnt: number of bytes
   155                          ; -----------------------------------------------------------------------------
   156                          !macro memset .dst, .val, .cnt {
   157                          !if .cnt <= 0 {
   158                          	!error "memset: invalid count: ", .cnt
   159                          } else if .cnt <= 8 {
   160                          	lda #.val
   161                          	!for i, 0, .cnt - 1 {
   162                          	sta .dst + i
   163                          	}
   164                          } else if .cnt <= 256 {
   165                          	ldx #<.cnt
   166                          	lda #.val
   167                          -
   168                          	dex
   169                          	sta .dst, x
   170                          	cpx #0
   171                          	bne -
   172                          } else {
   173                          	lda #<.dst
   174                          	sta MEM_DST
   175                          	lda #>.dst
   176                          	sta MEM_DST + 1
   177                          	lda #<.cnt
   178                          	sta MEM_LEN
   179                          	lda #>.cnt
   180                          	sta MEM_LEN + 1
   181                          	lda #.val
   182                          	jsr memsetMultiPage
   183                          }
   184                          }
   185                          
   186                          

; ******** Source: ../../kernel\hbc56kernel.inc
    18                          

; ******** Source: ../../lib\gfx\tms9918.inc
     1                          ; 6502 - TMS9918 VDP Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; tmsWaitReg: Not sure how much delay we need so make a macro for now
    15                          ; -----------------------------------------------------------------------------
    16                          !macro tmsWaitReg {
    17                                  jsr _tmsWaitReg
    18                          }
    19                          
    20                          ; -----------------------------------------------------------------------------
    21                          ; tmsWaitData: Not sure how much delay we need so make a macro for now
    22                          ; -----------------------------------------------------------------------------
    23                          !macro tmsWaitData {
    24                                  jsr _tmsWaitData
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; tmsSetAddressWrite: Set an address in the TMS9918
    29                          ; -----------------------------------------------------------------------------
    30                          !macro tmsSetAddressWrite .addr {
    31                                  +tmsSetAddressRead ($4000 | .addr)
    32                          }
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; tmsSetAddressRead: Set an address to read from the TMS9918
    36                          ; -----------------------------------------------------------------------------
    37                          !macro tmsSetAddressRead .addr {
    38                                  php
    39                                  sei             ; we can't be interrupted here
    40                                  lda #<(.addr)
    41                                  sta TMS9918_REG
    42                                  +tmsWaitReg
    43                                  lda #>(.addr)
    44                                  sta TMS9918_REG
    45                                  +tmsWaitReg
    46                                  plp
    47                          }
    48                          
    49                          ; -----------------------------------------------------------------------------
    50                          ; tmsGet: Get a byte of data from the TMS9918
    51                          ; -----------------------------------------------------------------------------
    52                          !macro tmsGet {
    53                                  lda TMS9918_RAM
    54                                  +tmsWaitData
    55                          }
    56                          
    57                          ; -----------------------------------------------------------------------------
    58                          ; tmsPut: Send a byte of data to the TMS9918
    59                          ; -----------------------------------------------------------------------------
    60                          !macro tmsPut .byte {
    61                                  lda #(.byte & 0xff)
    62                                  +tmsPut
    63                          }
    64                          
    65                          
    66                          ; -----------------------------------------------------------------------------
    67                          ; tmsPut: Send a byte (A) of data to the TMS9918
    68                          ; -----------------------------------------------------------------------------
    69                          !macro tmsPut {
    70                                  sta TMS9918_RAM
    71                                  +tmsWaitData
    72                          }
    73                          
    74                          ; -----------------------------------------------------------------------------
    75                          ; tmsSetColor: Set current fg/bg color
    76                          ; -----------------------------------------------------------------------------
    77                          !macro tmsSetColor .color {
    78                                  lda #.color
    79                                  jsr tmsSetBackground
    80                          }
    81                          
    82                          ; -----------------------------------------------------------------------------
    83                          ; tmsSetColorFgBg: Set current fg/bg color
    84                          ; -----------------------------------------------------------------------------
    85                          !macro tmsSetColorFgBg .fg, .bg {
    86                                  +tmsColorFgBg .fg, .bg
    87                                  jsr tmsSetBackground
    88                          }
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; byteTmsColorFgBg: Output a data byte
    92                          ; -----------------------------------------------------------------------------
    93                          !macro byteTmsColorFgBg .fg, .bg {
    94                          !byte (.fg << 4 | .bg)
    95                          }
    96                          
    97                          
    98                          ; -----------------------------------------------------------------------------
    99                          ; tmsDisableOutput: Disable the TMS9918 output
   100                          ; -----------------------------------------------------------------------------
   101                          !macro tmsDisableOutput {
   102                                  lda #TMS_R1_DISP_ACTIVE
   103                                  jsr tmsReg1ClearFields
   104                          }
   105                          
   106                          ; -----------------------------------------------------------------------------
   107                          ; tmsEnableOutput: Enable the TMS9918 output
   108                          ; -----------------------------------------------------------------------------
   109                          !macro tmsEnableOutput {
   110                                  lda #TMS_R1_DISP_ACTIVE
   111                                  jsr tmsReg1SetFields
   112                          }
   113                          
   114                          ; -
   115                          !macro tmsEnableInterrupts {
   116                                  lda #TMS_R1_INT_ENABLE
   117                                  jsr tmsReg1SetFields
   118                          }
   119                          
   120                          !macro tmsDisableInterrupts {
   121                                  lda #TMS_R1_INT_ENABLE
   122                                  jsr tmsReg1ClearFields
   123                          }
   124                          
   125                          !macro tmsConsoleOut .char {
   126                                  lda #.char
   127                                  jsr tmsConsoleOut
   128                          }
   129                          
   130                          
   131                          ; -----------------------------------------------------------------------------
   132                          ; tmsConsolePrintAddr: Print text to console
   133                          ; -----------------------------------------------------------------------------
   134                          ; Inputs:
   135                          ;  textAddr: Address of null-terminated string to print
   136                          ; -----------------------------------------------------------------------------
   137                          !macro tmsConsolePrintAddr .textAddr {
   138                                  lda #<.textAddr
   139                                  sta STR_ADDR_L
   140                                  lda #>.textAddr
   141                                  sta STR_ADDR_H
   142                                  jsr tmsConsolePrint        
   143                          }
   144                          
   145                          ; -----------------------------------------------------------------------------
   146                          ; tmsConsolePrint: Print immediate text to console
   147                          ; -----------------------------------------------------------------------------
   148                          ; Inputs:
   149                          ;  str: String to print
   150                          ; -----------------------------------------------------------------------------
   151                          !macro tmsConsolePrint .str {
   152                          	jmp .afterText
   153                          .textAddr
   154                          	!text .str,0
   155                          .afterText        
   156                                  +tmsConsolePrintAddr .textAddr
   157                          }
   158                          
   159                          ; -----------------------------------------------------------------------------
   160                          ; +tmsColorFgBg: Set A to the given FG / BG color
   161                          ; -----------------------------------------------------------------------------
   162                          !macro tmsColorFgBg .fg, .bg {
   163                                  lda #(.fg << 4 | .bg)
   164                          }
   165                          
   166                          ; -----------------------------------------------------------------------------
   167                          ; tmsReadStatus: Read status - clear interrupt
   168                          ; -----------------------------------------------------------------------------
   169                          !macro tmsReadStatus  {
   170                                  bit TMS9918_REG
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; tmsSendData: Send # bytes from .sourceAddr to tms9918 data port
   175                          ; -----------------------------------------------------------------------------
   176                          !macro tmsSendData .sourceAddr, .numBytes {
   177                                  lda #<.sourceAddr
   178                                  sta TMS_TMP_ADDRESS
   179                                  lda #>.sourceAddr
   180                                  sta TMS_TMP_ADDRESS + 1
   181                          
   182                                  !if .numBytes < 256 {
   183                                          ldx #.numBytes
   184                                          jsr tmsSendBytes
   185                                  } else {
   186                                          !do while .numBytes > 0 {
   187                                                  !if .numBytes > 255 {
   188                                                          ldx #0
   189                                                          !set .numBytes = .numBytes - 256
   190                                                  } else {
   191                                                          ldx #.numBytes
   192                                                          !set .numBytes = 0
   193                                                  }
   194                                                  jsr tmsSendBytes
   195                                                  inc TMS_TMP_ADDRESS + 1
   196                                          }
   197                                  }
   198                          
   199                          }
   200                          
   201                          ; -----------------------------------------------------------------------------
   202                          ; tmsSendDataRpt: Send # bytes from .sourceAddr to tms9918 data port .rpt times
   203                          ; -----------------------------------------------------------------------------
   204                          !macro tmsSendDataRpt .sourceAddr, .numBytes, .rpt {
   205                                  lda #<.sourceAddr
   206                                  sta TMS_TMP_ADDRESS
   207                                  lda #>.sourceAddr
   208                                  sta TMS_TMP_ADDRESS + 1
   209                          
   210                                  !if .numBytes < 256 {
   211                                          !if .rpt < 5 {
   212                                                  !for i,1,.rpt {
   213                                                          ldx #.numBytes
   214                                                          jsr tmsSendBytes
   215                                                  }
   216                                          } else {
   217                                                  lda #.rpt
   218                                                  sta TMS9918_TMP_BUFFER
   219                          -
   220                                                  ldx #.numBytes
   221                                                  jsr tmsSendBytes
   222                                                  dec TMS9918_TMP_BUFFER
   223                                                  bne -
   224                                          }
   225                                  } else {
   226                                          !error "tmsSendDataRpt supports <256 bytes only"
   227                                  }
   228                          }
   229                          
   230                          
   231                          ; -----------------------------------------------------------------------------
   232                          ; tmsPutRpt: Send value .rpt times
   233                          ; -----------------------------------------------------------------------------
   234                          !macro tmsPutRpt .value, .rpt {
   235                                  ldx #.rpt
   236                                  lda #.value
   237                          -
   238                                  +tmsPut
   239                                  dex
   240                                  bne -
   241                          }
   242                          
   243                          !macro tmsPutSeq .from, .count {
   244                                  lda #.from
   245                          -
   246                                  +tmsPut
   247                                  inc
   248                                  cmp #<(.from + .count)
   249                                  bne -
   250                          }
   251                          
   252                          !macro tmsSetSourceAddressInd .addr {
   253                          	lda .addr
   254                          	sta TMS_TMP_ADDRESS
   255                          	lda .addr + 1
   256                          	sta TMS_TMP_ADDRESS + 1
   257                          }
   258                          
   259                          !macro tmsSetSourceAddressIndOffset .addr, .offset {
   260                                  clc
   261                          	lda .addr
   262                                  adc #<.offset
   263                          	sta TMS_TMP_ADDRESS
   264                          	lda .addr + 1
   265                                  adc #>.offset
   266                          	sta TMS_TMP_ADDRESS + 1
   267                          }
   268                          
   269                          
   270                          !macro tmsSendBytes .bytes {
   271                                  ldx #.bytes
   272                                  jsr tmsSendBytes
   273                          }
   274                          
   275                          
   276                          ; -----------------------------------------------------------------------------
   277                          ; tmsSetAddrPattTable: Initialise address for font table
   278                          ; -----------------------------------------------------------------------------
   279                          !macro tmsSetAddrPattTable {
   280                                  +tmsSetAddrPattTable 0
   281                          }
   282                          
   283                          ; -----------------------------------------------------------------------------
   284                          ; tmsSetAddrPattTable: Initialise address for pattern table
   285                          ; -----------------------------------------------------------------------------
   286                          !macro tmsSetAddrPattTable .ind {
   287                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   288                          }
   289                          
   290                          ; -----------------------------------------------------------------------------
   291                          ; tmsSetAddrPattTable: Initialise address for pattern table
   292                          ; -----------------------------------------------------------------------------
   293                          !macro tmsSetAddrPattTable .ind, .row {
   294                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   295                          }
   296                          
   297                          ; -----------------------------------------------------------------------------
   298                          ; tmsSetAddrPattTableIIBank0: Initialise address for pattern table
   299                          ; -----------------------------------------------------------------------------
   300                          !macro tmsSetAddrPattTableIIBank0 .ind {
   301                                  +tmsSetAddrPattTable .ind
   302                          }
   303                          
   304                          ; -----------------------------------------------------------------------------
   305                          ; tmsSetAddrPattTableIIBank1: Initialise address for pattern table
   306                          ; -----------------------------------------------------------------------------
   307                          !macro tmsSetAddrPattTableIIBank1 .ind {
   308                                  +tmsSetAddrPattTable 256 + .ind
   309                          }
   310                          
   311                          ; -----------------------------------------------------------------------------
   312                          ; tmsSetAddrPattTableIIBank2: Initialise address for pattern table
   313                          ; -----------------------------------------------------------------------------
   314                          !macro tmsSetAddrPattTableIIBank2 .ind {
   315                                  +tmsSetAddrPattTable 512 + .ind
   316                          }
   317                          
   318                          ; -----------------------------------------------------------------------------
   319                          ; tmsSetAddrPattTableRead: Initialise address for pattern table to read
   320                          ; -----------------------------------------------------------------------------
   321                          !macro tmsSetAddrPattTableRead .ind {
   322                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   323                          }
   324                          
   325                          ; -----------------------------------------------------------------------------
   326                          ; tmsSetAddrPattTableRowRead: Initialise address for pattern table to read
   327                          ; -----------------------------------------------------------------------------
   328                          !macro tmsSetAddrPattTableRead .ind, .row {
   329                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   330                          }
   331                          
   332                          ; -----------------------------------------------------------------------------
   333                          ; tmsUpdateFont: Update the pattern table with a given font
   334                          ; -----------------------------------------------------------------------------
   335                          !macro tmsUpdateFont .fontAddr {
   336                                  +tmsSetAddrPattTable 32
   337                                  +tmsSendData .fontAddr, $300
   338                          }
   339                          
   340                          ; -----------------------------------------------------------------------------
   341                          ; tmsSetAddrNameTable: Initialise address for base (text) table
   342                          ; -----------------------------------------------------------------------------
   343                          !macro tmsSetAddrNameTable {
   344                                  +tmsSetAddressWrite TMS_VRAM_NAME_ADDRESS
   345                          }
   346                          
   347                          ; -----------------------------------------------------------------------------
   348                          ; tmsSetAddrColorTable: Initialise address for color table
   349                          ; -----------------------------------------------------------------------------
   350                          !macro tmsSetAddrColorTable {
   351                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS
   352                          }
   353                          
   354                          ; -----------------------------------------------------------------------------
   355                          ; tmsSetAddrColorTable: Initialise address for color table index
   356                          ; -----------------------------------------------------------------------------
   357                          !macro tmsSetAddrColorTable .ind {
   358                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind
   359                          }
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; tmsSetAddrColorTableII: Initialise address for color table index (mode II)
   363                          ; -----------------------------------------------------------------------------
   364                          !macro tmsSetAddrColorTableII .ind {
   365                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind * 8
   366                          }
   367                          
   368                          ; -----------------------------------------------------------------------------
   369                          ; tmsSetAddrColorTableIIBank0: Initialise address for color table index (mode II)
   370                          ; -----------------------------------------------------------------------------
   371                          !macro tmsSetAddrColorTableIIBank0 .ind {
   372                                  +tmsSetAddrColorTableII .ind
   373                          }
   374                          
   375                          ; -----------------------------------------------------------------------------
   376                          ; tmsSetAddrColorTableIIBank1: Initialise address for color table index (mode II)
   377                          ; -----------------------------------------------------------------------------
   378                          !macro tmsSetAddrColorTableIIBank1 .ind {
   379                                  +tmsSetAddrColorTableII 256 + .ind
   380                          }
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; tmsSetAddrColorTableIIBank2: Initialise address for color table index (mode II)
   384                          ; -----------------------------------------------------------------------------
   385                          !macro tmsSetAddrColorTableIIBank2 .ind {
   386                                  +tmsSetAddrColorTableII 512 + .ind
   387                          }
   388                          
   389                          ; -----------------------------------------------------------------------------
   390                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   391                          ; -----------------------------------------------------------------------------
   392                          !macro tmsSetAddrSpriteAttrTable {
   393                                  +tmsSetAddrSpriteAttrTable 0
   394                          }
   395                          
   396                          ; -----------------------------------------------------------------------------
   397                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   398                          ; -----------------------------------------------------------------------------
   399                          !macro tmsSetAddrSpriteAttrTable .index {
   400                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + .index * 4
   401                          }
   402                          
   403                          ; -----------------------------------------------------------------------------
   404                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   405                          ; -----------------------------------------------------------------------------
   406                          !macro tmsSetAddrSpritePattTable {
   407                                  +tmsSetAddrSpritePattTable 0
   408                          }
   409                          
   410                          ; -----------------------------------------------------------------------------
   411                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   412                          ; -----------------------------------------------------------------------------
   413                          !macro tmsSetAddrSpritePattTable .index {
   414                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_PATT_ADDRESS + .index * 8
   415                          }
   416                          
   417                          
   418                          ; -----------------------------------------------------------------------------
   419                          ; tmsCreateSpritePattern: Create a sprite pattern (.spriteDataAddr is 8 bytes)
   420                          ; -----------------------------------------------------------------------------
   421                          !macro tmsCreateSpritePattern .pattInd, .spriteDataAddr {
   422                          
   423                                  
   424                          
   425                                  ; sprite pattern table
   426                                  +tmsSetAddrSpritePattTable .pattInd
   427                          
   428                                  ldx #0
   429                          -
   430                                  lda .spriteDataAddr,x
   431                                  +tmsPut
   432                                  inx
   433                                  cpx #8
   434                          
   435                                  
   436                          
   437                                  bne -
   438                          }
   439                          
   440                          ; -----------------------------------------------------------------------------
   441                          ; tmsCreateSpritePatternQuad: Create a (size 1) sprite pattern 
   442                          ;   (.spriteDataAddr is 32 bytes)
   443                          ; -----------------------------------------------------------------------------
   444                          !macro tmsCreateSpritePatternQuad .pattInd, .spriteDataAddr {
   445                          
   446                                  
   447                          
   448                                  ; sprite pattern table
   449                                  +tmsSetAddrSpritePattTable .pattInd * 4
   450                          
   451                                  ldx #0
   452                          -
   453                                  lda .spriteDataAddr,x
   454                                  +tmsPut 
   455                                  inx
   456                                  cpx #32
   457                          
   458                                  
   459                          
   460                                  bne -
   461                          }
   462                          
   463                          
   464                          !macro tmsCreateSpritePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   465                          
   466                                  ; sprite pattern table
   467                                  +tmsSetAddrSpritePattTable .ind
   468                                  +tmsPut .b0
   469                                  +tmsPut .b2
   470                                  +tmsPut .b2
   471                                  +tmsPut .b3
   472                                  +tmsPut .b4
   473                                  +tmsPut .b5
   474                                  +tmsPut .b6
   475                                  +tmsPut .b7
   476                          }
   477                          
   478                          !macro tmsCreatePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   479                          
   480                                  ; sprite pattern table
   481                                  +tmsSetAddrPattTable .ind
   482                                  +tmsPut .b0
   483                                  +tmsPut .b2
   484                                  +tmsPut .b2
   485                                  +tmsPut .b3
   486                                  +tmsPut .b4
   487                                  +tmsPut .b5
   488                                  +tmsPut .b6
   489                                  +tmsPut .b7
   490                          }
   491                          
   492                          
   493                          ; -----------------------------------------------------------------------------
   494                          ; tmsCreateSprite: Create a sprite
   495                          ; -----------------------------------------------------------------------------
   496                          !macro tmsCreateSprite .ind, .pattInd, .xPos, .yPos, .color {
   497                          
   498                                  ; sprite attr table
   499                                  +tmsSetAddrSpriteAttrTable .ind
   500                          
   501                                  +tmsPut .yPos
   502                                  +tmsPut .xPos
   503                                  +tmsPut .pattInd
   504                                  +tmsPut .color
   505                          }
   506                          
   507                          ; -----------------------------------------------------------------------------
   508                          ; tmsSpritePos: Set a sprite position
   509                          ; -----------------------------------------------------------------------------
   510                          !macro tmsSpritePos .ind, .xPos, .yPos {
   511                                  
   512                          
   513                                  ; sprite attr table
   514                                  +tmsSetAddrSpriteAttrTable .ind
   515                          
   516                                  +tmsPut .yPos
   517                                  +tmsPut .xPos        
   518                          }
   519                          
   520                          
   521                          ; -----------------------------------------------------------------------------
   522                          ; tmsSetLastSprite: Mark a sprite as the last sprite (set next ypos to )
   523                          ; -----------------------------------------------------------------------------
   524                          !macro tmsSetLastSprite .ind {
   525                                  +tmsSpritePos .ind + 1, 0, $d0
   526                          }
   527                          
   528                          
   529                          ; -----------------------------------------------------------------------------
   530                          ; tmsSpritePosXYReg: Set a sprite position from x/y registers
   531                          ; -----------------------------------------------------------------------------
   532                          !macro tmsSpritePosXYReg .ind {
   533                                  
   534                          
   535                                  ; sprite attr table
   536                                  +tmsSetAddrSpriteAttrTable .ind
   537                          
   538                                  tya
   539                                  +tmsPut 
   540                                  txa
   541                                  +tmsPut 
   542                          }
   543                          
   544                          
   545                          ; -----------------------------------------------------------------------------
   546                          ; tmsSetAddrSpriteColor: Change a sprite color
   547                          ; -----------------------------------------------------------------------------
   548                          !macro tmsSetAddrSpriteColor .ind {
   549                          
   550                                  ; sprite attr table
   551                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + (.ind * 4) + 3
   552                          }
   553                          ; -----------------------------------------------------------------------------
   554                          ; tmsSpriteColor: Change a sprite color
   555                          ; -----------------------------------------------------------------------------
   556                          !macro tmsSpriteColor .ind, .color {
   557                          
   558                                  +tmsSetAddrSpriteColor .ind
   559                          
   560                                  +tmsPut .color
   561                          }
   562                          
   563                          
   564                          ; -----------------------------------------------------------------------------
   565                          ; tmsSetPosWrite: Set cursor position
   566                          ; -----------------------------------------------------------------------------
   567                          !macro tmsSetPosWrite .x, .y {
   568                                  +tmsSetAddressWrite (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   569                          }
   570                          
   571                          ; -----------------------------------------------------------------------------
   572                          ; tmsSetPosRead: Set read cursor position
   573                          ; -----------------------------------------------------------------------------
   574                          !macro tmsSetPosRead .x, .y {
   575                                  +tmsSetAddressRead (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   576                          }
   577                          
   578                          ; -----------------------------------------------------------------------------
   579                          ; tmsPrint: Print immediate text
   580                          ; -----------------------------------------------------------------------------
   581                          ; Inputs:
   582                          ;  str: String to print
   583                          ;  x: x position
   584                          ;  y: y position
   585                          ; -----------------------------------------------------------------------------
   586                          !macro tmsPrint .str, .x, .y {
   587                          	jmp .afterText
   588                          .textAddr
   589                          	!text .str,0
   590                          .afterText        
   591                          
   592                                  +tmsSetPosWrite .x, .y
   593                          
   594                                  lda #<.textAddr
   595                                  sta STR_ADDR_L
   596                                  lda #>.textAddr
   597                                  sta STR_ADDR_H
   598                                  jsr tmsPrint        
   599                          }
   600                          
   601                          
   602                          ; -----------------------------------------------------------------------------
   603                          ; tmsPrintCentre: Print centre-aligned immediate text
   604                          ; -----------------------------------------------------------------------------
   605                          ; Inputs:
   606                          ;  str: String to print
   607                          ;  y: y position
   608                          ; -----------------------------------------------------------------------------
   609                          !macro tmsPrintCentre .str, .y {
   610                          	jmp .afterText
   611                          .textAddr
   612                          	!text .str,0
   613                          .afterText        
   614                          
   615                                  +tmsSetPosWrite (32 - ((.afterText - 1) - .textAddr)) / 2, .y
   616                          
   617                                  lda #<.textAddr
   618                                  sta STR_ADDR_L
   619                                  lda #>.textAddr
   620                                  sta STR_ADDR_H
   621                                  jsr tmsPrint        
   622                          }
   623                          
   624                          
   625                          ; -----------------------------------------------------------------------------
   626                          ; tmsPrintZ: Print text
   627                          ; -----------------------------------------------------------------------------
   628                          ; Inputs:
   629                          ;  str: Address of zero-terminated string to print
   630                          ;  x: x position
   631                          ;  y: y position
   632                          ; -----------------------------------------------------------------------------
   633                          !macro tmsPrintZ .textAddr, .x, .y {
   634                                  +tmsSetPosWrite .x, .y
   635                          
   636                                  lda #<.textAddr
   637                                  sta STR_ADDR_L
   638                                  lda #>.textAddr
   639                                  sta STR_ADDR_H
   640                                  jsr tmsPrint        
   641                          }

; ******** Source: ../../kernel\hbc56kernel.inc
    19                          

; ******** Source: ../../lib\gfx\tilemap.inc
     1                          ; 6502 - Tilemap
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          
    12                          
    13                          !macro tilemapCreate .tilemapStructAddr, .bufferAddr, .tilesetAddr, .sizeFlags, .tileSizePx, .invertAddr, .dirtyAddr {
    14                          	!if <.tilesetAddr != 0 { !error "tilemapCreate: Tileset address must be page-aligned",.tilesetAddr }
    15                          	!if >.tilesetAddr < 3 { !error "tilemapCreate: Tileset address must be greater than $2ff",.tilesetAddr }
    16                          	!if <.bufferAddr != 0 { !error "tilemapCreate: Buffer address must be page-aligned",.bufferAddr }
    17                          	!if >.bufferAddr < 3 { !error "tilemapCreate: Buffer address must be greater than $2ff",.bufferAddr }
    18                          	!if .invertAddr != 0 and <.invertAddr != 0  {!error "tilemapCreate: Invert address must be page-aligned", .invertAddr}
    19                          	!if .invertAddr != 0 and >.invertAddr < 3  {!error "tilemapCreate: Invert address must be greater than $2ff", .invertAddr}
    20                          	!if .dirtyAddr != 0 and <.dirtyAddr != 0  {!error "tilemapCreate: Dirty address must be page-aligned", .dirtyAddr}
    21                          	!if .dirtyAddr != 0 and >.dirtyAddr < 3  {!error "tilemapCreate: Dirty address must be greater than $2ff", .dirtyAddr}
    22                          	!if .tileSizePx != 4 and .tileSizePx != 8 {!error "tilemapCreate: Tile size must be 4 or 8 pixels",.tileSizePx}
    23                          
    24                          	lda #<.tilemapStructAddr
    25                          	sta TILEMAP_ADDR
    26                          	lda #>.tilemapStructAddr
    27                          	sta TILEMAP_ADDR + 1
    28                          
    29                          	lda #>.bufferAddr
    30                          	sta .tilemapStructAddr + TILEMAP_BUFFER_ADDR
    31                          	lda #.sizeFlags
    32                          	sta .tilemapStructAddr + TILEMAP_SIZE
    33                          	lda #>.tilesetAddr
    34                          	sta .tilemapStructAddr + TILEMAP_TILES_ADDR
    35                          	lda #>.invertAddr
    36                          	sta .tilemapStructAddr + TILEMAP_INVERT_ADDR
    37                          	lda #>.dirtyAddr
    38                          	sta .tilemapStructAddr + TILEMAP_DIRTY_ADDR
    39                          	lda #.tileSizePx
    40                          	sta .tilemapStructAddr + TILEMAP_TILE_SIZE_PX
    41                          
    42                          	jsr tilemapInit
    43                          }
    44                          
    45                          !macro tilemapCreateDefault .sizeFlags, .tilesetAddr {
    46                          	+tilemapCreate TILEMAP_FIXED_ADDRESS, TILEMAP_DEFAULT_BUFFER_ADDRESS, .tilesetAddr, .sizeFlags, 8, $0, $0
    47                          }
    48                          
    49                          !macro tilemapSetActive .tilemapStructAddr {
    50                          	lda #<.tilemapStructAddr
    51                          	sta TILEMAP_ADDR
    52                          	lda #>.tilemapStructAddr
    53                          	sta TILEMAP_ADDR + 1
    54                          
    55                          	jsr tilemapSetActive

; ******** Source: ../../kernel\hbc56kernel.inc
    20                          

; ******** Source: ../../lib\lcd\lcd.inc
     1                          ; 6502 LCD Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          ; -----------------------------------------------------------------------------
    11                          ; lcdPrint: Print immediate text
    12                          ; -----------------------------------------------------------------------------
    13                          ; Inputs:
    14                          ;  str: String to print
    15                          ; -----------------------------------------------------------------------------
    16                          !macro lcdPrint str {
    17                          	jmp +
    18                          .textAddr
    19                          	!text str,0
    20                          +
    21                          	lda #<.textAddr
    22                          	sta STR_ADDR_L
    23                          	lda #>.textAddr
    24                          	sta STR_ADDR_H
    25                          	jsr lcdPrint
    26                          }
    27                          
    28                          
    29                          ; -----------------------------------------------------------------------------
    30                          ; lcdChar: Print immediate character
    31                          ; -----------------------------------------------------------------------------
    32                          ; Inputs:
    33                          ;  c: Character to print
    34                          ; -----------------------------------------------------------------------------
    35                          !macro lcdChar c {
    36                          	pha
    37                          	lda #c
    38                          	jsr lcdChar
    39                          	pla
    40                          }
    41                          
    42                          
    43                          ; -----------------------------------------------------------------------------
    44                          ; lcdConsolePrint: Print immediate text to console
    45                          ; -----------------------------------------------------------------------------
    46                          ; Inputs:
    47                          ;  str: String to print
    48                          ; -----------------------------------------------------------------------------
    49                          !macro lcdConsolePrint .str {
    50                          	jmp .afterText
    51                          .textAddr
    52                          	!text .str,0
    53                          .afterText        
    54                          
    55                                  lda #<.textAddr
    56                                  sta STR_ADDR_L
    57                                  lda #>.textAddr
    58                                  sta STR_ADDR_H
    59                                  jsr lcdConsolePrint        

; ******** Source: ../../kernel\hbc56kernel.inc
    21                          

; ******** Source: ../../lib\inp\nes.inc
     1                          ; 6502 NES Controller Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ; Dependencies:
    10                          ;  - hbc56.asm
    11                          
    12                          
    13                          !macro nes1BranchIfPressed .buttonMask, .addr {
    14                                  pha
    15                                  lda #(.buttonMask)
    16                                  jsr nes1Pressed
    17                                  pla
    18                                  bcs .addr
    19                          }
    20                          
    21                          !macro nes1BranchIfNotPressed .buttonMask, .addr {
    22                                  pha
    23                                  lda #(.buttonMask)
    24                                  jsr nes1Pressed
    25                                  pla
    26                                  bcc .addr
    27                          }
    28                          
    29                          !macro nes2BranchIfPressed .buttonMask, addr {
    30                                  pha
    31                                  lda #(.buttonMask)
    32                                  jsr nes2Pressed
    33                                  pla
    34                                  bcs addr
    35                          }
    36                          
    37                          !macro nes2BranchIfNotPressed .buttonMask, addr {
    38                                  pha
    39                                  lda #(.buttonMask)
    40                                  jsr nes2Pressed
    41                                  pla
    42                                  bcc addr
    43                          }

; ******** Source: ../../kernel\hbc56kernel.inc
    22                          

; ******** Source: ../../lib\inp\keyboard.inc
     1                          ; 6502 KB Controller Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ; Dependencies:
    10                          ;  - hbc56.asm
    11                          
    12                          
    13                          !macro kbBranchIfNotPressed .scancode, .addr {
    14                                  ldx #.scancode
    15                                  jsr kbReadAscii
    16                                  beq .addr
    17                          }
    18                          
    19                          !macro kbBranchIfPressed .scancode, .addr {
    20                                  ldx #.scancode
    21                                  jsr kbIsPressed
    22                                  bne .addr
    23                          }
    24                          
    25                          !macro kbSetEventHandlerPressed .cb {
    26                                  lda #<.cb
    27                                  sta KB_CB_PRESSED
    28                                  lda #>.cb
    29                                  sta KB_CB_PRESSED + 1
    30                          }
    31                          
    32                          !macro kbSetEventHandlerReleased .cb {
    33                                  lda #<.cb
    34                                  sta KB_CB_RELEASED
    35                                  lda #>.cb
    36                                  sta KB_CB_RELEASED + 1

; ******** Source: ../../kernel\hbc56kernel.inc
    23                          

; ******** Source: ../../lib\sfx\ay3891x.inc
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          !macro ayWrite .dev, .reg, .val {
    13                                  lda #.reg
    14                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    15                                  lda #.val
    16                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    17                          }        
    18                          
    19                          !macro ayRead .dev, .reg {
    20                                  lda #.reg
    21                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    22                                  lda IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_READ | .dev
    23                          }        
    24                          
    25                          
    26                          !macro ayWriteX .dev, .reg {
    27                                  lda #.reg
    28                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    29                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    30                          }
    31                          
    32                          !macro ayWriteA .dev, .reg {
    33                                  ldx #.reg
    34                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    35                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    36                          }
    37                          
    38                          !macro ayPlayNote .dev, .chan, .freq {
    39                                  !if .freq <= 0 {
    40                                          .val = 0
    41                                  } else {
    42                                          .val = AY_CLOCK_FREQ / (32.0 * .freq)
    43                                  }
    44                                  +ayWrite .dev, AY_CHA_TONE_L + (.chan * 2), <.val
    45                                  +ayWrite .dev, AY_CHA_TONE_H + (.chan * 2), >.val
    46                          }
    47                          
    48                          !macro ayToneWord .freq {
    49                                  !word (AY_CLOCK_FREQ / (32.0 * .freq))
    50                          }
    51                          
    52                          !macro ayToneByteL .freq {
    53                                  !byte <(AY_CLOCK_FREQ / (32.0 * .freq))
    54                          }
    55                          
    56                          !macro ayToneByteH .freq {
    57                                  !byte >(AY_CLOCK_FREQ / (32.0 * .freq))
    58                          }
    59                          
    60                          
    61                          !macro ayToneEnable .dev, .chan {
    62                                  +ayRead .dev, AY_ENABLES
    63                                  and #!($01 << .chan)
    64                                  +ayWriteA .dev, AY_ENABLES
    65                          }
    66                          
    67                          !macro ayToneDisable .dev, .chan {
    68                                  +ayRead .dev, AY_ENABLES
    69                                  ora #($01 << .chan)
    70                                  +ayWriteA .dev, AY_ENABLES
    71                          }
    72                          
    73                          !macro ayNoiseEnable .dev, .chan {
    74                                  +ayRead .dev, AY_ENABLES
    75                                  eor #($08 << .chan)
    76                                  +ayWriteA .dev, AY_ENABLES
    77                          }
    78                          
    79                          !macro ayNoiseDisable .dev, .chan {
    80                                  +ayRead .dev, AY_ENABLES
    81                                  ora #($08 << .chan)
    82                                  +ayWriteA .dev, AY_ENABLES
    83                          }
    84                          
    85                          !macro aySetVolume .dev, .chan, .vol {
    86                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), (.vol >> 4)
    87                          }
    88                          
    89                          !macro aySetVolumeEnvelope .dev, .chan {
    90                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), $10
    91                          }
    92                          
    93                          !macro aySetEnvelopePeriod .dev, .period {
    94                                  +ayWrite .dev, AY_ENV_PERIOD_L, <.period
    95                                  +ayWrite .dev, AY_ENV_PERIOD_H, >.period
    96                          }
    97                          
    98                          !macro aySetEnvShape .dev, .shape {
    99                                  +ayWrite .dev, AY_ENV_SHAPE, .shape
   100                          }
   101                          
   102                          !macro aySetNoise .dev, .freq {
   103                                  +ayWrite .dev, AY_ENV_SHAPE, .freq >> 3
   104                          }
   105                          
   106                          !macro ayStop .dev, .chan {
   107                                  +ayPlayNote .dev, .chan, 0
   108                             ;     +ayWrite .dev, (AY_CHA_AMPL + .chan), 0
   109                          }

; ******** Source: ../../kernel\hbc56kernel.inc
    24                          

; ******** Source: ../../lib\ser\uart.inc
     1                          ; 6502 - MC68B50 UART Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          ; -----------------------------------------------------------------------------
    11                          ; uartOutStringAddr: Output a string to the uart
    12                          ; -----------------------------------------------------------------------------
    13                          ; Inputs:
    14                          ;  .addr: Address of null-terminated string to print
    15                          ; -----------------------------------------------------------------------------
    16                          !macro uartOutStringAddr .addr {
    17                                  lda #<.addr
    18                                  sta STR_ADDR_L
    19                                  lda #>.addr
    20                                  sta STR_ADDR_H
    21                                  jsr uartOutString        
    22                          }
    23                          
    24                          
    25                          ; -----------------------------------------------------------------------------
    26                          ; uartOutString: Output an immediate string to the uart
    27                          ; -----------------------------------------------------------------------------
    28                          ; Inputs:
    29                          ;  .str: String to output
    30                          ; -----------------------------------------------------------------------------
    31                          !macro uartOutString .str {
    32                          	jmp @afterText
    33                          @textAddr
    34                          	!text .str,0
    35                          @afterText        
    36                                  +uartOutStringAddr @textAddr
    37                          }
    38                          

; ******** Source: ../../kernel\hbc56kernel.inc
    25                          

; ******** Source: ../../kernel\kernel.inc
     1                          ; 6502 - HBC-56 Kernel Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !macro setIntHandler .address {
    12                                  lda #<.address
    13                                  sta HBC56_INT_VECTOR + 1
    14                                  lda #>.address
    15                                  sta HBC56_INT_VECTOR + 2
    16                                  lda #JMP_OPCODE
    17                                  sta HBC56_INT_VECTOR
    18                          }
    19                          
    20                          !macro setNmiHandler .address {
    21                                  lda #<.address
    22                                  sta HBC56_NMI_VECTOR + 1
    23                                  lda #>.address
    24                                  sta HBC56_NMI_VECTOR + 2
    25                                  lda #JMP_OPCODE
    26                                  sta HBC56_NMI_VECTOR
    27                          }
    28                          
    29                          !macro setHbcMetaNES {
    30                                  lda #HBC56_CONSOLE_FLAG_NES
    31                                  ora HBC56_CONSOLE_FLAGS
    32                                  sta HBC56_CONSOLE_FLAGS
    33                          }
    34                          
    35                          !macro setHbcMetaNoWait {
    36                                  lda #HBC56_CONSOLE_FLAG_NOWAIT
    37                                  ora HBC56_CONSOLE_FLAGS
    38                                  sta HBC56_CONSOLE_FLAGS
    39                          }
    40                          
    41                          
    42                          !macro hbc56SetVsyncCallback .vsync {
    43                                  lda #<.vsync
    44                                  sta HBC56_VSYNC_CALLBACK
    45                                  lda #>.vsync
    46                                  sta HBC56_VSYNC_CALLBACK + 1
    47                          }
    48                          
    49                          !macro hbc56SetViaCallback .cb {
    50                                  lda #<.cb
    51                                  sta HBC56_VIA_CALLBACK
    52                                  lda #>.cb
    53                                  sta HBC56_VIA_CALLBACK + 1
    54                          }
    55                          
    56                          
    57                          !macro setHbcMetaTitle .titleStr {
    58                                  jmp .hbcMetaTitleOut
    59                          .titleStrLabel:
    60                                  !text .titleStr
    61                          .titleStrLabelLen = * - .titleStrLabel
    62                                  !byte 0 ; nul terminator for game name
    63                          
    64                          !if .titleStrLabelLen > HBC56_META_TITLE_MAX_LEN {
    65                                  !error "setHbcMetaTitle: Title metadata limited to ",HBC56_META_TITLE_MAX_LEN,"bytes"
    66                          }
    67                          .hbcMetaTitleOut:
    68                                  +memcpy HBC56_META_TITLE + (HBC56_META_TITLE_MAX_LEN-.titleStrLabelLen)/2, .titleStrLabel, .titleStrLabelLen
    69                                  lda #.titleStrLabelLen
    70                                  sta HBC56_META_TITLE_LEN
    71                          }
    72                          
    73                          !macro consoleEnableCursor {
    74                                  lda HBC56_CONSOLE_FLAGS
    75                                  ora #HBC56_CONSOLE_FLAG_CURSOR
    76                                  sta HBC56_CONSOLE_FLAGS
    77                          }
    78                          
    79                          !macro consoleDisableCursor {
    80                                  lda HBC56_CONSOLE_FLAGS
    81                                  and #!HBC56_CONSOLE_FLAG_CURSOR & $ff
    82                                  sta HBC56_CONSOLE_FLAGS
    83                          }
    84                          
    85                          !macro consoleLCDMode {
    86                                  lda HBC56_CONSOLE_FLAGS
    87                                  ora #HBC56_CONSOLE_FLAG_LCD
    88                                  sta HBC56_CONSOLE_FLAGS
    89                          }
    90                          
    91                          !macro setBreakpoint {
    92                                 !byte $db 
    93                          }
    94                          
    95                          !macro hbc56CustomDelay .delay {
    96                                  ldy #.delay
    97                                  jsr hbc56CustomDelay
    98                          }
    99                          
   100                          !macro hbc56DelayUs .us {
   101                          !if .us = 1 {
   102                                  nop
   103                                  nop
   104                          }
   105                          }
   106                          !macro hbc56DelayMs .ms {
   107                                  lda #<.ms
   108                                  sta DELAY_L
   109                                  lda #>.ms
   110                                  sta DELAY_H
   111                          
   112                                  jsr hbc56CustomDelayMs

; ******** Source: ../../kernel\hbc56kernel.inc
    26                          
    27                          
    28                          !ifndef HBC_56_EXCLUDE_KERNEL_ROM {
    29                          
    30                                  ; if the program requires the kernal image
    31                                  ; then... include it
    32                          
    33                                  *=HBC56_META_VECTOR
    34                                  !ifdef hbc56Meta {
    35  dffc 4c0380                             jmp hbc56Meta
    36                                  } else {
    37                                          rts
    38                                  }
    39                          
    40                                  *=HBC56_KERNEL_START
    41  e000 c9619005c97b9002...        !bin "kernel.o"
    42                          
    43                                  *=DEFAULT_HBC56_RST_VECTOR
    44  8000 4c3080                     jmp hbc56Main
    45                          
    46                          } else {
    47                          
    48                                  ; otherwise, place the program in RAM
    49                          
    50                                  *=$0400

; ******** Source: tms9918mctest.asm
    10                          
    11                          
    12                          hbc56Meta:
    13  8003 4c1580544d53204d...        +setHbcMetaTitle "TMS MULTICOLOR"
    14  8027 a9400da37c8da37c           +setHbcMetaNES
    15  802f 60                         rts
    16                          
    17                          hbc56Main:
    18  8030 78                         sei
    19                          
    20  8031 20cbe6                     jsr tmsModeMulticolor
    21                          
    22  8034 a9f1                       +tmsColorFgBg TMS_WHITE, TMS_BLACK
    23  8036 20cfe5                     jsr tmsSetBackground
    24                          
    25  8039 0878a9008d117f20...        +tmsSetAddrNameTable
    26  804c a9518524a9818525...        +tmsSendData TMS_NAME_DATA, $300
    27                          
    28  8069 a94020e5e5                 +tmsEnableOutput
    29  806e a92020e5e5                 +tmsEnableInterrupts
    30                          loop:
    31                          
    32  8073 78                         sei
    33  8074 0878a9008d117f20...        +tmsSetAddrPattTable
    34  8087 a9518524a9848525...        +tmsSendData TMS_BIRD_DATA, $800
    35  80c7 58                         cli
    36                          
    37  80c8 203881                     jsr medDelay
    38  80cb 203881                     jsr medDelay
    39  80ce 203881                     jsr medDelay
    40  80d1 203881                     jsr medDelay
    41                          
    42  80d4 78                         sei
    43  80d5 0878a9008d117f20...        +tmsSetAddrPattTable
    44  80e8 a9518524a98c8525...        +tmsSendData TMS_PATTERN_DATA, $800
    45  8128 58                         cli
    46                          
    47  8129 203881                     jsr medDelay
    48  812c 203881                     jsr medDelay
    49  812f 203881                     jsr medDelay
    50  8132 203881                     jsr medDelay
    51                          
    52  8135 4c7380                     jmp loop
    53                          
    54                          medDelay:
    55  8138 204481             	jsr delay
    56  813b 204481             	jsr delay
    57  813e 204481             	jsr delay
    58  8141 204481             	jsr delay
    59                          
    60                          
    61                          delay:
    62  8144 a000               	ldy #0
    63                          customDelay:
    64  8146 a200               	ldx #0
    65                          -
    66  8148 ca                 	dex
    67  8149 d0fd               	bne -
    68  814b a200               	ldx #0
    69  814d 88                 	dey
    70  814e d0f8               	bne -
    71  8150 60                 	rts
    72                          
    73                          
    74                          
    75                          TMS_NAME_DATA:
    76                          
    77                          !for .y, 0, 23 {
    78                          !for .x, 0, 31 {
    79                                  !byte .x + ((.y & $fc) << 3)
    80                          }
    81  8151 0001020304050607...}
    82                          
    83                          TMS_BIRD_DATA:
    84  8451 cacaaccaac1cacc1...!bin "bird.bin"
    85                          
    86                          TMS_PATTERN_DATA:
    87  8c51 7717171711111111...!bin "mcmode.bin"

; ******** Source: kernel.asm
     1                          ; 6502 - HBC-56 Kernel
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          HBC56_INT_VECTOR = $7e00
    12                          HBC56_NMI_VECTOR = $7e04
    13                          HBC56_RST_VECTOR = kernelMain
    14                          
    15                          HBC56_KERNEL_START = $e000
    16                          HBC56_META_VECTOR  = HBC56_KERNEL_START-4
    17                          
    18                          RTI_OPCODE = $40
    19                          JMP_OPCODE = $4c
    20                          
    21                          ; -------------------------
    22                          ; I/O devices
    23                          ; -------------------------
    24                          LCD_IO_PORT             = $02
    25                          TMS9918_IO_PORT         = $10
    26                          UART_IO_PORT            = $20
    27                          AY_IO_PORT              = $40
    28                          KB_IO_PORT              = $80
    29                          NES_IO_PORT             = $82
    30                          INT_IO_PORT             = $df
    31                          VIA_IO_PORT             = $f0
    32                          ROM_BANK_REG            = $08
    33                          
    34                          ; -------------------------
    35                          ; Kernel Zero Page
    36                          ; -------------------------
    37                          HBC56_KERNEL_ZP_START   = $18
    38                          
    39                          TILEMAP_ZP_START        = HBC56_KERNEL_ZP_START
    40                          TILEMAP_ZP_END          = TILEMAP_ZP_START + 6
    41                          
    42                          BITMAP_ZP_START         = TILEMAP_ZP_END
    43                          BITMAP_ZP_END           = BITMAP_ZP_START + 6
    44                          
    45                          !ifdef HBC56_DISABLE_TMS9918 { .TMS_ZP_SIZE = 0 } else { .TMS_ZP_SIZE = 4 }
    46                          TMS9918_ZP_START        = BITMAP_ZP_END
    47                          TMS9918_ZP_END          = TMS9918_ZP_START + .TMS_ZP_SIZE
    48                          
    49                          !ifdef HBC56_DISABLE_LCD { .LCD_ZP_SIZE = 0 } else { .LCD_ZP_SIZE = 2 }
    50                          LCD_ZP_START            = TMS9918_ZP_END
    51                          LCD_ZP_END              = LCD_ZP_START + .LCD_ZP_SIZE
    52                          
    53                          !ifdef HBC56_DISABLE_UART { .UART_ZP_SIZE = 0 } else { .UART_ZP_SIZE = 4 }
    54                          UART_ZP_START            = LCD_ZP_END
    55                          UART_ZP_END              = UART_ZP_START + .UART_ZP_SIZE
    56                          
    57                          MEMORY_ZP_START         = UART_ZP_END
    58                          MEMORY_ZP_END           = MEMORY_ZP_START + 6
    59                          
    60                          STR_ADDR                = MEMORY_ZP_END
    61                          STR_ADDR_L              = MEMORY_ZP_END
    62                          STR_ADDR_H              = MEMORY_ZP_END + 1
    63                          
    64                          DELAY_L                 = STR_ADDR_H + 1
    65                          DELAY_H                 = DELAY_L + 1
    66                          
    67                          HBC56_KERNEL_ZP_END     = DELAY_H + 1
    68                          HBC56_USER_ZP_START     = HBC56_KERNEL_ZP_END
    69                          
    70                          ;!warn "Total ZP used: ",STR_ADDR_H-HBC56_KERNEL_ZP_START
    71                          
    72                          
    73                          !ifndef HAVE_TMS9918 { HBC56_DISABLE_SFXMAN=1 }
    74                          
    75                          ; -------------------------
    76                          ; Kernel RAM
    77                          ; -------------------------
    78                          HBC56_KERNEL_RAM_START  = $7a00
    79                          
    80                          TILEMAP_RAM_START       = HBC56_KERNEL_RAM_START
    81                          TILEMAP_RAM_END         = TILEMAP_RAM_START + $116
    82                          
    83                          BITMAP_RAM_START        = TILEMAP_RAM_END
    84                          BITMAP_RAM_END          = BITMAP_RAM_START + 16
    85                          
    86                          !ifdef HBC56_DISABLE_TMS9918 { .TMS_RAM_SIZE = 0 } else { .TMS_RAM_SIZE = 50 }
    87                          TMS9918_RAM_START       = BITMAP_RAM_END
    88                          TMS9918_RAM_END         = TMS9918_RAM_START + .TMS_RAM_SIZE
    89                          
    90                          !ifdef HBC56_DISABLE_LCD { .LCD_RAM_SIZE = 0 } else { .LCD_RAM_SIZE = 42 }
    91                          LCD_RAM_START           = TMS9918_RAM_END
    92                          LCD_RAM_END             = LCD_RAM_START + .LCD_RAM_SIZE
    93                          
    94                          !ifdef HBC56_DISABLE_UART { .UART_RAM_SIZE = 0 } else { .UART_RAM_SIZE = 256 }
    95                          UART_RAM_START            = LCD_RAM_END
    96                          UART_RAM_END              = UART_RAM_START + .UART_RAM_SIZE
    97                          
    98                          VIA_RAM_START             = UART_RAM_END
    99                          VIA_RAM_END               = VIA_RAM_START + 1
   100                          
   101                          !ifdef HBC56_DISABLE_SFXMAN { .SFXMAN_RAM_SIZE = 0 } else { .SFXMAN_RAM_SIZE = 18 }
   102                          SFXMAN_RAM_START        = VIA_RAM_END
   103                          SFXMAN_RAM_END          = SFXMAN_RAM_START + .SFXMAN_RAM_SIZE
   104                          
   105                          BCD_RAM_START           = SFXMAN_RAM_END
   106                          BCD_RAM_END             = BCD_RAM_START + 3
   107                          
   108                          KB_RAM_START            = BCD_RAM_END
   109                          KB_RAM_END              = KB_RAM_START + 64
   110                          
   111                          NES_RAM_START            = KB_RAM_END
   112                          NES_RAM_END              = NES_RAM_START + 3
   113                          
   114                          LAST_MODULE_RAM_END     = NES_RAM_END
   115                          
   116                          HBC56_TICKS             = LAST_MODULE_RAM_END
   117                          HBC56_SECONDS_L         = LAST_MODULE_RAM_END + 1
   118                          HBC56_SECONDS_H         = LAST_MODULE_RAM_END + 2
   119                          HBC56_TMP               = LAST_MODULE_RAM_END + 3
   120                          
   121                          HBC56_CONSOLE_FLAGS     = LAST_MODULE_RAM_END + 4
   122                          HBC56_CONSOLE_FLAG_CURSOR = $80
   123                          HBC56_CONSOLE_FLAG_NES    = $40
   124                          HBC56_CONSOLE_FLAG_LCD    = $20
   125                          HBC56_CONSOLE_FLAG_NOWAIT = $10
   126                          
   127                          HBC56_TMP_X             = LAST_MODULE_RAM_END + 5
   128                          HBC56_TMP_Y             = LAST_MODULE_RAM_END + 6
   129                          
   130                          HBC56_META_TITLE_MAX_LEN = 16
   131                          HBC56_META_TITLE        = LAST_MODULE_RAM_END + 7
   132                          HBC56_META_TITLE_END    = HBC56_META_TITLE + HBC56_META_TITLE_MAX_LEN + 1
   133                          HBC56_META_TITLE_LEN    = HBC56_META_TITLE_END + 1
   134                          
   135                          ; callback function on vsync
   136                          HBC56_VSYNC_CALLBACK = HBC56_META_TITLE_LEN + 1
   137                          HBC56_VIA_CALLBACK   = HBC56_VSYNC_CALLBACK + 2
   138                          
   139                          
   140                          HBC56_KERNEL_RAM_END    = HBC56_VIA_CALLBACK + 2
   141                          HBC56_KERNEL_RAM_SIZE   = HBC56_KERNEL_RAM_END - HBC56_KERNEL_RAM_START
   142                          ;!warn "Total RAM used: ",HBC56_KERNEL_RAM_SIZE
   143                          

; ******** Source: ../lib\hbc56.asm
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !cpu w65c02
    12                          !initmem $FF
    13                          cputype = $65c02
    14                          

; ******** Source: ../lib\hbc56.inc
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; Base address of the 256 IO port memory range
    12                          IO_PORT_BASE_ADDRESS	= $7f00
    13                          
    14                          
    15                          ; -------------------------
    16                          ; ASCII constants
    17                          ; -------------------------
    18                          ASCII_RETURN    = $0A
    19                          ASCII_CR        = $0D
    20                          ASCII_BACKSPACE = $08
    21                          ASCII_BELL      = $07

; ******** Source: ../lib\hbc56.asm
    16                          
    17                          DEFAULT_HBC56_NMI_VECTOR = $FFE0
    18                          DEFAULT_HBC56_RST_VECTOR = $8000
    19                          DEFAULT_HBC56_INT_VECTOR = $FFE0
    20                          
    21                          !macro hbc56Title .title {
    22                          HBC56_TITLE_TEXT:
    23                                  !text .title
    24                          HBC56_TITLE_TEXT_LEN = * - HBC56_TITLE_TEXT
    25                                  !byte 0 ; nul terminator for game name
    26                          }
    27                          
    28                          *=DEFAULT_HBC56_INT_VECTOR
    29  ffe0 40                         rti
    30                          
    31                          hbc56Delay:
    32  ffe1 a000               	ldy #0
    33                          hbc56CustomDelay:
    34  ffe3 a200               	ldx #0
    35                          -
    36  ffe5 ca                 	dex
    37  ffe6 d0fd               	bne -
    38  ffe8 a200               	ldx #0
    39  ffea 88                 	dey
    40  ffeb d0f8               	bne -
    41  ffed 60                 	rts
    42                          
    43                          *=$FFFA
    44  fffa 047e               !ifdef HBC56_NMI_VECTOR { !word HBC56_NMI_VECTOR } else { !word DEFAULT_HBC56_NMI_VECTOR }
    45  fffc 77f1               !ifdef HBC56_RST_VECTOR { !word HBC56_RST_VECTOR } else { !word DEFAULT_HBC56_RST_VECTOR }
    46  fffe 007e               !ifdef HBC56_INT_VECTOR { !word HBC56_INT_VECTOR } else { !word DEFAULT_HBC56_INT_VECTOR }
    47                          
    48                          
    49                          *=DEFAULT_HBC56_RST_VECTOR

; ******** Source: kernel.asm
   144                          
   145                          *=HBC56_KERNEL_START
   146                          

; ******** Source: ../lib\ut\ascii.asm
     1                          ; 6502 - ASCII subroutines
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; -----------------------------------------------------------------------------
    12                          ; isLower: Is the ASCII character a lower-case letter (a-z)
    13                          ; -----------------------------------------------------------------------------
    14                          ; Inputs:
    15                          ;   A: ASCII character
    16                          ; Outputs:
    17                          ;   Carry set if lower case, carry clear if not lower case
    18                          ; -----------------------------------------------------------------------------
    19                          isLower:
    20  e000 c961                       cmp #'a'
    21  e002 9005                       bcc @notLower   ; less than 'a'?
    22  e004 c97b                       cmp #'z' + 1
    23  e006 9002                       bcc @isLower    ; less than or equal 'z'?
    24  e008 18                         clc
    25                          @notLower:
    26  e009 60                         rts
    27                          
    28                          @isLower
    29  e00a 38                         sec
    30  e00b 60                         rts
    31                          
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; isUpper: Is the ASCII character a upper-case letter (A-Z)
    35                          ; -----------------------------------------------------------------------------
    36                          ; Inputs:
    37                          ;   A: ASCII character
    38                          ; Outputs:
    39                          ;   Carry set if upper case, carry clear if not upper case
    40                          ; -----------------------------------------------------------------------------
    41                          isUpper:
    42  e00c c941                       cmp #'A'
    43  e00e 9005                       bcc @notUpper   ; less than 'A'?
    44  e010 c95b                       cmp #'Z' + 1
    45  e012 9002                       bcc @isUpper    ; less than or equal 'Z'?
    46  e014 18                         clc
    47                          @notUpper:
    48  e015 60                         rts
    49                          
    50                          @isUpper
    51  e016 38                         sec
    52  e017 60                         rts
    53                          
    54                          ; -----------------------------------------------------------------------------
    55                          ; isAlpha: Is the ASCII character alphanumeric (A-Z, a-z)
    56                          ; -----------------------------------------------------------------------------
    57                          ; Inputs:
    58                          ;   A: ASCII character
    59                          ; Outputs:
    60                          ;   Carry set if alpha, carry clear if not alpha
    61                          ; -----------------------------------------------------------------------------
    62                          isAlpha:
    63  e018 2000e0                     jsr isLower
    64  e01b 90ef                       bcc isUpper
    65  e01d 60                         rts
    66                          
    67                          
    68                          ; -----------------------------------------------------------------------------
    69                          ; isDigit: Is the ASCII character a decimal digit (0-9)
    70                          ; -----------------------------------------------------------------------------
    71                          ; Inputs:
    72                          ;   A: ASCII character
    73                          ; Outputs:
    74                          ;   Carry set if digit, carry clear if not digit
    75                          ; -----------------------------------------------------------------------------
    76                          isDigit:
    77  e01e c930                       cmp #'0'
    78  e020 9005                       bcc @notDigit    ; less than '0'?
    79  e022 c93a                       cmp #'9' + 1
    80  e024 9002                       bcc @isDigit     ; less than or equal '9'?
    81  e026 18                         clc
    82                          
    83                          @notDigit:
    84  e027 60                         rts
    85                          
    86                          @isDigit
    87  e028 38                         sec
    88  e029 60                         rts
    89                          
    90                          
    91                          ; -----------------------------------------------------------------------------
    92                          ; isAlNum: Is the ASCII character alphanumeric (A-Z, a-z, 0-9)
    93                          ; -----------------------------------------------------------------------------
    94                          ; Inputs:
    95                          ;   A: ASCII character
    96                          ; Outputs:
    97                          ;   Carry set if alphanumeric, carry clear if not alphanumeric
    98                          ; -----------------------------------------------------------------------------
    99                          isAlNum:
   100  e02a 2018e0                     jsr isAlpha
   101  e02d 90ef                       bcc isDigit
   102  e02f 60                         rts
   103                          
   104                          ; -----------------------------------------------------------------------------
   105                          ; isDigitX: Is the ASCII character a hex digit (A-F, a-f, 0-9)
   106                          ; -----------------------------------------------------------------------------
   107                          ; Inputs:
   108                          ;   A: ASCII character
   109                          ; Outputs:
   110                          ;   Carry set if hexadecimal, carry clear if not hexadecimal
   111                          ; -----------------------------------------------------------------------------
   112                          isDigitX:
   113  e030 201ee0                     jsr isDigit
   114  e033 b013                       bcs @endIsDigitX
   115  e035 c941                       cmp #'A'
   116  e037 900d                       bcc @notHexDigit   ; less than 'A'?
   117  e039 c947                       cmp #'F' + 1
   118  e03b 900a                       bcc @isHexDigit    ; less than or equal 'F'?
   119  e03d c961                       cmp #'a'
   120  e03f 9005                       bcc @notHexDigit   ; less than 'a'?
   121  e041 c967                       cmp #'f' + 1
   122  e043 9002                       bcc @isHexDigit    ; less than or equal 'f'?
   123  e045 18                         clc
   124                          @notHexDigit:
   125  e046 60                         rts
   126                          
   127                          @isHexDigit
   128  e047 38                         sec
   129                          
   130                          @endIsDigitX
   131  e048 60                         rts
   132                          
   133                          
   134                          ; -----------------------------------------------------------------------------
   135                          ; isSpace: Is the ASCII character a whitespace character?
   136                          ; -----------------------------------------------------------------------------
   137                          ; Inputs:
   138                          ;   A: ASCII character
   139                          ; Outputs:
   140                          ;   Carry set if space, carry clear if not space
   141                          ; -----------------------------------------------------------------------------
   142                          isSpace:
   143  e049 c920                       cmp #' '
   144  e04b f01c                       beq @isSpace
   145  e04d b018                       bcs @notSpace
   146  e04f c90a                       cmp #'\n'
   147  e051 f016                       beq @isSpace
   148  e053 c90d                       cmp #'\r'
   149  e055 f012                       beq @isSpace
   150  e057 c909                       cmp #'\t'
   151  e059 f00e                       beq @isSpace
   152  e05b c90d                       cmp #'\r'
   153  e05d f00a                       beq @isSpace
   154  e05f c90b                       cmp #$0b
   155  e061 f006                       beq @isSpace
   156  e063 c90c                       cmp #$0c
   157  e065 f002                       beq @isSpace
   158                          
   159                          @notSpace:
   160  e067 18                         clc
   161  e068 60                         rts
   162                          
   163                          @isSpace
   164  e069 38                         sec
   165  e06a 60                         rts
   166                          
   167                          ; -----------------------------------------------------------------------------
   168                          ; toUpper: convert an ascii character to upper case
   169                          ; -----------------------------------------------------------------------------
   170                          ; Inputs:
   171                          ;   A: ascii character
   172                          ; Outputs:
   173                          ;   A: upper case ascii character
   174                          ;   C: set if character was converted
   175                          ; -----------------------------------------------------------------------------
   176                          toUpper:
   177  e06b 2000e0                     jsr isLower
   178  e06e 9002                       bcc @endToUpper
   179  e070 4920                       eor #$20        ; convert (subtract $20)
   180                          
   181                          @endToUpper
   182  e072 60                         rts        
   183                          
   184                          ; -----------------------------------------------------------------------------
   185                          ; toLower: convert an ascii character to lower case
   186                          ; -----------------------------------------------------------------------------
   187                          ; Inputs:
   188                          ;   A: ascii character
   189                          ; Outputs:
   190                          ;   A: lower case ascii character
   191                          ;   C: set if character was converted
   192                          ; -----------------------------------------------------------------------------
   193                          toLower:
   194  e073 200ce0                     jsr isUpper
   195  e076 9002                       bcc @endToUpper
   196                          
   197  e078 0920                       ora #$20        ; convert (add $20)
   198                          
   199                          @endToUpper

; ******** Source: kernel.asm
   147  e07a 60                 

; ******** Source: ../lib\ut\bcd.asm
     1                          ; 6502 - BCD subroutines
     2                          ;
     3                          ; Copyright (c) 2020 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          
    12                          !ifndef BCD_RAM_START { BCD_RAM_START = $7810
    13                                  !warn "BCD_RAM_START not provided. Defaulting to ", BCD_RAM_START
    14                          }
    15                          
    16                          ; -------------------------
    17                          ; High RAM
    18                          ; -------------------------
    19                          BCD_TMP1	= BCD_RAM_START
    20                          BCD_TMP2	= BCD_RAM_START + 1
    21                          BCD_TMP3	= BCD_RAM_START + 2
    22                          .BCD_RAM_SIZE	= 3
    23                          
    24                          !if BCD_RAM_END < (BCD_RAM_START + .BCD_RAM_SIZE) {
    25                          	!error "BCD_RAM requires ",BCD_RAM_SIZE," bytes. Allocated ",BCD_RAM_END - BCD_RAM_START
    26                          }
    27                          
    28                          
    29                          ; -----------------------------------------------------------------------------
    30                          ; bin2bcd8: convert an unsigned byte to a 2-digit bcd value
    31                          ; -----------------------------------------------------------------------------
    32                          ; Inputs:
    33                          ;   A: value
    34                          ; Outputs:
    35                          ;   BCD value in R8
    36                          ; -----------------------------------------------------------------------------
    37                          bin2bcd8:
    38  e07b 8d597c               sta BCD_TMP1
    39  e07e a900                 lda #0
    40  e080 8d5a7c               sta BCD_TMP2
    41  e083 8d5b7c               sta BCD_TMP3
    42  e086 a208                 ldx #8 
    43  e088 f8                   sed    
    44                          .loop:
    45  e089 0e597c               asl BCD_TMP1
    46  e08c ad5a7c               lda BCD_TMP2
    47  e08f 6d5a7c               adc BCD_TMP2
    48  e092 8d5a7c               sta BCD_TMP2
    49  e095 ad5b7c               lda BCD_TMP3
    50  e098 6d5b7c               adc BCD_TMP3
    51  e09b 8d5b7c               sta BCD_TMP3
    52  e09e ca                   dex
    53  e09f d0e8                 bne .loop
    54  e0a1 d8                   cld   
    55  e0a2 60                   rts
    56                          

; ******** Source: kernel.asm
   148                          

; ******** Source: ../lib\ut\memory.asm
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          

; ******** Source: ../lib\ut\memory.inc
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; store16: Write a 16-bit immediate value to memory
    15                          ; -----------------------------------------------------------------------------
    16                          ; Inputs:
    17                          ;	.dst: destination address
    18                          ;	.val16: 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          !macro store16 .dst, .val16 {
    21                                  lda #<.val16
    22                                  sta .addr
    23                                  lda #>.val16
    24                                  sta .addr + 1
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; memcpy: Copy a fixed number of bytes from .src to dest
    29                          ; -----------------------------------------------------------------------------
    30                          ; Inputs:
    31                          ;	.src: source address
    32                          ;	.dst: destination address
    33                          ;	.cnt: number of bytes
    34                          ; -----------------------------------------------------------------------------
    35                          !macro memcpy .dst, .src, .cnt {
    36                          !if .cnt <= 0 {
    37                          	!error "memcpy: invalid count: ", .cnt
    38                          } else if .cnt <= 8 {
    39                          	!for i, 0, .cnt - 1 {
    40                          		lda .src + i
    41                          		sta .dst + i
    42                          	}
    43                          } else { !if .cnt <= 256 {
    44                          	ldx #0
    45                          -
    46                          	lda .src, x
    47                          	sta .dst, x
    48                          	inx
    49                          	cpx #(.cnt & $ff)	
    50                          	bne -
    51                          } else {
    52                          	lda #<.src
    53                          	sta MEM_SRC
    54                          	lda #>.src
    55                          	sta MEM_SRC + 1
    56                          
    57                          	lda #<.dst
    58                          	sta MEM_DST
    59                          	lda #>.dst
    60                          	sta MEM_DST + 1
    61                          
    62                          
    63                          		lda #<.cnt
    64                          		sta MEM_LEN
    65                          		lda #>.cnt
    66                          		sta MEM_LEN + 1
    67                          		jsr memcpyMultiPage
    68                          	}
    69                          }
    70                          }
    71                          
    72                          !macro setMemCpySrc .src {
    73                          	lda #<.src
    74                          	sta MEM_SRC
    75                          	lda #>.src
    76                          	sta MEM_SRC + 1
    77                          }
    78                          
    79                          !macro setMemCpyDst .dst {
    80                          	lda #<.dst
    81                          	sta MEM_DST
    82                          	lda #>.dst
    83                          	sta MEM_DST + 1
    84                          }
    85                          
    86                          !macro setMemCpySrcInd .srcRef {
    87                          	lda .srcRef
    88                          	sta MEM_SRC
    89                          	lda .srcRef + 1
    90                          	sta MEM_SRC + 1
    91                          }
    92                          
    93                          !macro setMemCpyDstInd .dstRef {
    94                          	lda .dstRef
    95                          	sta MEM_DST
    96                          	lda .dstRef + 1
    97                          	sta MEM_DST + 1
    98                          }
    99                          
   100                          !macro memcpySinglePage .bytes {
   101                          
   102                          	!if .bytes <= 0 {
   103                          		!error "memcpySinglePage: invalid count: ", .bytes
   104                          	}	
   105                          
   106                          	ldy #.bytes
   107                          	jsr memcpySinglePage
   108                          }
   109                          
   110                          
   111                          ; -----------------------------------------------------------------------------
   112                          ; memcpyPort: Copy a fixed number of bytes from .src ram to dest port
   113                          ; -----------------------------------------------------------------------------
   114                          ; Inputs:
   115                          ;	.src: source address
   116                          ;	.dst: destination address
   117                          ;	.cnt: number of bytes
   118                          ; -----------------------------------------------------------------------------
   119                          !macro memcpyPort .dst, .src, .cnt {
   120                          	!if .cnt <= 0 {
   121                          		!error "memcpyPort: invalid count: ", .cnt
   122                          	}
   123                          	
   124                          	lda #<.src
   125                          	sta MEM_SRC
   126                          	lda #>.src
   127                          	sta MEM_SRC + 1
   128                          
   129                          	lda #<.dst
   130                          	sta MEM_DST
   131                          	lda #>.dst
   132                          	sta MEM_DST + 1
   133                          
   134                          	!if .cnt <= 256 {
   135                          		ldy #<.cnt					
   136                          		jsr memcpySinglePagePort
   137                          	} else {
   138                          		lda #<.cnt
   139                          		sta MEM_LEN
   140                          		lda #>.cnt
   141                          		sta MEM_LEN + 1
   142                          		jsr memcpyMultiPagePort
   143                          	}
   144                          }
   145                          
   146                          !zone {
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; memset: Set a fixed number of bytes to a single value
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;	.dst: destination address
   153                          ;	val: the byte value
   154                          ;	.cnt: number of bytes
   155                          ; -----------------------------------------------------------------------------
   156                          !macro memset .dst, .val, .cnt {
   157                          !if .cnt <= 0 {
   158                          	!error "memset: invalid count: ", .cnt
   159                          } else if .cnt <= 8 {
   160                          	lda #.val
   161                          	!for i, 0, .cnt - 1 {
   162                          	sta .dst + i
   163                          	}
   164                          } else if .cnt <= 256 {
   165                          	ldx #<.cnt
   166                          	lda #.val
   167                          -
   168                          	dex
   169                          	sta .dst, x
   170                          	cpx #0
   171                          	bne -
   172                          } else {
   173                          	lda #<.dst
   174                          	sta MEM_DST
   175                          	lda #>.dst
   176                          	sta MEM_DST + 1
   177                          	lda #<.cnt
   178                          	sta MEM_LEN
   179                          	lda #>.cnt
   180                          	sta MEM_LEN + 1
   181                          	lda #.val
   182                          	jsr memsetMultiPage
   183                          }
   184                          }
   185                          
   186                          

; ******** Source: ../lib\ut\memory.asm
    14                          
    15                          
    16                          !ifndef MEMORY_ZP_START { MEMORY_ZP_START = $48
    17                                  !warn "MEMORY_ZP_START not provided. Defaulting to ", MEMORY_ZP_START
    18                          }
    19                          
    20                          ; -------------------------
    21                          ; Zero page
    22                          ; -------------------------
    23                          MEM_DST	= MEMORY_ZP_START
    24                          MEM_SRC	= MEMORY_ZP_START + 2
    25                          MEM_LEN	= MEMORY_ZP_START + 4
    26                          MEMORY_ZP_SIZE	= 6
    27                          
    28                          
    29                          !if MEMORY_ZP_END < (MEMORY_ZP_START + MEMORY_ZP_SIZE) {
    30                          	!error "MEMORY_ZP requires ",MEMORY_ZP_SIZE," bytes. Allocated ",MEMORY_ZP_END - MEMORY_ZP_START
    31                          }
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; memcpySinglePage: Copy up to 255 bytes 
    35                          ; -----------------------------------------------------------------------------
    36                          ; Inputs:
    37                          ;	MEM_SRC: src address
    38                          ;	MEM_DST: dst address
    39                          ;	Y:	bytes
    40                          ; -----------------------------------------------------------------------------
    41                          memcpySinglePage:
    42  e0a3 c000               	cpy #0
    43  e0a5 f009               	beq .endMemcpySinglePage
    44                          -
    45  e0a7 88                 	dey
    46  e0a8 b12e               	lda (MEM_SRC), Y
    47  e0aa 912c               	sta (MEM_DST), Y
    48  e0ac c000               	cpy #0
    49  e0ae d0f7               	bne -
    50                          .endMemcpySinglePage:
    51  e0b0 60                 	rts
    52                          ; -----------------------------------------------------------------------------
    53                          
    54                          
    55                          
    56                          ; -----------------------------------------------------------------------------
    57                          ; memcpySinglePagePort: Copy up to 255 bytes 
    58                          ; -----------------------------------------------------------------------------
    59                          ; Inputs:
    60                          ;	MEM_SRC: src address
    61                          ;	MEM_DST: dst address (port)
    62                          ;	Y:	bytes
    63                          ; -----------------------------------------------------------------------------
    64                          memcpySinglePagePort:
    65  e0b1 c000               	cpy #0
    66  e0b3 f009               	beq .endMemcpySinglePagePort
    67                          -
    68  e0b5 88                 	dey
    69  e0b6 b12e               	lda (MEM_SRC), Y
    70  e0b8 852c               	sta MEM_DST
    71  e0ba c000               	cpy #0
    72  e0bc d0f7               	bne -
    73                          .endMemcpySinglePagePort
    74  e0be 60                 	rts
    75                          ; -----------------------------------------------------------------------------
    76                          
    77                          
    78                          
    79                          ; -----------------------------------------------------------------------------
    80                          ; memcpyMultiPage: Copy an up to 2^15 bytes 
    81                          ; -----------------------------------------------------------------------------
    82                          ; Inputs:
    83                          ;	MEM_SRC: src address
    84                          ;	MEM_DST: dst address
    85                          ;	MEM_LEN: length
    86                          ; -----------------------------------------------------------------------------
    87                          memcpyMultiPage:
    88                          
    89                          !ifdef ALLOW_SELF_MODIFYING_CODE {
    90                          	lda MEM_SRC
    91                          	sta .loadIns + 1
    92                          	lda MEM_SRC + 1
    93                          	sta .loadIns + 2
    94                          
    95                          	lda MEM_DST
    96                          	sta .storeIns + 1
    97                          	lda MEM_DST + 1
    98                          	sta .storeIns + 2
    99                          
   100                          .loadIns:
   101                          	lda SELF_MODIFY_ADDR, Y
   102                          	
   103                          .storeIns:
   104                          	sta SELF_MODIFY_ADDR, Y
   105                          	dey
   106                          	bne .loadIns
   107                          	inc .loadIns + 2
   108                          	inc .storeIns + 2
   109                          	dex
   110                          	bne .loadIns
   111                          } else {
   112  e0bf a000               	ldy #0
   113  e0c1 a631               	ldx MEM_LEN + 1
   114                          - 
   115  e0c3 b12e               	lda (MEM_SRC),y ; could unroll to any power of 2
   116  e0c5 912c               	sta (MEM_DST),y
   117  e0c7 c8                 	iny
   118  e0c8 d0f9               	bne -
   119  e0ca ca                 	dex
   120  e0cb f007               	beq .memcpyMultiPageRemaining
   121  e0cd e62f               	inc MEM_SRC + 1
   122  e0cf e62d               	inc MEM_DST + 1
   123  e0d1 4cc3e0             	jmp -
   124                          .memcpyMultiPageRemaining ; remaining bytes
   125  e0d4 a630               	ldx MEM_LEN
   126  e0d6 f008               	beq .memcpyMultiPageEnd
   127                          - ; X bytes
   128  e0d8 b12e               	lda (MEM_SRC),y
   129  e0da 912c               	sta (MEM_DST),y
   130  e0dc c8                 	iny
   131  e0dd ca                 	dex
   132  e0de d0f8               	bne -
   133                          .memcpyMultiPageEnd
   134                          }
   135                          
   136  e0e0 60                 	rts
   137                          ; -----------------------------------------------------------------------------
   138                          
   139                          
   140                          ; -----------------------------------------------------------------------------
   141                          ; memcpyMultiPagePort: Copy an up to 2^15 bytes 
   142                          ; -----------------------------------------------------------------------------
   143                          ; Inputs:
   144                          ;	MEM_SRC: src address
   145                          ;	MEM_DST: dst address (port)
   146                          ;	MEM_LEN: length
   147                          ; -----------------------------------------------------------------------------
   148                          memcpyMultiPagePort:
   149                          
   150  e0e1 a000               	ldy #0
   151  e0e3 a631               	ldx MEM_LEN + 1
   152                          - 
   153  e0e5 b12e               	lda (MEM_SRC),y ; could unroll to any power of 2
   154  e0e7 852c               	sta MEM_DST
   155  e0e9 c8                 	iny
   156  e0ea d0f9               	bne -
   157  e0ec ca                 	dex
   158  e0ed f005               	beq .memcpyMultiPagePortRemaining
   159  e0ef e62f               	inc MEM_SRC + 1
   160  e0f1 4ce5e0             	jmp -
   161                          .memcpyMultiPagePortRemaining ; remaining bytes
   162  e0f4 a630               	ldx MEM_LEN
   163  e0f6 f008               	beq .memcpyMultiPagePortEnd
   164                          - ; X bytes
   165  e0f8 b12e               	lda (MEM_SRC),y
   166  e0fa 852c               	sta MEM_DST
   167  e0fc c8                 	iny
   168  e0fd ca                 	dex
   169  e0fe d0f8               	bne -
   170                          .memcpyMultiPagePortEnd
   171  e100 60                 	rts
   172                          ; -----------------------------------------------------------------------------
   173                          
   174                          
   175                          ; -----------------------------------------------------------------------------
   176                          ; memsetSinglePage: set a block of memory data
   177                          ; -----------------------------------------------------------------------------
   178                          ; Inputs:
   179                          ;	 A:	value to set
   180                          ;	 MEM_DST: start address
   181                          ;	 Y:	bytes
   182                          ; -----------------------------------------------------------------------------
   183                          memsetSinglePage:
   184  e101 c000               	cpy #0
   185  e103 f007               	beq .doneCpy
   186                          -
   187  e105 88                 	dey
   188  e106 912c               	sta (MEM_DST), y
   189  e108 c000               	cpy #0
   190  e10a d0f9               	bne -
   191                          .doneCpy
   192  e10c 60                 	rts
   193                          
   194                          
   195                          ; -----------------------------------------------------------------------------
   196                          ; memsetMultiPage: set a block of memory data
   197                          ; -----------------------------------------------------------------------------
   198                          ; Inputs:
   199                          ;	 A: value
   200                          ;	 MEM_DST: start address
   201                          ;	 MEM_LEN: length
   202                          ; -----------------------------------------------------------------------------
   203                          memsetMultiPage:
   204  e10d a631               	ldx MEM_LEN + 1
   205  e10f d005               	bne .doneSet
   206  e111 a430               	ldy MEM_LEN
   207  e113 4c01e1             	jmp memsetSinglePage
   208                          .doneSet
   209  e116 a000               	ldy #0
   210                          - 
   211  e118 912c               	sta (MEM_DST),y ; could unroll to any power of 2
   212  e11a c8                 	iny
   213  e11b d0fb               	bne -
   214  e11d ca                 	dex
   215  e11e f005               	beq .doneSet2
   216  e120 e62d               	inc MEM_DST + 1
   217  e122 4c18e1             	jmp -
   218                          .doneSet2 ; remaining bytes
   219  e125 a630               	ldx MEM_LEN
   220  e127 f006               	beq .doneSet3
   221                          - ; X bytes
   222  e129 912c               	sta (MEM_DST),y
   223  e12b c8                 	iny
   224  e12c ca                 	dex
   225  e12d d0fa               	bne -
   226                          .doneSet3
   227  e12f 60                 	rts

; ******** Source: kernel.asm
   149                          

; ******** Source: ../lib\ut\tables.asm
     1                          ; 6502 - Useful tables
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          tableBitFromLeft:
    12  e130 8040201008040201   !byte $80,$40,$20,$10,$08,$04,$02,$01
    13                          tableInvBitFromLeft:
    14  e138 7fbfdfeff7fbfdfe   !byte $7f,$bf,$df,$ef,$f7,$fb,$fd,$fe
    15                          tableBitFromRight:
    16  e140 0102040810204080   !byte $01,$02,$04,$08,$10,$20,$40,$80
    17                          tableInvBitFromRight:
    18  e148 fefdfbf7efdfbf7f   !byte $fe,$fd,$fb,$f7,$ef,$df,$bf,$7f
    19                          tableBitsFromLeft:
    20  e150 80c0e0f0f8fcfeff   !byte $80,$c0,$e0,$f0,$f8,$fc,$fe,$ff

; ******** Source: kernel.asm
   150                          
   151                          
   152                          !ifndef HBC56_DISABLE_AY3891X {

; ******** Source: ../lib\sfx\ay3891x.asm
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          

; ******** Source: ../lib\sfx\ay3891x.inc
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          !macro ayWrite .dev, .reg, .val {
    13                                  lda #.reg
    14                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    15                                  lda #.val
    16                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    17                          }        
    18                          
    19                          !macro ayRead .dev, .reg {
    20                                  lda #.reg
    21                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    22                                  lda IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_READ | .dev
    23                          }        
    24                          
    25                          
    26                          !macro ayWriteX .dev, .reg {
    27                                  lda #.reg
    28                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    29                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    30                          }
    31                          
    32                          !macro ayWriteA .dev, .reg {
    33                                  ldx #.reg
    34                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    35                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    36                          }
    37                          
    38                          !macro ayPlayNote .dev, .chan, .freq {
    39                                  !if .freq <= 0 {
    40                                          .val = 0
    41                                  } else {
    42                                          .val = AY_CLOCK_FREQ / (32.0 * .freq)
    43                                  }
    44                                  +ayWrite .dev, AY_CHA_TONE_L + (.chan * 2), <.val
    45                                  +ayWrite .dev, AY_CHA_TONE_H + (.chan * 2), >.val
    46                          }
    47                          
    48                          !macro ayToneWord .freq {
    49                                  !word (AY_CLOCK_FREQ / (32.0 * .freq))
    50                          }
    51                          
    52                          !macro ayToneByteL .freq {
    53                                  !byte <(AY_CLOCK_FREQ / (32.0 * .freq))
    54                          }
    55                          
    56                          !macro ayToneByteH .freq {
    57                                  !byte >(AY_CLOCK_FREQ / (32.0 * .freq))
    58                          }
    59                          
    60                          
    61                          !macro ayToneEnable .dev, .chan {
    62                                  +ayRead .dev, AY_ENABLES
    63                                  and #!($01 << .chan)
    64                                  +ayWriteA .dev, AY_ENABLES
    65                          }
    66                          
    67                          !macro ayToneDisable .dev, .chan {
    68                                  +ayRead .dev, AY_ENABLES
    69                                  ora #($01 << .chan)
    70                                  +ayWriteA .dev, AY_ENABLES
    71                          }
    72                          
    73                          !macro ayNoiseEnable .dev, .chan {
    74                                  +ayRead .dev, AY_ENABLES
    75                                  eor #($08 << .chan)
    76                                  +ayWriteA .dev, AY_ENABLES
    77                          }
    78                          
    79                          !macro ayNoiseDisable .dev, .chan {
    80                                  +ayRead .dev, AY_ENABLES
    81                                  ora #($08 << .chan)
    82                                  +ayWriteA .dev, AY_ENABLES
    83                          }
    84                          
    85                          !macro aySetVolume .dev, .chan, .vol {
    86                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), (.vol >> 4)
    87                          }
    88                          
    89                          !macro aySetVolumeEnvelope .dev, .chan {
    90                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), $10
    91                          }
    92                          
    93                          !macro aySetEnvelopePeriod .dev, .period {
    94                                  +ayWrite .dev, AY_ENV_PERIOD_L, <.period
    95                                  +ayWrite .dev, AY_ENV_PERIOD_H, >.period
    96                          }
    97                          
    98                          !macro aySetEnvShape .dev, .shape {
    99                                  +ayWrite .dev, AY_ENV_SHAPE, .shape
   100                          }
   101                          
   102                          !macro aySetNoise .dev, .freq {
   103                                  +ayWrite .dev, AY_ENV_SHAPE, .freq >> 3
   104                          }
   105                          
   106                          !macro ayStop .dev, .chan {
   107                                  +ayPlayNote .dev, .chan, 0
   108                             ;     +ayWrite .dev, (AY_CHA_AMPL + .chan), 0
   109                          }

; ******** Source: ../lib\sfx\ay3891x.asm
    10                          
    11                          
    12                          
    13                          !ifndef AY_IO_PORT { AY_IO_PORT = $40
    14                                  !warn "AY_IO_PORT not provided. Defaulting to ", AY_IO_PORT
    15                          }
    16                          
    17                          HAVE_AY3891X = 1
    18                          
    19                          ; -------------------------
    20                          ; Constants
    21                          ; -------------------------
    22                          AY_PSG0 = $00
    23                          AY_PSG1 = $04
    24                          
    25                          ; IO Ports
    26                          AY_S0 = IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_PSG0
    27                          AY_S1 = IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_PSG1
    28                          
    29                          AY_INACTIVE = $03
    30                          AY_READ     = $02
    31                          AY_WRITE    = $01
    32                          AY_ADDR     = $00
    33                          
    34                          AY_S0_READ  = AY_S0 | AY_READ
    35                          AY_S0_WRITE = AY_S0 | AY_WRITE
    36                          AY_S0_ADDR  = AY_S0 | AY_ADDR
    37                          
    38                          AY_S1_READ  = AY_S1 | AY_READ
    39                          AY_S1_WRITE = AY_S1 | AY_WRITE
    40                          AY_S1_ADDR  = AY_S1 | AY_ADDR
    41                          
    42                          ; Registers
    43                          AY_R0 = 0
    44                          AY_R1 = 1
    45                          AY_R2 = 2
    46                          AY_R3 = 3
    47                          AY_R4 = 4
    48                          AY_R5 = 5
    49                          AY_R6 = 6
    50                          AY_R7 = 7
    51                          AY_R8 = 8
    52                          AY_R9 = 9
    53                          AY_R10 = 10
    54                          AY_R11 = 11
    55                          AY_R12 = 12
    56                          AY_R13 = 13
    57                          AY_R14 = 14
    58                          AY_R15 = 15
    59                          AY_R16 = 16
    60                          AY_R17 = 17
    61                          
    62                          AY_CHA = 0
    63                          AY_CHB = 1
    64                          AY_CHC = 2
    65                          AY_CHN = 3
    66                          
    67                          AY_CHA_TONE_L   = AY_R0
    68                          AY_CHA_TONE_H   = AY_R1
    69                          AY_CHB_TONE_L   = AY_R2
    70                          AY_CHB_TONE_H   = AY_R3
    71                          AY_CHC_TONE_L   = AY_R4
    72                          AY_CHC_TONE_H   = AY_R5
    73                          AY_NOISE_GEN    = AY_R6
    74                          AY_ENABLES      = AY_R7
    75                          AY_CHA_AMPL     = AY_R8
    76                          AY_CHB_AMPL     = AY_R9
    77                          AY_CHC_AMPL     = AY_R10
    78                          AY_ENV_PERIOD_L = AY_R11
    79                          AY_ENV_PERIOD_H = AY_R12
    80                          AY_ENV_SHAPE    = AY_R13
    81                          AY_PORTA        = AY_R14
    82                          AY_PORTB        = AY_R15
    83                          
    84                          AY_ENV_SHAPE_CONTINUE  = $08
    85                          AY_ENV_SHAPE_ATTACK    = $04
    86                          AY_ENV_SHAPE_ALTERNATE = $02
    87                          AY_ENV_SHAPE_HOLD      = $01
    88                          
    89                          ;  /\  /\  /\  /\  /\ 
    90                          ; /  \/  \/  \/  \/  \
    91                          AY_ENV_SHAPE_TRIANGLE     = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK | AY_ENV_SHAPE_ALTERNATE)
    92                          
    93                          ;  /------------------
    94                          ; /
    95                          AY_ENV_SHAPE_FADE_IN      = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK | AY_ENV_SHAPE_HOLD)
    96                          
    97                          ; \
    98                          ;  \__________________
    99                          AY_ENV_SHAPE_FADE_OUT     = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_HOLD)
   100                          
   101                          ; \ |\ |\ |\ |\ |\ |\ |
   102                          ;  \| \| \| \| \| \| \|
   103                          AY_ENV_SHAPE_SAW1         = (AY_ENV_SHAPE_CONTINUE)
   104                          
   105                          ;  /| /| /| /| /| /| /|
   106                          ; / |/ |/ |/ |/ |/ |/ |
   107                          AY_ENV_SHAPE_SAW2         = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK)
   108                          
   109                          ;  /|
   110                          ; / |__________________
   111                          AY_ENV_SHAPE_FADE_IN_STOP = (AY_ENV_SHAPE_ATTACK)
   112                          
   113                          
   114                          AY_CLOCK_FREQ   = 2000000
   115                          
   116                          ayInit:
   117                                  ; disable everything
   118  e158 a9078d407fa9ff8d...        +ayWrite AY_PSG0, AY_ENABLES, $ff
   119  e162 a9078d447fa9ff8d...        +ayWrite AY_PSG1, AY_ENABLES, $ff
   120                          
   121  e16c a9088d407fa9008d...        +aySetVolume AY_PSG0, AY_CHA, 0
   122  e176 a9098d407fa9008d...        +aySetVolume AY_PSG0, AY_CHB, 0
   123  e180 a90a8d407fa9008d...        +aySetVolume AY_PSG0, AY_CHC, 0
   124                          
   125  e18a a9008d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHA, 0
   126  e19e a9028d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHB, 0
   127  e1b2 a9048d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHC, 0
   128                          
   129  e1c6 a90b8d407fa9008d...        +aySetEnvelopePeriod AY_PSG0, 0
   130  e1da a90d8d407fa9008d...        +aySetEnvShape AY_PSG0, 0
   131  e1e4 a90d8d407fa9008d...        +aySetNoise  AY_PSG0, 0
   132                          
   133  e1ee a9088d447fa9008d...        +aySetVolume AY_PSG1, AY_CHA, 0
   134  e1f8 a9098d447fa9008d...        +aySetVolume AY_PSG1, AY_CHB, 0
   135  e202 a90a8d447fa9008d...        +aySetVolume AY_PSG1, AY_CHC, 0
   136                          
   137  e20c a9008d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHA, 0
   138  e220 a9028d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHB, 0
   139  e234 a9048d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHC, 0
   140                          
   141  e248 a90b8d447fa9008d...        +aySetEnvelopePeriod AY_PSG1, 0
   142  e25c a90d8d447fa9008d...        +aySetEnvShape AY_PSG1, 0
   143  e266 a90d8d447fa9008d...        +aySetNoise  AY_PSG1, 0
   144  e270 60                         rts
   145                          
   146                          ; Note frequencies from https://pages.mtu.edu/~suits/notefreqs.html
   147                          
   148                          NOTE_FREQ_C0  = 16.35
   149                          NOTE_FREQ_CS0 = 17.32
   150                          NOTE_FREQ_D0  = 18.35
   151                          NOTE_FREQ_DS0 = 19.45
   152                          NOTE_FREQ_E0  = 20.6
   153                          NOTE_FREQ_F0  = 21.83
   154                          NOTE_FREQ_FS0 = 23.12
   155                          NOTE_FREQ_G0  = 24.5
   156                          NOTE_FREQ_GS0 = 25.96
   157                          NOTE_FREQ_A0  = 27.5
   158                          NOTE_FREQ_AS0 = 29.14
   159                          NOTE_FREQ_B0  = 30.87
   160                          NOTE_FREQ_C1  = 32.7
   161                          NOTE_FREQ_CS1 = 34.65
   162                          NOTE_FREQ_D1  = 36.71
   163                          NOTE_FREQ_DS1 = 38.89
   164                          NOTE_FREQ_E1  = 41.2
   165                          NOTE_FREQ_F1  = 43.65
   166                          NOTE_FREQ_FS1 = 46.25
   167                          NOTE_FREQ_G1  = 49
   168                          NOTE_FREQ_GS1 = 51.91
   169                          NOTE_FREQ_A1  = 55
   170                          NOTE_FREQ_AS1 = 58.27
   171                          NOTE_FREQ_B1  = 61.74
   172                          NOTE_FREQ_C2  = 65.41
   173                          NOTE_FREQ_CS2 = 69.3
   174                          NOTE_FREQ_D2  = 73.42
   175                          NOTE_FREQ_DS2 = 77.78
   176                          NOTE_FREQ_E2  = 82.41
   177                          NOTE_FREQ_F2  = 87.31
   178                          NOTE_FREQ_FS2 = 92.5
   179                          NOTE_FREQ_G2  = 98
   180                          NOTE_FREQ_GS2 = 103.83
   181                          NOTE_FREQ_A2  = 110
   182                          NOTE_FREQ_AS2 = 116.54
   183                          NOTE_FREQ_B2  = 123.47
   184                          NOTE_FREQ_C3  = 130.81
   185                          NOTE_FREQ_CS3 = 138.59
   186                          NOTE_FREQ_D3  = 146.83
   187                          NOTE_FREQ_DS3 = 155.56
   188                          NOTE_FREQ_E3  = 164.81
   189                          NOTE_FREQ_F3  = 174.61
   190                          NOTE_FREQ_FS3 = 185
   191                          NOTE_FREQ_G3  = 196
   192                          NOTE_FREQ_GS3 = 207.65
   193                          NOTE_FREQ_A3  = 220
   194                          NOTE_FREQ_AS3 = 233.08
   195                          NOTE_FREQ_B3  = 246.94
   196                          NOTE_FREQ_C4  = 261.63
   197                          NOTE_FREQ_CS4 = 277.18
   198                          NOTE_FREQ_D4  = 293.66
   199                          NOTE_FREQ_DS4 = 311.13
   200                          NOTE_FREQ_E4  = 329.63
   201                          NOTE_FREQ_F4  = 349.23
   202                          NOTE_FREQ_FS4 = 369.99
   203                          NOTE_FREQ_G4  = 392
   204                          NOTE_FREQ_GS4 = 415.3
   205                          NOTE_FREQ_A4  = 440
   206                          NOTE_FREQ_AS4 = 466.16
   207                          NOTE_FREQ_B4  = 493.88
   208                          NOTE_FREQ_C5  = 523.25
   209                          NOTE_FREQ_CS5 = 554.37
   210                          NOTE_FREQ_D5  = 587.33
   211                          NOTE_FREQ_DS5 = 622.25
   212                          NOTE_FREQ_E5  = 659.25
   213                          NOTE_FREQ_F5  = 698.46
   214                          NOTE_FREQ_FS5 = 739.99
   215                          NOTE_FREQ_G5  = 783.99
   216                          NOTE_FREQ_GS5 = 830.61
   217                          NOTE_FREQ_A5  = 880
   218                          NOTE_FREQ_AS5 = 932.33
   219                          NOTE_FREQ_B5  = 987.77
   220                          NOTE_FREQ_C6  = 1046.5
   221                          NOTE_FREQ_CS6 = 1108.73
   222                          NOTE_FREQ_D6  = 1174.66
   223                          NOTE_FREQ_DS6 = 1244.51
   224                          NOTE_FREQ_E6  = 1318.51
   225                          NOTE_FREQ_F6  = 1396.91
   226                          NOTE_FREQ_FS6 = 1479.98
   227                          NOTE_FREQ_G6  = 1567.98
   228                          NOTE_FREQ_GS6 = 1661.22
   229                          NOTE_FREQ_A6  = 1760
   230                          NOTE_FREQ_AS6 = 1864.66
   231                          NOTE_FREQ_B6  = 1975.53
   232                          NOTE_FREQ_C7  = 2093
   233                          NOTE_FREQ_CS7 = 2217.46
   234                          NOTE_FREQ_D7  = 2349.32
   235                          NOTE_FREQ_DS7 = 2489.02
   236                          NOTE_FREQ_E7  = 2637.02
   237                          NOTE_FREQ_F7  = 2793.83
   238                          NOTE_FREQ_FS7 = 2959.96
   239                          NOTE_FREQ_G7  = 3135.96
   240                          NOTE_FREQ_GS7 = 3322.44
   241                          NOTE_FREQ_A7  = 3520
   242                          NOTE_FREQ_AS7 = 3729.31
   243                          NOTE_FREQ_B7  = 3951.07
   244                          NOTE_FREQ_C8  = 4186.01
   245                          NOTE_FREQ_CS8 = 4434.92
   246                          NOTE_FREQ_D8  = 4698.63
   247                          NOTE_FREQ_DS8 = 4978.03
   248                          NOTE_FREQ_E8  = 5274.04
   249                          NOTE_FREQ_F8  = 5587.65
   250                          NOTE_FREQ_FS8 = 5919.91
   251                          NOTE_FREQ_G8  = 6271.93
   252                          NOTE_FREQ_GS8 = 6644.88
   253                          NOTE_FREQ_A8  = 7040
   254                          NOTE_FREQ_AS8 = 7458.62
   255                          NOTE_FREQ_B8  = 7902.13

; ******** Source: kernel.asm
   153                          
   154                          }
   155                          
   156                          !ifndef HBC56_DISABLE_TMS9918 {
   157                                  !ifndef TMS_MODEL { TMS_MODEL = 9918 }

; ******** Source: ../lib\gfx\tms9918.asm
     1                          ; 6502 - TMS9918 VDP
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          

; ******** Source: ../lib\hbc56.inc
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; Base address of the 256 IO port memory range
    12                          IO_PORT_BASE_ADDRESS	= $7f00
    13                          
    14                          
    15                          ; -------------------------
    16                          ; ASCII constants
    17                          ; -------------------------
    18                          ASCII_RETURN    = $0A
    19                          ASCII_CR        = $0D
    20                          ASCII_BACKSPACE = $08
    21                          ASCII_BELL      = $07

; ******** Source: ../lib\gfx\tms9918.asm
    10                          
    11                          
    12                          !ifndef HAVE_MATH_INC { !src "ut/math.inc" }

; ******** Source: ../lib\gfx\tms9918.inc
     1                          ; 6502 - TMS9918 VDP Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; tmsWaitReg: Not sure how much delay we need so make a macro for now
    15                          ; -----------------------------------------------------------------------------
    16                          !macro tmsWaitReg {
    17                                  jsr _tmsWaitReg
    18                          }
    19                          
    20                          ; -----------------------------------------------------------------------------
    21                          ; tmsWaitData: Not sure how much delay we need so make a macro for now
    22                          ; -----------------------------------------------------------------------------
    23                          !macro tmsWaitData {
    24                                  jsr _tmsWaitData
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; tmsSetAddressWrite: Set an address in the TMS9918
    29                          ; -----------------------------------------------------------------------------
    30                          !macro tmsSetAddressWrite .addr {
    31                                  +tmsSetAddressRead ($4000 | .addr)
    32                          }
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; tmsSetAddressRead: Set an address to read from the TMS9918
    36                          ; -----------------------------------------------------------------------------
    37                          !macro tmsSetAddressRead .addr {
    38                                  php
    39                                  sei             ; we can't be interrupted here
    40                                  lda #<(.addr)
    41                                  sta TMS9918_REG
    42                                  +tmsWaitReg
    43                                  lda #>(.addr)
    44                                  sta TMS9918_REG
    45                                  +tmsWaitReg
    46                                  plp
    47                          }
    48                          
    49                          ; -----------------------------------------------------------------------------
    50                          ; tmsGet: Get a byte of data from the TMS9918
    51                          ; -----------------------------------------------------------------------------
    52                          !macro tmsGet {
    53                                  lda TMS9918_RAM
    54                                  +tmsWaitData
    55                          }
    56                          
    57                          ; -----------------------------------------------------------------------------
    58                          ; tmsPut: Send a byte of data to the TMS9918
    59                          ; -----------------------------------------------------------------------------
    60                          !macro tmsPut .byte {
    61                                  lda #(.byte & 0xff)
    62                                  +tmsPut
    63                          }
    64                          
    65                          
    66                          ; -----------------------------------------------------------------------------
    67                          ; tmsPut: Send a byte (A) of data to the TMS9918
    68                          ; -----------------------------------------------------------------------------
    69                          !macro tmsPut {
    70                                  sta TMS9918_RAM
    71                                  +tmsWaitData
    72                          }
    73                          
    74                          ; -----------------------------------------------------------------------------
    75                          ; tmsSetColor: Set current fg/bg color
    76                          ; -----------------------------------------------------------------------------
    77                          !macro tmsSetColor .color {
    78                                  lda #.color
    79                                  jsr tmsSetBackground
    80                          }
    81                          
    82                          ; -----------------------------------------------------------------------------
    83                          ; tmsSetColorFgBg: Set current fg/bg color
    84                          ; -----------------------------------------------------------------------------
    85                          !macro tmsSetColorFgBg .fg, .bg {
    86                                  +tmsColorFgBg .fg, .bg
    87                                  jsr tmsSetBackground
    88                          }
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; byteTmsColorFgBg: Output a data byte
    92                          ; -----------------------------------------------------------------------------
    93                          !macro byteTmsColorFgBg .fg, .bg {
    94                          !byte (.fg << 4 | .bg)
    95                          }
    96                          
    97                          
    98                          ; -----------------------------------------------------------------------------
    99                          ; tmsDisableOutput: Disable the TMS9918 output
   100                          ; -----------------------------------------------------------------------------
   101                          !macro tmsDisableOutput {
   102                                  lda #TMS_R1_DISP_ACTIVE
   103                                  jsr tmsReg1ClearFields
   104                          }
   105                          
   106                          ; -----------------------------------------------------------------------------
   107                          ; tmsEnableOutput: Enable the TMS9918 output
   108                          ; -----------------------------------------------------------------------------
   109                          !macro tmsEnableOutput {
   110                                  lda #TMS_R1_DISP_ACTIVE
   111                                  jsr tmsReg1SetFields
   112                          }
   113                          
   114                          ; -
   115                          !macro tmsEnableInterrupts {
   116                                  lda #TMS_R1_INT_ENABLE
   117                                  jsr tmsReg1SetFields
   118                          }
   119                          
   120                          !macro tmsDisableInterrupts {
   121                                  lda #TMS_R1_INT_ENABLE
   122                                  jsr tmsReg1ClearFields
   123                          }
   124                          
   125                          !macro tmsConsoleOut .char {
   126                                  lda #.char
   127                                  jsr tmsConsoleOut
   128                          }
   129                          
   130                          
   131                          ; -----------------------------------------------------------------------------
   132                          ; tmsConsolePrintAddr: Print text to console
   133                          ; -----------------------------------------------------------------------------
   134                          ; Inputs:
   135                          ;  textAddr: Address of null-terminated string to print
   136                          ; -----------------------------------------------------------------------------
   137                          !macro tmsConsolePrintAddr .textAddr {
   138                                  lda #<.textAddr
   139                                  sta STR_ADDR_L
   140                                  lda #>.textAddr
   141                                  sta STR_ADDR_H
   142                                  jsr tmsConsolePrint        
   143                          }
   144                          
   145                          ; -----------------------------------------------------------------------------
   146                          ; tmsConsolePrint: Print immediate text to console
   147                          ; -----------------------------------------------------------------------------
   148                          ; Inputs:
   149                          ;  str: String to print
   150                          ; -----------------------------------------------------------------------------
   151                          !macro tmsConsolePrint .str {
   152                          	jmp .afterText
   153                          .textAddr
   154                          	!text .str,0
   155                          .afterText        
   156                                  +tmsConsolePrintAddr .textAddr
   157                          }
   158                          
   159                          ; -----------------------------------------------------------------------------
   160                          ; +tmsColorFgBg: Set A to the given FG / BG color
   161                          ; -----------------------------------------------------------------------------
   162                          !macro tmsColorFgBg .fg, .bg {
   163                                  lda #(.fg << 4 | .bg)
   164                          }
   165                          
   166                          ; -----------------------------------------------------------------------------
   167                          ; tmsReadStatus: Read status - clear interrupt
   168                          ; -----------------------------------------------------------------------------
   169                          !macro tmsReadStatus  {
   170                                  bit TMS9918_REG
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; tmsSendData: Send # bytes from .sourceAddr to tms9918 data port
   175                          ; -----------------------------------------------------------------------------
   176                          !macro tmsSendData .sourceAddr, .numBytes {
   177                                  lda #<.sourceAddr
   178                                  sta TMS_TMP_ADDRESS
   179                                  lda #>.sourceAddr
   180                                  sta TMS_TMP_ADDRESS + 1
   181                          
   182                                  !if .numBytes < 256 {
   183                                          ldx #.numBytes
   184                                          jsr tmsSendBytes
   185                                  } else {
   186                                          !do while .numBytes > 0 {
   187                                                  !if .numBytes > 255 {
   188                                                          ldx #0
   189                                                          !set .numBytes = .numBytes - 256
   190                                                  } else {
   191                                                          ldx #.numBytes
   192                                                          !set .numBytes = 0
   193                                                  }
   194                                                  jsr tmsSendBytes
   195                                                  inc TMS_TMP_ADDRESS + 1
   196                                          }
   197                                  }
   198                          
   199                          }
   200                          
   201                          ; -----------------------------------------------------------------------------
   202                          ; tmsSendDataRpt: Send # bytes from .sourceAddr to tms9918 data port .rpt times
   203                          ; -----------------------------------------------------------------------------
   204                          !macro tmsSendDataRpt .sourceAddr, .numBytes, .rpt {
   205                                  lda #<.sourceAddr
   206                                  sta TMS_TMP_ADDRESS
   207                                  lda #>.sourceAddr
   208                                  sta TMS_TMP_ADDRESS + 1
   209                          
   210                                  !if .numBytes < 256 {
   211                                          !if .rpt < 5 {
   212                                                  !for i,1,.rpt {
   213                                                          ldx #.numBytes
   214                                                          jsr tmsSendBytes
   215                                                  }
   216                                          } else {
   217                                                  lda #.rpt
   218                                                  sta TMS9918_TMP_BUFFER
   219                          -
   220                                                  ldx #.numBytes
   221                                                  jsr tmsSendBytes
   222                                                  dec TMS9918_TMP_BUFFER
   223                                                  bne -
   224                                          }
   225                                  } else {
   226                                          !error "tmsSendDataRpt supports <256 bytes only"
   227                                  }
   228                          }
   229                          
   230                          
   231                          ; -----------------------------------------------------------------------------
   232                          ; tmsPutRpt: Send value .rpt times
   233                          ; -----------------------------------------------------------------------------
   234                          !macro tmsPutRpt .value, .rpt {
   235                                  ldx #.rpt
   236                                  lda #.value
   237                          -
   238                                  +tmsPut
   239                                  dex
   240                                  bne -
   241                          }
   242                          
   243                          !macro tmsPutSeq .from, .count {
   244                                  lda #.from
   245                          -
   246                                  +tmsPut
   247                                  inc
   248                                  cmp #<(.from + .count)
   249                                  bne -
   250                          }
   251                          
   252                          !macro tmsSetSourceAddressInd .addr {
   253                          	lda .addr
   254                          	sta TMS_TMP_ADDRESS
   255                          	lda .addr + 1
   256                          	sta TMS_TMP_ADDRESS + 1
   257                          }
   258                          
   259                          !macro tmsSetSourceAddressIndOffset .addr, .offset {
   260                                  clc
   261                          	lda .addr
   262                                  adc #<.offset
   263                          	sta TMS_TMP_ADDRESS
   264                          	lda .addr + 1
   265                                  adc #>.offset
   266                          	sta TMS_TMP_ADDRESS + 1
   267                          }
   268                          
   269                          
   270                          !macro tmsSendBytes .bytes {
   271                                  ldx #.bytes
   272                                  jsr tmsSendBytes
   273                          }
   274                          
   275                          
   276                          ; -----------------------------------------------------------------------------
   277                          ; tmsSetAddrPattTable: Initialise address for font table
   278                          ; -----------------------------------------------------------------------------
   279                          !macro tmsSetAddrPattTable {
   280                                  +tmsSetAddrPattTable 0
   281                          }
   282                          
   283                          ; -----------------------------------------------------------------------------
   284                          ; tmsSetAddrPattTable: Initialise address for pattern table
   285                          ; -----------------------------------------------------------------------------
   286                          !macro tmsSetAddrPattTable .ind {
   287                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   288                          }
   289                          
   290                          ; -----------------------------------------------------------------------------
   291                          ; tmsSetAddrPattTable: Initialise address for pattern table
   292                          ; -----------------------------------------------------------------------------
   293                          !macro tmsSetAddrPattTable .ind, .row {
   294                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   295                          }
   296                          
   297                          ; -----------------------------------------------------------------------------
   298                          ; tmsSetAddrPattTableIIBank0: Initialise address for pattern table
   299                          ; -----------------------------------------------------------------------------
   300                          !macro tmsSetAddrPattTableIIBank0 .ind {
   301                                  +tmsSetAddrPattTable .ind
   302                          }
   303                          
   304                          ; -----------------------------------------------------------------------------
   305                          ; tmsSetAddrPattTableIIBank1: Initialise address for pattern table
   306                          ; -----------------------------------------------------------------------------
   307                          !macro tmsSetAddrPattTableIIBank1 .ind {
   308                                  +tmsSetAddrPattTable 256 + .ind
   309                          }
   310                          
   311                          ; -----------------------------------------------------------------------------
   312                          ; tmsSetAddrPattTableIIBank2: Initialise address for pattern table
   313                          ; -----------------------------------------------------------------------------
   314                          !macro tmsSetAddrPattTableIIBank2 .ind {
   315                                  +tmsSetAddrPattTable 512 + .ind
   316                          }
   317                          
   318                          ; -----------------------------------------------------------------------------
   319                          ; tmsSetAddrPattTableRead: Initialise address for pattern table to read
   320                          ; -----------------------------------------------------------------------------
   321                          !macro tmsSetAddrPattTableRead .ind {
   322                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   323                          }
   324                          
   325                          ; -----------------------------------------------------------------------------
   326                          ; tmsSetAddrPattTableRowRead: Initialise address for pattern table to read
   327                          ; -----------------------------------------------------------------------------
   328                          !macro tmsSetAddrPattTableRead .ind, .row {
   329                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   330                          }
   331                          
   332                          ; -----------------------------------------------------------------------------
   333                          ; tmsUpdateFont: Update the pattern table with a given font
   334                          ; -----------------------------------------------------------------------------
   335                          !macro tmsUpdateFont .fontAddr {
   336                                  +tmsSetAddrPattTable 32
   337                                  +tmsSendData .fontAddr, $300
   338                          }
   339                          
   340                          ; -----------------------------------------------------------------------------
   341                          ; tmsSetAddrNameTable: Initialise address for base (text) table
   342                          ; -----------------------------------------------------------------------------
   343                          !macro tmsSetAddrNameTable {
   344                                  +tmsSetAddressWrite TMS_VRAM_NAME_ADDRESS
   345                          }
   346                          
   347                          ; -----------------------------------------------------------------------------
   348                          ; tmsSetAddrColorTable: Initialise address for color table
   349                          ; -----------------------------------------------------------------------------
   350                          !macro tmsSetAddrColorTable {
   351                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS
   352                          }
   353                          
   354                          ; -----------------------------------------------------------------------------
   355                          ; tmsSetAddrColorTable: Initialise address for color table index
   356                          ; -----------------------------------------------------------------------------
   357                          !macro tmsSetAddrColorTable .ind {
   358                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind
   359                          }
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; tmsSetAddrColorTableII: Initialise address for color table index (mode II)
   363                          ; -----------------------------------------------------------------------------
   364                          !macro tmsSetAddrColorTableII .ind {
   365                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind * 8
   366                          }
   367                          
   368                          ; -----------------------------------------------------------------------------
   369                          ; tmsSetAddrColorTableIIBank0: Initialise address for color table index (mode II)
   370                          ; -----------------------------------------------------------------------------
   371                          !macro tmsSetAddrColorTableIIBank0 .ind {
   372                                  +tmsSetAddrColorTableII .ind
   373                          }
   374                          
   375                          ; -----------------------------------------------------------------------------
   376                          ; tmsSetAddrColorTableIIBank1: Initialise address for color table index (mode II)
   377                          ; -----------------------------------------------------------------------------
   378                          !macro tmsSetAddrColorTableIIBank1 .ind {
   379                                  +tmsSetAddrColorTableII 256 + .ind
   380                          }
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; tmsSetAddrColorTableIIBank2: Initialise address for color table index (mode II)
   384                          ; -----------------------------------------------------------------------------
   385                          !macro tmsSetAddrColorTableIIBank2 .ind {
   386                                  +tmsSetAddrColorTableII 512 + .ind
   387                          }
   388                          
   389                          ; -----------------------------------------------------------------------------
   390                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   391                          ; -----------------------------------------------------------------------------
   392                          !macro tmsSetAddrSpriteAttrTable {
   393                                  +tmsSetAddrSpriteAttrTable 0
   394                          }
   395                          
   396                          ; -----------------------------------------------------------------------------
   397                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   398                          ; -----------------------------------------------------------------------------
   399                          !macro tmsSetAddrSpriteAttrTable .index {
   400                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + .index * 4
   401                          }
   402                          
   403                          ; -----------------------------------------------------------------------------
   404                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   405                          ; -----------------------------------------------------------------------------
   406                          !macro tmsSetAddrSpritePattTable {
   407                                  +tmsSetAddrSpritePattTable 0
   408                          }
   409                          
   410                          ; -----------------------------------------------------------------------------
   411                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   412                          ; -----------------------------------------------------------------------------
   413                          !macro tmsSetAddrSpritePattTable .index {
   414                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_PATT_ADDRESS + .index * 8
   415                          }
   416                          
   417                          
   418                          ; -----------------------------------------------------------------------------
   419                          ; tmsCreateSpritePattern: Create a sprite pattern (.spriteDataAddr is 8 bytes)
   420                          ; -----------------------------------------------------------------------------
   421                          !macro tmsCreateSpritePattern .pattInd, .spriteDataAddr {
   422                          
   423                                  
   424                          
   425                                  ; sprite pattern table
   426                                  +tmsSetAddrSpritePattTable .pattInd
   427                          
   428                                  ldx #0
   429                          -
   430                                  lda .spriteDataAddr,x
   431                                  +tmsPut
   432                                  inx
   433                                  cpx #8
   434                          
   435                                  
   436                          
   437                                  bne -
   438                          }
   439                          
   440                          ; -----------------------------------------------------------------------------
   441                          ; tmsCreateSpritePatternQuad: Create a (size 1) sprite pattern 
   442                          ;   (.spriteDataAddr is 32 bytes)
   443                          ; -----------------------------------------------------------------------------
   444                          !macro tmsCreateSpritePatternQuad .pattInd, .spriteDataAddr {
   445                          
   446                                  
   447                          
   448                                  ; sprite pattern table
   449                                  +tmsSetAddrSpritePattTable .pattInd * 4
   450                          
   451                                  ldx #0
   452                          -
   453                                  lda .spriteDataAddr,x
   454                                  +tmsPut 
   455                                  inx
   456                                  cpx #32
   457                          
   458                                  
   459                          
   460                                  bne -
   461                          }
   462                          
   463                          
   464                          !macro tmsCreateSpritePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   465                          
   466                                  ; sprite pattern table
   467                                  +tmsSetAddrSpritePattTable .ind
   468                                  +tmsPut .b0
   469                                  +tmsPut .b2
   470                                  +tmsPut .b2
   471                                  +tmsPut .b3
   472                                  +tmsPut .b4
   473                                  +tmsPut .b5
   474                                  +tmsPut .b6
   475                                  +tmsPut .b7
   476                          }
   477                          
   478                          !macro tmsCreatePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   479                          
   480                                  ; sprite pattern table
   481                                  +tmsSetAddrPattTable .ind
   482                                  +tmsPut .b0
   483                                  +tmsPut .b2
   484                                  +tmsPut .b2
   485                                  +tmsPut .b3
   486                                  +tmsPut .b4
   487                                  +tmsPut .b5
   488                                  +tmsPut .b6
   489                                  +tmsPut .b7
   490                          }
   491                          
   492                          
   493                          ; -----------------------------------------------------------------------------
   494                          ; tmsCreateSprite: Create a sprite
   495                          ; -----------------------------------------------------------------------------
   496                          !macro tmsCreateSprite .ind, .pattInd, .xPos, .yPos, .color {
   497                          
   498                                  ; sprite attr table
   499                                  +tmsSetAddrSpriteAttrTable .ind
   500                          
   501                                  +tmsPut .yPos
   502                                  +tmsPut .xPos
   503                                  +tmsPut .pattInd
   504                                  +tmsPut .color
   505                          }
   506                          
   507                          ; -----------------------------------------------------------------------------
   508                          ; tmsSpritePos: Set a sprite position
   509                          ; -----------------------------------------------------------------------------
   510                          !macro tmsSpritePos .ind, .xPos, .yPos {
   511                                  
   512                          
   513                                  ; sprite attr table
   514                                  +tmsSetAddrSpriteAttrTable .ind
   515                          
   516                                  +tmsPut .yPos
   517                                  +tmsPut .xPos        
   518                          }
   519                          
   520                          
   521                          ; -----------------------------------------------------------------------------
   522                          ; tmsSetLastSprite: Mark a sprite as the last sprite (set next ypos to )
   523                          ; -----------------------------------------------------------------------------
   524                          !macro tmsSetLastSprite .ind {
   525                                  +tmsSpritePos .ind + 1, 0, $d0
   526                          }
   527                          
   528                          
   529                          ; -----------------------------------------------------------------------------
   530                          ; tmsSpritePosXYReg: Set a sprite position from x/y registers
   531                          ; -----------------------------------------------------------------------------
   532                          !macro tmsSpritePosXYReg .ind {
   533                                  
   534                          
   535                                  ; sprite attr table
   536                                  +tmsSetAddrSpriteAttrTable .ind
   537                          
   538                                  tya
   539                                  +tmsPut 
   540                                  txa
   541                                  +tmsPut 
   542                          }
   543                          
   544                          
   545                          ; -----------------------------------------------------------------------------
   546                          ; tmsSetAddrSpriteColor: Change a sprite color
   547                          ; -----------------------------------------------------------------------------
   548                          !macro tmsSetAddrSpriteColor .ind {
   549                          
   550                                  ; sprite attr table
   551                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + (.ind * 4) + 3
   552                          }
   553                          ; -----------------------------------------------------------------------------
   554                          ; tmsSpriteColor: Change a sprite color
   555                          ; -----------------------------------------------------------------------------
   556                          !macro tmsSpriteColor .ind, .color {
   557                          
   558                                  +tmsSetAddrSpriteColor .ind
   559                          
   560                                  +tmsPut .color
   561                          }
   562                          
   563                          
   564                          ; -----------------------------------------------------------------------------
   565                          ; tmsSetPosWrite: Set cursor position
   566                          ; -----------------------------------------------------------------------------
   567                          !macro tmsSetPosWrite .x, .y {
   568                                  +tmsSetAddressWrite (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   569                          }
   570                          
   571                          ; -----------------------------------------------------------------------------
   572                          ; tmsSetPosRead: Set read cursor position
   573                          ; -----------------------------------------------------------------------------
   574                          !macro tmsSetPosRead .x, .y {
   575                                  +tmsSetAddressRead (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   576                          }
   577                          
   578                          ; -----------------------------------------------------------------------------
   579                          ; tmsPrint: Print immediate text
   580                          ; -----------------------------------------------------------------------------
   581                          ; Inputs:
   582                          ;  str: String to print
   583                          ;  x: x position
   584                          ;  y: y position
   585                          ; -----------------------------------------------------------------------------
   586                          !macro tmsPrint .str, .x, .y {
   587                          	jmp .afterText
   588                          .textAddr
   589                          	!text .str,0
   590                          .afterText        
   591                          
   592                                  +tmsSetPosWrite .x, .y
   593                          
   594                                  lda #<.textAddr
   595                                  sta STR_ADDR_L
   596                                  lda #>.textAddr
   597                                  sta STR_ADDR_H
   598                                  jsr tmsPrint        
   599                          }
   600                          
   601                          
   602                          ; -----------------------------------------------------------------------------
   603                          ; tmsPrintCentre: Print centre-aligned immediate text
   604                          ; -----------------------------------------------------------------------------
   605                          ; Inputs:
   606                          ;  str: String to print
   607                          ;  y: y position
   608                          ; -----------------------------------------------------------------------------
   609                          !macro tmsPrintCentre .str, .y {
   610                          	jmp .afterText
   611                          .textAddr
   612                          	!text .str,0
   613                          .afterText        
   614                          
   615                                  +tmsSetPosWrite (32 - ((.afterText - 1) - .textAddr)) / 2, .y
   616                          
   617                                  lda #<.textAddr
   618                                  sta STR_ADDR_L
   619                                  lda #>.textAddr
   620                                  sta STR_ADDR_H
   621                                  jsr tmsPrint        
   622                          }
   623                          
   624                          
   625                          ; -----------------------------------------------------------------------------
   626                          ; tmsPrintZ: Print text
   627                          ; -----------------------------------------------------------------------------
   628                          ; Inputs:
   629                          ;  str: Address of zero-terminated string to print
   630                          ;  x: x position
   631                          ;  y: y position
   632                          ; -----------------------------------------------------------------------------
   633                          !macro tmsPrintZ .textAddr, .x, .y {
   634                                  +tmsSetPosWrite .x, .y
   635                          
   636                                  lda #<.textAddr
   637                                  sta STR_ADDR_L
   638                                  lda #>.textAddr
   639                                  sta STR_ADDR_H
   640                                  jsr tmsPrint        
   641                          }

; ******** Source: ../lib\gfx\tms9918.asm
    13                          
    14                          
    15                          TMS_FONT_DATA:

; ******** Source: ../lib\gfx\fonts\hbc56font.asm
     1                          ; 6502 - HBC-56 Font
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          
    13                          
    14                          
    15                          
    16                          
    17                          
    18                          
    19                          
    20                          
    21                          
    22                          
    23                          
    24                          
    25                          
    26                          
    27                          
    28                          
    29                          
    30                          
    31                          
    32  e271 0000000000000000   !byte $00,$00,$00,$00,$00,$00,$00,$00 ; <SPACE>
    33  e279 1818181818001800   !byte $18,$18,$18,$18,$18,$00,$18,$00 ; !
    34  e281 6c6c6c0000000000   !byte $6C,$6C,$6C,$00,$00,$00,$00,$00 ; "
    35  e289 6c6cfe6cfe6c6c00   !byte $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; #
    36  e291 187ec07c06fc1800   !byte $18,$7E,$C0,$7C,$06,$FC,$18,$00 ; $
    37  e299 00c6cc183066c600   !byte $00,$C6,$CC,$18,$30,$66,$C6,$00 ; %
    38  e2a1 386c3876dccc7600   !byte $38,$6C,$38,$76,$DC,$CC,$76,$00 ; &
    39  e2a9 3030600000000000   !byte $30,$30,$60,$00,$00,$00,$00,$00 ; '
    40  e2b1 0c18303030180c00   !byte $0C,$18,$30,$30,$30,$18,$0C,$00 ; (
    41  e2b9 30180c0c0c183000   !byte $30,$18,$0C,$0C,$0C,$18,$30,$00 ; )
    42  e2c1 00663cff3c660000   !byte $00,$66,$3C,$FF,$3C,$66,$00,$00 ; *
    43  e2c9 0018187e18180000   !byte $00,$18,$18,$7E,$18,$18,$00,$00 ; +
    44  e2d1 0000000000181830   !byte $00,$00,$00,$00,$00,$18,$18,$30 ; ,
    45  e2d9 0000007e00000000   !byte $00,$00,$00,$7E,$00,$00,$00,$00 ; -
    46  e2e1 0000000000181800   !byte $00,$00,$00,$00,$00,$18,$18,$00 ; .
    47  e2e9 060c183060c08000   !byte $06,$0C,$18,$30,$60,$C0,$80,$00 ; /
    48  e2f1 7ccedef6e6c67c00   !byte $7C,$CE,$DE,$F6,$E6,$C6,$7C,$00 ; 0
    49  e2f9 1838181818187e00   !byte $18,$38,$18,$18,$18,$18,$7E,$00 ; 1
    50  e301 7cc6067cc0c0fe00   !byte $7C,$C6,$06,$7C,$C0,$C0,$FE,$00 ; 2
    51  e309 fc06063c0606fc00   !byte $FC,$06,$06,$3C,$06,$06,$FC,$00 ; 3
    52  e311 0cccccccfe0c0c00   !byte $0C,$CC,$CC,$CC,$FE,$0C,$0C,$00 ; 4
    53  e319 fec0fc0606c67c00   !byte $FE,$C0,$FC,$06,$06,$C6,$7C,$00 ; 5
    54  e321 7cc0c0fcc6c67c00   !byte $7C,$C0,$C0,$FC,$C6,$C6,$7C,$00 ; 6
    55  e329 fe06060c18303000   !byte $FE,$06,$06,$0C,$18,$30,$30,$00 ; 7
    56  e331 7cc6c67cc6c67c00   !byte $7C,$C6,$C6,$7C,$C6,$C6,$7C,$00 ; 8
    57  e339 7cc6c67e06067c00   !byte $7C,$C6,$C6,$7E,$06,$06,$7C,$00 ; 9
    58  e341 0018180000181800   !byte $00,$18,$18,$00,$00,$18,$18,$00 ; :
    59  e349 0018180000181830   !byte $00,$18,$18,$00,$00,$18,$18,$30 ; ;
    60  e351 0c18306030180c00   !byte $0C,$18,$30,$60,$30,$18,$0C,$00 ; <
    61  e359 00007e007e000000   !byte $00,$00,$7E,$00,$7E,$00,$00,$00 ; =
    62  e361 30180c060c183000   !byte $30,$18,$0C,$06,$0C,$18,$30,$00 ; >
    63  e369 3c660c1818001800   !byte $3C,$66,$0C,$18,$18,$00,$18,$00 ; ?
    64  e371 7cc6dededec07e00   !byte $7C,$C6,$DE,$DE,$DE,$C0,$7E,$00 ; @
    65  e379 386cc6c6fec6c600   !byte $38,$6C,$C6,$C6,$FE,$C6,$C6,$00 ; A
    66  e381 fcc6c6fcc6c6fc00   !byte $FC,$C6,$C6,$FC,$C6,$C6,$FC,$00 ; B
    67  e389 7cc6c0c0c0c67c00   !byte $7C,$C6,$C0,$C0,$C0,$C6,$7C,$00 ; C
    68  e391 f8ccc6c6c6ccf800   !byte $F8,$CC,$C6,$C6,$C6,$CC,$F8,$00 ; D
    69  e399 fec0c0f8c0c0fe00   !byte $FE,$C0,$C0,$F8,$C0,$C0,$FE,$00 ; E
    70  e3a1 fec0c0f8c0c0c000   !byte $FE,$C0,$C0,$F8,$C0,$C0,$C0,$00 ; F
    71  e3a9 7cc6c0c0cec67c00   !byte $7C,$C6,$C0,$C0,$CE,$C6,$7C,$00 ; G
    72  e3b1 c6c6c6fec6c6c600   !byte $C6,$C6,$C6,$FE,$C6,$C6,$C6,$00 ; H
    73  e3b9 7e18181818187e00   !byte $7E,$18,$18,$18,$18,$18,$7E,$00 ; I
    74  e3c1 0606060606c67c00   !byte $06,$06,$06,$06,$06,$C6,$7C,$00 ; J
    75  e3c9 c6ccd8f0d8ccc600   !byte $C6,$CC,$D8,$F0,$D8,$CC,$C6,$00 ; K
    76  e3d1 c0c0c0c0c0c0fe00   !byte $C0,$C0,$C0,$C0,$C0,$C0,$FE,$00 ; L
    77  e3d9 c6eefefed6c6c600   !byte $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; M
    78  e3e1 c6e6f6decec6c600   !byte $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; N
    79  e3e9 7cc6c6c6c6c67c00   !byte $7C,$C6,$C6,$C6,$C6,$C6,$7C,$00 ; O
    80  e3f1 fcc6c6fcc0c0c000   !byte $FC,$C6,$C6,$FC,$C0,$C0,$C0,$00 ; P
    81  e3f9 7cc6c6c6d6de7c06   !byte $7C,$C6,$C6,$C6,$D6,$DE,$7C,$06 ; Q
    82  e401 fcc6c6fcd8ccc600   !byte $FC,$C6,$C6,$FC,$D8,$CC,$C6,$00 ; R
    83  e409 7cc6c07c06c67c00   !byte $7C,$C6,$C0,$7C,$06,$C6,$7C,$00 ; S
    84  e411 ff18181818181800   !byte $FF,$18,$18,$18,$18,$18,$18,$00 ; T
    85  e419 c6c6c6c6c6c6fe00   !byte $C6,$C6,$C6,$C6,$C6,$C6,$FE,$00 ; U
    86  e421 c6c6c6c6c67c3800   !byte $C6,$C6,$C6,$C6,$C6,$7C,$38,$00 ; V
    87  e429 c6c6c6c6d6fe6c00   !byte $C6,$C6,$C6,$C6,$D6,$FE,$6C,$00 ; W
    88  e431 c6c66c386cc6c600   !byte $C6,$C6,$6C,$38,$6C,$C6,$C6,$00 ; X
    89  e439 c6c6c67c1830e000   !byte $C6,$C6,$C6,$7C,$18,$30,$E0,$00 ; Y
    90  e441 fe060c183060fe00   !byte $FE,$06,$0C,$18,$30,$60,$FE,$00 ; Z
    91  e449 3c30303030303c00   !byte $3C,$30,$30,$30,$30,$30,$3C,$00 ; [
    92  e451 c06030180c060200   !byte $C0,$60,$30,$18,$0C,$06,$02,$00 ; \
    93  e459 3c0c0c0c0c0c3c00   !byte $3C,$0C,$0C,$0C,$0C,$0C,$3C,$00 ; ]
    94  e461 10386cc600000000   !byte $10,$38,$6C,$C6,$00,$00,$00,$00 ; ^
    95  e469 00000000000000ff   !byte $00,$00,$00,$00,$00,$00,$00,$FF ; _
    96  e471 18180c0000000000   !byte $18,$18,$0C,$00,$00,$00,$00,$00 ; `
    97  e479 00007c067ec67e00   !byte $00,$00,$7C,$06,$7E,$C6,$7E,$00 ; a
    98  e481 c0c0c0fcc6c6fc00   !byte $C0,$C0,$C0,$FC,$C6,$C6,$FC,$00 ; b
    99  e489 00007cc6c0c67c00   !byte $00,$00,$7C,$C6,$C0,$C6,$7C,$00 ; c
   100  e491 0606067ec6c67e00   !byte $06,$06,$06,$7E,$C6,$C6,$7E,$00 ; d
   101  e499 00007cc6fec07c00   !byte $00,$00,$7C,$C6,$FE,$C0,$7C,$00 ; e
   102  e4a1 1c36307830307800   !byte $1C,$36,$30,$78,$30,$30,$78,$00 ; f
   103  e4a9 00007ec6c67e06fc   !byte $00,$00,$7E,$C6,$C6,$7E,$06,$FC ; g
   104  e4b1 c0c0fcc6c6c6c600   !byte $C0,$C0,$FC,$C6,$C6,$C6,$C6,$00 ; h
   105  e4b9 1800381818183c00   !byte $18,$00,$38,$18,$18,$18,$3C,$00 ; i
   106  e4c1 060006060606c67c   !byte $06,$00,$06,$06,$06,$06,$C6,$7C ; j
   107  e4c9 c0c0ccd8f8ccc600   !byte $C0,$C0,$CC,$D8,$F8,$CC,$C6,$00 ; k
   108  e4d1 3818181818183c00   !byte $38,$18,$18,$18,$18,$18,$3C,$00 ; l
   109  e4d9 0000ccfefed6d600   !byte $00,$00,$CC,$FE,$FE,$D6,$D6,$00 ; m
   110  e4e1 0000fcc6c6c6c600   !byte $00,$00,$FC,$C6,$C6,$C6,$C6,$00 ; n
   111  e4e9 00007cc6c6c67c00   !byte $00,$00,$7C,$C6,$C6,$C6,$7C,$00 ; o
   112  e4f1 0000fcc6c6fcc0c0   !byte $00,$00,$FC,$C6,$C6,$FC,$C0,$C0 ; p
   113  e4f9 00007ec6c67e0606   !byte $00,$00,$7E,$C6,$C6,$7E,$06,$06 ; q
   114  e501 0000fcc6c0c0c000   !byte $00,$00,$FC,$C6,$C0,$C0,$C0,$00 ; r
   115  e509 00007ec07c06fc00   !byte $00,$00,$7E,$C0,$7C,$06,$FC,$00 ; s
   116  e511 18187e1818180e00   !byte $18,$18,$7E,$18,$18,$18,$0E,$00 ; t
   117  e519 0000c6c6c6c67e00   !byte $00,$00,$C6,$C6,$C6,$C6,$7E,$00 ; u
   118  e521 0000c6c6c67c3800   !byte $00,$00,$C6,$C6,$C6,$7C,$38,$00 ; v
   119  e529 0000c6c6d6fe6c00   !byte $00,$00,$C6,$C6,$D6,$FE,$6C,$00 ; w
   120  e531 0000c66c386cc600   !byte $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; x
   121  e539 0000c6c6c67e06fc   !byte $00,$00,$C6,$C6,$C6,$7E,$06,$FC ; y
   122  e541 0000fe0c3860fe00   !byte $00,$00,$FE,$0C,$38,$60,$FE,$00 ; z
   123  e549 0e18187018180e00   !byte $0E,$18,$18,$70,$18,$18,$0E,$00 ; {
   124  e551 1818180018181800   !byte $18,$18,$18,$00,$18,$18,$18,$00 ; |
   125  e559 7018180e18187000   !byte $70,$18,$18,$0E,$18,$18,$70,$00 ; }
   126  e561 76dc000000000000   !byte $76,$DC,$00,$00,$00,$00,$00,$00 ; ~

; ******** Source: ../lib\gfx\tms9918.asm
    16  e569 ffffffffffffffff   
    17                          
    18                          HAVE_TMS9918 = 1
    19                          
    20                          ; -------------------------
    21                          ; Constants
    22                          ; -------------------------
    23                          !ifndef TMS9918_IO_PORT { TMS9918_IO_PORT = $10
    24                                  !warn "TMS9918_IO_PORT not provided. Defaulting to ", TMS9918_IO_PORT
    25                          }
    26                          
    27                          !ifndef TMS9918_ZP_START { TMS9918_ZP_START = $30
    28                                  !warn "TMS9918_ZP_START not provided. Defaulting to ", TMS9918_ZP_START
    29                          }
    30                          
    31                          !ifndef TMS9918_RAM_START { TMS9918_RAM_START = $7ba0
    32                                  !warn "TMS9918_RAM_START not provided. Defaulting to ", TMS9918_RAM_START
    33                          }
    34                          
    35                          ; -----------------------------------------------------------------------------
    36                          ; Zero page
    37                          ; -----------------------------------------------------------------------------
    38                          TMS_TMP_ADDRESS         = TMS9918_ZP_START      ; 2 bytes
    39                          TMS9918_ZP_SIZE         = 2                     ; LAST ZP ADDRESS
    40                          
    41                          ; -----------------------------------------------------------------------------
    42                          ; High RAM
    43                          ; -----------------------------------------------------------------------------
    44                          .TMS9918_REG0_SHADOW_ADDR = TMS9918_RAM_START
    45                          .TMS9918_REG1_SHADOW_ADDR = TMS9918_RAM_START + 1
    46                          
    47                          TMS9918_CONSOLE_X         = TMS9918_RAM_START + 2
    48                          TMS9918_CONSOLE_Y         = TMS9918_RAM_START + 3
    49                          TMS9918_CONSOLE_SIZE_X    = TMS9918_RAM_START + 4
    50                          TMS9918_CONSOLE_LINE_LEN  = TMS9918_RAM_START + 5
    51                          .TMS9918_REGX             = TMS9918_RAM_START + 6
    52                          .TMS9918_REGY             = TMS9918_RAM_START + 7
    53                          .TMS9918_TMP_READ_ROW     = TMS9918_RAM_START + 8
    54                          .TMS9918_TMP_WRITE_ROW    = TMS9918_RAM_START + 9
    55                          
    56                          TMS9918_TMP_BUFFER        = TMS9918_RAM_START + 10 ; 40 bytes 
    57                          TMS9918_RAM_SIZE          = 50
    58                          
    59                          
    60                          
    61                          !if TMS9918_ZP_END < (TMS9918_ZP_START + TMS9918_ZP_SIZE) {
    62                          	!error "TMS9918_ZP requires ",TMS9918_ZP_SIZE," bytes. Allocated ",TMS9918_ZP_END - TMS9918_ZP_START
    63                          }
    64                          
    65                          !if TMS9918_RAM_END < (TMS9918_RAM_START + TMS9918_RAM_SIZE) {
    66                          	!error "TMS9918_RAM requires ",.TMS9918_RAM_SIZE," bytes. Allocated ",TMS9918_RAM_END - TMS9918_RAM_START
    67                          }
    68                          
    69                          
    70                          ; IO Ports
    71                          TMS9918_RAM     = IO_PORT_BASE_ADDRESS | TMS9918_IO_PORT
    72                          TMS9918_REG     = IO_PORT_BASE_ADDRESS | TMS9918_IO_PORT | $01
    73                          
    74                          
    75                          ; -----------------------------------------------------------------------------
    76                          ; VRAM addresses
    77                          ; -----------------------------------------------------------------------------
    78                          TMS_VRAM_NAME_ADDRESS           = $3800
    79                          TMS_VRAM_COLOR_ADDRESS          = $0000
    80                          TMS_VRAM_PATT_ADDRESS           = $2000
    81                          TMS_VRAM_SPRITE_ATTR_ADDRESS    = $3B00
    82                          TMS_VRAM_SPRITE_PATT_ADDRESS    = $1800
    83                          
    84                          ; -----------------------------------------------------------------------------
    85                          ; Register values
    86                          ; -----------------------------------------------------------------------------
    87                          TMS_R0_MODE_GRAPHICS_I          = $00
    88                          TMS_R0_MODE_GRAPHICS_II         = $02
    89                          TMS_R0_MODE_MULTICOLOR          = $00
    90                          TMS_R0_MODE_TEXT                = $00
    91                          TMS_R0_EXT_VDP_ENABLE           = $01
    92                          TMS_R0_EXT_VDP_DISABLE          = $00
    93                          
    94                          TMS_R1_RAM_16K                  = $80
    95                          TMS_R1_RAM_4K                   = $00
    96                          TMS_R1_DISP_BLANK               = $00
    97                          TMS_R1_DISP_ACTIVE              = $40
    98                          TMS_R1_INT_ENABLE               = $20
    99                          TMS_R1_INT_DISABLE              = $00
   100                          TMS_R1_MODE_GRAPHICS_I          = $00
   101                          TMS_R1_MODE_GRAPHICS_II         = $00
   102                          TMS_R1_MODE_MULTICOLOR          = $08
   103                          TMS_R1_MODE_TEXT                = $10
   104                          TMS_R1_SPRITE_8                 = $00
   105                          TMS_R1_SPRITE_16                = $02
   106                          TMS_R1_SPRITE_MAG1              = $00
   107                          TMS_R1_SPRITE_MAG2              = $01
   108                          
   109                          ; -----------------------------------------------------------------------------
   110                          ; Color palette
   111                          ; -----------------------------------------------------------------------------
   112                          TMS_TRANSPARENT         = $00
   113                          TMS_BLACK               = $01
   114                          TMS_MED_GREEN           = $02
   115                          TMS_LT_GREEN            = $03
   116                          TMS_DK_BLUE             = $04
   117                          TMS_LT_BLUE             = $05
   118                          TMS_DK_RED              = $06
   119                          TMS_CYAN                = $07
   120                          TMS_MED_RED             = $08
   121                          TMS_LT_RED              = $09
   122                          TMS_DK_YELLOW           = $0a
   123                          TMS_LT_YELLOW           = $0b
   124                          TMS_DK_GREEN            = $0c
   125                          TMS_MAGENTA             = $0d
   126                          TMS_GREY                = $0e
   127                          TMS_WHITE               = $0f
   128                          
   129                          TMS_GFX_TILE_WIDTH      = 8
   130                          TMS_GFX_TILE_HEIGHT     = 8
   131                          TMS_GFX_TILES_X         = 32
   132                          TMS_GFX_TILES_Y         = 24
   133                          TMS_GFX_PIXELS_X        = TMS_GFX_TILES_X * TMS_GFX_TILE_WIDTH
   134                          TMS_GFX_PIXELS_Y        = TMS_GFX_TILES_Y * TMS_GFX_TILE_HEIGHT
   135                          
   136                          TMS_TXT_TILE_WIDTH      = 6
   137                          TMS_TXT_TILE_HEIGHT     = 8
   138                          TMS_TXT_TILES_X         = 40
   139                          TMS_TXT_TILES_Y         = 24
   140                          TMS_TXT_PIXELS_X        = TMS_TXT_TILES_X * TMS_TXT_TILE_WIDTH
   141                          TMS_TXT_PIXELS_Y        = TMS_TXT_TILES_Y * TMS_TXT_TILE_HEIGHT
   142                          
   143                          TMS_SPRITE_SIZE         = 8
   144                          TMS_SPRITE_SIZE2X       = TMS_SPRITE_SIZE * 2
   145                          
   146                          !ifndef TMS_MODEL {
   147                          	!warn "Set TMS_MODEL to one of: 9918, 9929. Defaulting to 9918"
   148                          	TMS_MODEL = 9918
   149                          } 
   150                          
   151                          ; -------------------------
   152                          ; Constants
   153                          ; -------------------------
   154                          
   155                          !if TMS_MODEL = 9918 {
   156                          	TMS_FPS = 60
   157                          } else { !if TMS_MODEL = 9929 {
   158                          	TMS_FPS = 50
   159                          } else {
   160                          	!error "Unknown TMS_MODEL. Must be one of: 9918 or 9929"
   161                          }}
   162                          
   163                          ; -----------------------------------------------------------------------------
   164                          ; Default register values
   165                          ; -----------------------------------------------------------------------------
   166                          TMS_REGISTER_DATA:
   167  e571 00                 !byte TMS_R0_EXT_VDP_DISABLE
   168  e572 80                 !byte TMS_R1_RAM_16K
   169  e573 0e                 !byte TMS_VRAM_NAME_ADDRESS >> 10
   170  e574 00                 !byte TMS_VRAM_COLOR_ADDRESS >> 6
   171  e575 04                 !byte TMS_VRAM_PATT_ADDRESS >> 11
   172  e576 76                 !byte TMS_VRAM_SPRITE_ATTR_ADDRESS >> 7
   173  e577 03                 !byte TMS_VRAM_SPRITE_PATT_ADDRESS >> 11
   174  e578 11                 !byte TMS_BLACK << 4 | TMS_BLACK
   175                          
   176                          
   177                          ; -----------------------------------------------------------------------------
   178                          ; Delay subroutines required for TMS9918 CPU access windows
   179                          ; -----------------------------------------------------------------------------
   180                          ;      CONDITION          MODE    VDP DELAY       WAIT TIME          TOTAL TIME
   181                          ; -----------------------------------------------------------------------------
   182                          ;  Active Display Area   Text        2uS          0 - 1.1uS           2 - 3.1uS      
   183                          ;  Active Display Area   GFX I, II   2uS          0 - 5.95uS          2 - 8uS      
   184                          ;  4300uS after VSYNC    All         2uS             0uS                2uS      
   185                          ;  Reg 1 Blank Bit 0     All         2uS             0uS                2uS      
   186                          ;  Active Display Area   Multicolor  2uS          0 - 1.5uS           2 - 3.5uS      
   187                          ; -----------------------------------------------------------------------------
   188                          _tmsWaitData:
   189  e579 ea                         nop
   190  e57a ea                         nop
   191  e57b ea                         nop
   192  e57c ea                         nop
   193  e57d ea                         nop
   194  e57e ea                         nop
   195  e57f ea                         nop
   196  e580 ea                         nop
   197  e581 ea                         nop
   198                          _tmsWaitReg:
   199  e582 ea                         nop
   200  e583 ea                         nop
   201  e584 ea                         nop
   202  e585 60                         rts
   203                          
   204                          tmsSetAddressNextRow:
   205  e586 a524                       lda TMS_TMP_ADDRESS
   206  e588 18                         clc
   207  e589 6920                       adc #32
   208  e58b 8524                       sta TMS_TMP_ADDRESS
   209  e58d 9002                       bcc +
   210  e58f e625                       inc TMS_TMP_ADDRESS + 1
   211                          +
   212  e591 60                         rts
   213                          
   214                          ; -----------------------------------------------------------------------------
   215                          ; tmsSetAddressWrite: Set an address in the TMS9918 
   216                          ; -----------------------------------------------------------------------------
   217                          ; TMS_TMP_ADDRESS: Address to set
   218                          ; -----------------------------------------------------------------------------
   219                          tmsSetAddressWrite:
   220  e592 08                         php
   221  e593 78                         sei                     ; we can't be interrupted here
   222  e594 a524                       lda TMS_TMP_ADDRESS
   223  e596 8d117f                     sta TMS9918_REG
   224  e599 2082e5                     +tmsWaitReg
   225  e59c a525                       lda TMS_TMP_ADDRESS + 1
   226  e59e 0940                       ora #$40
   227  e5a0 8d117f                     sta TMS9918_REG
   228  e5a3 2082e5                     +tmsWaitReg
   229  e5a6 28                         plp
   230  e5a7 60                         rts
   231                          
   232                          ; -----------------------------------------------------------------------------
   233                          ; tmsSetAddressRead: Set an address to read from the TMS9918 
   234                          ; -----------------------------------------------------------------------------
   235                          ; TMS_TMP_ADDRESS: Address to read
   236                          ; -----------------------------------------------------------------------------
   237                          tmsSetAddressRead:
   238  e5a8 08                         php
   239  e5a9 78                         sei                     ; we can't be interrupted here
   240  e5aa a524                       lda TMS_TMP_ADDRESS
   241  e5ac 8d117f                     sta TMS9918_REG
   242  e5af 2082e5                     +tmsWaitReg
   243  e5b2 a525                       lda TMS_TMP_ADDRESS + 1
   244  e5b4 8d117f                     sta TMS9918_REG
   245  e5b7 2082e5                     +tmsWaitReg
   246  e5ba 28                         plp
   247  e5bb 60                         rts
   248                          
   249                          
   250                          ; -----------------------------------------------------------------------------
   251                          ; tmsSetRegister: Set a register value
   252                          ; -----------------------------------------------------------------------------
   253                          ; Inputs:
   254                          ;  A: The value to set
   255                          ;  X: The register (0 - 7)
   256                          ; -----------------------------------------------------------------------------
   257                          tmsSetRegister:
   258  e5bc 08                         php
   259  e5bd 78                         sei             ; we can't be interrupted here
   260  e5be 8d117f                     sta TMS9918_REG
   261  e5c1 2082e5                     +tmsWaitReg
   262  e5c4 8a                         txa
   263  e5c5 0980                       ora #$80
   264  e5c7 8d117f                     sta TMS9918_REG
   265  e5ca 2082e5                     +tmsWaitReg
   266  e5cd 28                         plp
   267  e5ce 60                         rts
   268                          
   269                          ; -----------------------------------------------------------------------------
   270                          ; tmsSetBackground: Set the background color (R7)
   271                          ; -----------------------------------------------------------------------------
   272                          ; Outputs:
   273                          ;  A: Color. High nibble = FG. Low nibble = BG
   274                          ; -----------------------------------------------------------------------------
   275                          tmsSetBackground:
   276  e5cf a207                       ldx #7
   277  e5d1 d0e9                       bne tmsSetRegister
   278                          
   279                          ; -----------------------------------------------------------------------------
   280                          ; tmsReg0Set: Set register 0
   281                          ; -----------------------------------------------------------------------------
   282                          ; Outputs:
   283                          ;  A: Field values to set (will be OR'd with existing Reg0)
   284                          ; -----------------------------------------------------------------------------
   285                          tmsReg0SetFields:
   286  e5d3 0d267b                     ora .TMS9918_REG0_SHADOW_ADDR
   287                          .tmsReg0SetFields:
   288  e5d6 8d267b                     sta .TMS9918_REG0_SHADOW_ADDR
   289  e5d9 a200                       ldx #0
   290  e5db f0df                       beq tmsSetRegister
   291                                  
   292                          ; -----------------------------------------------------------------------------
   293                          ; tmsReg0Clear: Clear register 0 
   294                          ; -----------------------------------------------------------------------------
   295                          ; Outputs:
   296                          ;  A: Field values to cleared (will be XOR'd with existing Reg0)
   297                          ; -----------------------------------------------------------------------------
   298                          tmsReg0ClearFields:
   299  e5dd 49ff                       eor #$ff
   300  e5df 2d267b                     and .TMS9918_REG0_SHADOW_ADDR
   301  e5e2 4cd6e5                     jmp .tmsReg0SetFields
   302                          
   303                          
   304                          ; -----------------------------------------------------------------------------
   305                          ; tmsReg1Set: Set register 0
   306                          ; -----------------------------------------------------------------------------
   307                          ; Outputs:
   308                          ;  A: Field values to set (will be OR'd with existing Reg1)
   309                          ; -----------------------------------------------------------------------------
   310                          tmsReg1SetFields:
   311  e5e5 0d277b                     ora .TMS9918_REG1_SHADOW_ADDR
   312                          .tmsReg1SetFields:
   313  e5e8 8d277b                     sta .TMS9918_REG1_SHADOW_ADDR
   314  e5eb a201                       ldx #1
   315  e5ed d0cd                       bne tmsSetRegister
   316                                  
   317                          ; -----------------------------------------------------------------------------
   318                          ; tmsReg1Clear: Clear register 1
   319                          ; -----------------------------------------------------------------------------
   320                          ; Outputs:
   321                          ;  A: Field values to cleared (will be XOR'd with existing Reg1)
   322                          ; -----------------------------------------------------------------------------
   323                          tmsReg1ClearFields:
   324  e5ef 49ff                       eor #$ff
   325  e5f1 2d277b                     and .TMS9918_REG1_SHADOW_ADDR
   326  e5f4 4ce8e5                     jmp .tmsReg1SetFields
   327                          
   328                          
   329                          ; -----------------------------------------------------------------------------
   330                          ; tmsModeReset: Reset graphics Mode
   331                          ; -----------------------------------------------------------------------------
   332                          tmsModeReset:
   333  e5f7 a903                       lda #$03
   334  e5f9 20dde5                     jsr tmsReg0ClearFields
   335                          
   336  e5fc a918                       lda #$18
   337  e5fe 20efe5                     jsr tmsReg1ClearFields
   338                          
   339                                  ; if we were in Graphics II, then we need to reset
   340                                  ; the color and pattern table addresses
   341  e601 a900                       lda #<(TMS_VRAM_COLOR_ADDRESS >> 6)
   342  e603 a203                       ldx #3
   343  e605 20bce5                     jsr tmsSetRegister
   344                          
   345  e608 a904                       lda #<(TMS_VRAM_PATT_ADDRESS >> 11)
   346  e60a a204                       ldx #4
   347  e60c 20bce5                     jsr tmsSetRegister
   348  e60f 60                         rts
   349                          
   350                          ; -----------------------------------------------------------------------------
   351                          ; tmsModeGraphicsI: Set up for Graphics I mode
   352                          ; -----------------------------------------------------------------------------
   353                          tmsModeGraphicsI:
   354  e610 20f7e5                     jsr tmsModeReset
   355                          
   356  e613 a900                       lda #TMS_R0_MODE_GRAPHICS_I
   357  e615 20d3e5                     jsr tmsReg0SetFields
   358                          
   359  e618 a900                       lda #TMS_R1_MODE_GRAPHICS_I
   360  e61a 20e5e5                     jsr tmsReg1SetFields
   361                          
   362  e61d a920                       lda #32
   363  e61f 8d2a7b                     sta TMS9918_CONSOLE_SIZE_X
   364  e622 60                         rts
   365                          
   366                          ; -----------------------------------------------------------------------------
   367                          ; tmsModeBitmap: Set up for Graphics II mode and set up name table for bitmap
   368                          ; -----------------------------------------------------------------------------
   369                          tmsModeBitmap:
   370  e623 08                         php
   371  e624 78                         sei
   372                                          ; clear the name table
   373  e625 0878a9008d117f20...        +tmsSetAddrNameTable
   374  e638 a003                       ldy #3
   375  e63a a900                       lda #0
   376                          -
   377  e63c 8d107f2079e5               +tmsPut
   378  e642 1a                         inc
   379  e643 d0f7                       bne -
   380  e645 88                         dey
   381  e646 d0f4                       bne -
   382                          
   383                                  ; set all color table entries to transparent
   384  e648 0878a9008d117f20...        +tmsSetAddrColorTable
   385  e65b a9f1                       +tmsColorFgBg TMS_WHITE, TMS_BLACK
   386  e65d 201be7                     jsr _tmsSendKb
   387  e660 201be7                     jsr _tmsSendKb
   388  e663 201be7                     jsr _tmsSendKb
   389  e666 201be7                     jsr _tmsSendKb
   390  e669 201be7                     jsr _tmsSendKb
   391  e66c 201be7                     jsr _tmsSendKb        
   392                          
   393                                  ; clear the pattern table
   394  e66f 0878a9008d117f20...        +tmsSetAddrPattTable
   395  e682 a900                       lda #0
   396  e684 201be7                     jsr _tmsSendKb
   397  e687 201be7                     jsr _tmsSendKb
   398  e68a 201be7                     jsr _tmsSendKb
   399  e68d 201be7                     jsr _tmsSendKb
   400  e690 201be7                     jsr _tmsSendKb
   401  e693 201be7                     jsr _tmsSendKb
   402                          
   403  e696 28                         plp
   404                                  
   405                                  ; flow on through
   406                          
   407                          ; -----------------------------------------------------------------------------
   408                          ; tmsModeGraphicsII: Set up for Graphics II mode
   409                          ; -----------------------------------------------------------------------------
   410                          tmsModeGraphicsII:
   411  e697 20f7e5                     jsr tmsModeReset
   412                          
   413  e69a a902                       lda #TMS_R0_MODE_GRAPHICS_II
   414  e69c 20d3e5                     jsr tmsReg0SetFields
   415                          
   416  e69f a900                       lda #TMS_R1_MODE_GRAPHICS_II
   417  e6a1 20e5e5                     jsr tmsReg1SetFields
   418                          
   419                                  ; in Graphics II, Registers 3 and 4 work differently
   420                                  ;
   421                                  ; reg3 - Color table
   422                                  ;   $7f = $0000
   423                                  ;   $ff = $2000
   424                                  ;
   425                                  ; reg4 - Pattern table
   426                                  ;  $03 = $0000
   427                                  ;  $07 = $2000
   428                          
   429                                  ; set color table to $0000
   430  e6a4 a97f                       lda #$7f
   431  e6a6 a203                       ldx #3
   432  e6a8 20bce5                     jsr tmsSetRegister
   433                          
   434                                  ; set pattern table to $2000
   435  e6ab a907                       lda #$07
   436  e6ad a204                       ldx #4
   437  e6af 20bce5                     jsr tmsSetRegister
   438                          
   439  e6b2 a920                       lda #32
   440  e6b4 8d2a7b                     sta TMS9918_CONSOLE_SIZE_X
   441                          
   442  e6b7 60                         rts
   443                          
   444                          ; -----------------------------------------------------------------------------
   445                          ; tmsModeText: Set up for Text mode
   446                          ; -----------------------------------------------------------------------------
   447                          tmsModeText:
   448  e6b8 20f7e5                     jsr tmsModeReset
   449                          
   450  e6bb a900                       lda #TMS_R0_MODE_TEXT
   451  e6bd 20d3e5                     jsr tmsReg0SetFields
   452                          
   453  e6c0 a910                       lda #TMS_R1_MODE_TEXT
   454  e6c2 20e5e5                     jsr tmsReg1SetFields
   455                          
   456  e6c5 a928                       lda #40
   457  e6c7 8d2a7b                     sta TMS9918_CONSOLE_SIZE_X
   458                          
   459  e6ca 60                         rts
   460                          
   461                          ; -----------------------------------------------------------------------------
   462                          ; tmsModeMulticolor: Set up for Multicolor mode
   463                          ; -----------------------------------------------------------------------------
   464                          tmsModeMulticolor:
   465  e6cb 20f7e5                     jsr tmsModeReset
   466                          
   467  e6ce a900                       lda #TMS_R0_MODE_MULTICOLOR
   468  e6d0 20d3e5                     jsr tmsReg0SetFields
   469                          
   470  e6d3 a908                       lda #TMS_R1_MODE_MULTICOLOR
   471  e6d5 20e5e5                     jsr tmsReg1SetFields
   472  e6d8 60                         rts
   473                          
   474                          ; -----------------------------------------------------------------------------
   475                          ; tmsInit: Initialise the registers
   476                          ; -----------------------------------------------------------------------------
   477                          tmsInit:
   478  e6d9 08                         php
   479  e6da 78                         sei                             ; we can't be interrupted here
   480  e6db ad71e5                     lda TMS_REGISTER_DATA
   481  e6de 8d267b                     sta .TMS9918_REG0_SHADOW_ADDR
   482  e6e1 ad72e5                     lda TMS_REGISTER_DATA + 1
   483  e6e4 8d277b                     sta .TMS9918_REG1_SHADOW_ADDR
   484                          
   485  e6e7 a900                       lda #0
   486  e6e9 8d287b                     sta TMS9918_CONSOLE_X
   487  e6ec 8d297b                     sta TMS9918_CONSOLE_Y
   488                          
   489                                  ; set up the registers
   490  e6ef a200                       ldx #0
   491                          
   492                          @regLoop
   493  e6f1 bd71e5                             lda TMS_REGISTER_DATA, x
   494  e6f4 8d117f                             sta TMS9918_REG
   495  e6f7 2082e5                             +tmsWaitReg
   496  e6fa 8a                                 txa
   497  e6fb 0980                               ora #$80
   498  e6fd 8d117f                             sta TMS9918_REG
   499  e700 2082e5                             +tmsWaitReg
   500  e703 e8                                 inx
   501  e704 e008                               cpx #8
   502  e706 d0e9                               bne @regLoop
   503                                  
   504  e708 2010e6                     jsr tmsModeGraphicsI
   505                          
   506                                  ; load all data into VRAM
   507  e70b 206de7                     jsr tmsInitPattTable
   508                          
   509  e70e 20ade7                     jsr tmsInitTextTable
   510                                  
   511  e711 a917                       +tmsColorFgBg TMS_BLACK, TMS_CYAN
   512  e713 20d1e7                     jsr tmsInitEntireColorTable
   513                          
   514  e716 20f2e7                     jsr tmsInitSpriteTable
   515                          
   516  e719 28                         plp
   517                                  
   518  e71a 60                         rts
   519                          
   520                          ; -----------------------------------------------------------------------------
   521                          ; _tmsSendPage: Send A for a kilobyte
   522                          ; -----------------------------------------------------------------------------
   523                          _tmsSendKb
   524  e71b 2024e7                     jsr _tmsSendPage
   525  e71e 2024e7                     jsr _tmsSendPage
   526  e721 2024e7                     jsr _tmsSendPage
   527                                  ; flow through
   528                                  
   529                          ; -----------------------------------------------------------------------------
   530                          ; _tmsSendPage: Send A for a whole page
   531                          ; -----------------------------------------------------------------------------
   532                          _tmsSendPage:
   533  e724 a220                       ldx #32
   534                          _tmsSendX8:
   535  e726 8d107f2079e5               +tmsPut
   536  e72c 8d107f2079e5               +tmsPut
   537  e732 8d107f2079e5               +tmsPut
   538  e738 8d107f2079e5               +tmsPut
   539  e73e 8d107f2079e5               +tmsPut
   540  e744 8d107f2079e5               +tmsPut
   541  e74a 8d107f2079e5               +tmsPut
   542  e750 8d107f2079e5               +tmsPut
   543  e756 ca                         dex
   544  e757 d0cd                       bne _tmsSendX8
   545  e759 60                         rts
   546                          
   547                          ; -----------------------------------------------------------------------------
   548                          ; _tmsSendEmptyPage: Send an empty page of data
   549                          ; -----------------------------------------------------------------------------
   550                          _tmsSendEmptyPage:
   551  e75a a900                       lda #0
   552  e75c f0c6                       beq _tmsSendPage ; rts in here
   553                          
   554                          ; -----------------------------------------------------------------------------
   555                          ; tmsSendBytes: Send bytes to the TMS (up to 1 page)
   556                          ; -----------------------------------------------------------------------------
   557                          ; Inputs:
   558                          ;   TMS_TMP_ADDRESS:    Holds source address
   559                          ;   X:                  Number of bytes (1 to 256)
   560                          ; -----------------------------------------------------------------------------
   561                          tmsSendBytes:
   562  e75e a000                       ldy #0
   563                          -
   564  e760 b124                       lda (TMS_TMP_ADDRESS), Y
   565  e762 8d107f2079e5               +tmsPut
   566  e768 c8                         iny
   567  e769 ca                         dex
   568  e76a d0f4                       bne -
   569  e76c 60                         rts
   570                          
   571                          ; -----------------------------------------------------------------------------
   572                          ; tmsInitPattTable: Initialise the pattern table
   573                          ; -----------------------------------------------------------------------------
   574                          tmsInitPattTable:
   575                                  
   576                          
   577                                  ; pattern table
   578  e76d 0878a9008d117f20...        +tmsSetAddrPattTable
   579                          
   580                                  ; (0 - 31) all empty
   581  e780 205ae7                     jsr _tmsSendEmptyPage
   582                          
   583  e783 a9718524a9e28525...        +tmsSendData TMS_FONT_DATA, $300
   584                          
   585                                  ; (128 - 159) all empty
   586  e7a0 205ae7                     jsr _tmsSendEmptyPage
   587                          
   588                                  ; (160 - 191) all empty
   589  e7a3 205ae7                     jsr _tmsSendEmptyPage
   590                          
   591                                  ; (192 - 223) all empty
   592  e7a6 205ae7                     jsr _tmsSendEmptyPage
   593                          
   594                                  ; (224 - 255) all empty
   595  e7a9 205ae7                     jsr _tmsSendEmptyPage
   596                          
   597                                  
   598                          
   599  e7ac 60                         rts
   600                          
   601                          ; -----------------------------------------------------------------------------
   602                          ; tmsInitTextTable: Initialise the text (tilemap) table
   603                          ; -----------------------------------------------------------------------------
   604                          tmsInitTextTable:
   605                                  
   606                          
   607                                  ; text table table
   608  e7ad 0878a9008d117f20...        +tmsSetAddrNameTable
   609                          
   610                          
   611  e7c0 18                         clc
   612  e7c1 ad2a7b                     lda TMS9918_CONSOLE_SIZE_X
   613  e7c4 6d2a7b                     adc TMS9918_CONSOLE_SIZE_X
   614  e7c7 6d2a7b                     adc TMS9918_CONSOLE_SIZE_X
   615  e7ca aa                         tax
   616  e7cb a900                       lda #0
   617  e7cd 2026e7                     jsr _tmsSendX8
   618                          
   619  e7d0 60                         rts
   620                          
   621                          
   622                          ; -----------------------------------------------------------------------------
   623                          ; tmsInitEntireColorTable: Initialise the full color table
   624                          ; -----------------------------------------------------------------------------
   625                          ; Inputs:
   626                          ;   A: Color (fg/bg) to initialise
   627                          
   628                          tmsInitEntireColorTable:
   629  e7d1 a220                       ldx #32
   630                          
   631                          ; tmsInitColorTable: Initialise the color table
   632                          
   633                          ; Inputs:
   634                          ;   A: Color (fg/bg) to initialise
   635                          ;   X: Number of elements to initialise (1 to 32)
   636                          ; -----------------------------------------------------------------------------
   637                          tmsInitColorTable:
   638                                  
   639  e7d3 48                         pha
   640                          
   641                                  ; color table
   642  e7d4 0878a9008d117f20...        +tmsSetAddrColorTable
   643                          
   644  e7e7 68                         pla
   645                          -
   646  e7e8 8d107f2079e5               +tmsPut
   647  e7ee ca                         dex
   648  e7ef d0f7                       bne -
   649                          
   650  e7f1 60                         rts
   651                          
   652                          ; -----------------------------------------------------------------------------
   653                          ; tmsInitSpriteTable: Initialise the sprite table
   654                          ; -----------------------------------------------------------------------------
   655                          tmsInitSpriteTable:
   656                                  
   657                          
   658                                  ; sprites table
   659  e7f2 0878a9008d117f20...        +tmsSetAddrSpriteAttrTable
   660                          
   661  e805 a220                       ldx #32
   662                          -
   663                                  ; Vertical position
   664  e807 a9d08d107f2079e5           +tmsPut $D0        ; 208 ($D0) stops processing of sprites
   665  e80f a9008d107f2079e5           +tmsPut $00        ; Horizontal position
   666                          
   667                                  ; Index (A still 0)
   668  e817 8d107f2079e5               +tmsPut
   669                                  ; Early Clock / Color  (A still 0)
   670  e81d 8d107f2079e5               +tmsPut
   671  e823 ca                         dex
   672  e824 d0e1                       bne -
   673                          
   674                                  
   675                          
   676  e826 60                         rts
   677                          
   678                          ; -----------------------------------------------------------------------------
   679                          ; tmsTileXyAtPixelXy: Return tile position at pixel position
   680                          ; -----------------------------------------------------------------------------
   681                          ; Inputs:
   682                          ;  X: Pixel position X
   683                          ;  Y: Pixel position Y
   684                          ; Outputs:
   685                          ;  X: Tile position X
   686                          ;  Y: Tile position Y
   687                          ; -----------------------------------------------------------------------------
   688                          tmsTileXyAtPixelXy:
   689  e827 48                         pha
   690  e828 8a                         txa
   691  e829 4a4a4a                     +div8
   692  e82c aa                         tax
   693                          
   694  e82d 98                         tya
   695  e82e 4a4a4a                     +div8
   696  e831 a8                         tay
   697  e832 68                         pla
   698  e833 60                         rts
   699                          
   700                          ; -----------------------------------------------------------------------------
   701                          ; tmsHex8: Output an 8-bit byte as hexadecimal
   702                          ; -----------------------------------------------------------------------------
   703                          ; Inputs:
   704                          ;  A: The value to output
   705                          ; -----------------------------------------------------------------------------
   706                          tmsHex8:
   707  e834 48                 	pha
   708  e835 4a4a4a4a                   +lsr4
   709  e839 aa                 	tax
   710  e83a bd51e8             	lda .H2, x
   711  e83d 8d107f2079e5               +tmsPut 
   712  e843 68                 	pla
   713  e844 290f               	and #$0f
   714  e846 aa                 	tax
   715  e847 bd51e8             	lda .H2, x
   716  e84a 8d107f2079e5               +tmsPut 
   717                                  
   718  e850 60                 	rts
   719                          
   720  e851 3031323334353637....H2 !text "0123456789abcdef"
   721                          
   722                          
   723                          ; -----------------------------------------------------------------------------
   724                          ; tmsSetSpriteTmpAddress: Set TMS_TMP_ADDRESS for a given sprite attributes
   725                          ; -----------------------------------------------------------------------------
   726                          ; Inputs:
   727                          ;   A: sprite index (0-31)
   728                          ; -----------------------------------------------------------------------------
   729                          tmsSetSpriteTmpAddress:
   730  e861 0a                         asl
   731  e862 0a                         asl
   732  e863 8524                       sta TMS_TMP_ADDRESS
   733                          
   734  e865 a93b                       lda #>TMS_VRAM_SPRITE_ATTR_ADDRESS
   735  e867 8525                       sta TMS_TMP_ADDRESS + 1
   736  e869 60                         rts
   737                          
   738                          ; -----------------------------------------------------------------------------
   739                          ; tmsSetPosTmpAddress: Set TMS_TMP_ADDRESS for a given text position
   740                          ; -----------------------------------------------------------------------------
   741                          ; Inputs:
   742                          ;   X: X position (0 - 31)
   743                          ;   Y: Y position (0 - 23)
   744                          ; -----------------------------------------------------------------------------
   745                          tmsSetPosTmpAddress:
   746  e86a a938                       lda #>TMS_VRAM_NAME_ADDRESS
   747  e86c 8525                       sta TMS_TMP_ADDRESS + 1
   748                                  
   749                                  ; this can be better. rotate and save, perhaps
   750                          
   751  e86e 98                         tya
   752  e86f 4a4a4a                     +div8
   753  e872 18                         clc
   754  e873 6525                       adc TMS_TMP_ADDRESS + 1
   755  e875 8525                       sta TMS_TMP_ADDRESS + 1
   756  e877 98                         tya
   757  e878 2907                       and #$07
   758  e87a 0a0a0a0a0a                 +mul32
   759  e87f 8524                       sta TMS_TMP_ADDRESS
   760  e881 8a                         txa
   761  e882 0524                       ora TMS_TMP_ADDRESS
   762  e884 8524                       sta TMS_TMP_ADDRESS
   763  e886 60                         rts
   764                          
   765                          ; -----------------------------------------------------------------------------
   766                          ; tmsSetPosTmpAddressText: Set TMS_TMP_ADDRESS for a given text position
   767                          ; -----------------------------------------------------------------------------
   768                          ; Inputs:
   769                          ;   X: X position (0 - 39)
   770                          ;   Y: Y position (0 - 23)
   771                          ; -----------------------------------------------------------------------------
   772                          tmsSetPosTmpAddressText:
   773  e887 a938                       lda #>TMS_VRAM_NAME_ADDRESS
   774  e889 8525                       sta TMS_TMP_ADDRESS + 1
   775  e88b a900                       lda #<TMS_VRAM_NAME_ADDRESS
   776  e88d 8524                       sta TMS_TMP_ADDRESS
   777                          
   778                          .tmsSetPosTmpAddressTextLoop
   779  e88f c000                       cpy #0
   780  e891 f00e                       beq ++
   781  e893 18                         clc
   782  e894 a524                       lda TMS_TMP_ADDRESS
   783  e896 6928                       adc #40
   784  e898 8524                       sta TMS_TMP_ADDRESS
   785  e89a 9002                       bcc +
   786  e89c e625                       inc TMS_TMP_ADDRESS + 1
   787                          +
   788  e89e 88                         dey
   789  e89f d0ee                       bne .tmsSetPosTmpAddressTextLoop
   790                          ++
   791  e8a1 18                         clc
   792  e8a2 8a                         txa
   793  e8a3 6524                       adc TMS_TMP_ADDRESS
   794  e8a5 8524                       sta TMS_TMP_ADDRESS
   795  e8a7 9002                       bcc +
   796  e8a9 e625                       inc TMS_TMP_ADDRESS + 1
   797                          +
   798  e8ab 60                         rts
   799                          
   800                          
   801                          tmsConsoleScrollLine:
   802  e8ac a900                       lda #0
   803  e8ae 8d2f7b                     sta .TMS9918_TMP_WRITE_ROW
   804  e8b1 a901                       lda #1
   805  e8b3 8d2e7b                     sta .TMS9918_TMP_READ_ROW
   806                          .nextRow:
   807                          
   808  e8b6 ac2e7b                     ldy .TMS9918_TMP_READ_ROW
   809  e8b9 a200                       ldx #0
   810  e8bb a928                       lda #40
   811  e8bd cd2a7b                     cmp TMS9918_CONSOLE_SIZE_X
   812  e8c0 f006                       beq +
   813  e8c2 206ae8                     jsr tmsSetPosTmpAddress
   814  e8c5 4ccbe8                     jmp ++
   815                          +
   816  e8c8 2087e8                     jsr tmsSetPosTmpAddressText
   817                          ++
   818  e8cb 20a8e5                     jsr tmsSetAddressRead
   819                          
   820  e8ce 20fce8                     jsr .tmsBufferIn
   821                          
   822  e8d1 a200                       ldx #0
   823  e8d3 ac2f7b                     ldy .TMS9918_TMP_WRITE_ROW
   824  e8d6 a200                       ldx #0
   825  e8d8 a928                       lda #40
   826  e8da cd2a7b                     cmp TMS9918_CONSOLE_SIZE_X
   827  e8dd f006                       beq +
   828  e8df 206ae8                     jsr tmsSetPosTmpAddress
   829  e8e2 4ce8e8                     jmp ++
   830                          +
   831  e8e5 2087e8                     jsr tmsSetPosTmpAddressText
   832                          ++
   833  e8e8 2092e5                     jsr tmsSetAddressWrite
   834                          
   835  e8eb 200ee9                     jsr .tmsBufferOut
   836                          
   837                          
   838  e8ee ee2f7b                     inc .TMS9918_TMP_WRITE_ROW
   839  e8f1 ee2e7b                     inc .TMS9918_TMP_READ_ROW
   840                          
   841  e8f4 ad2e7b                     lda .TMS9918_TMP_READ_ROW
   842  e8f7 c919                       cmp #25
   843                          
   844  e8f9 d0bb                       bne .nextRow
   845                          
   846                          
   847                                  ; copy to buffer 32 bytes at a time, write back  24 rows for gfx, 30 "rows" for text
   848  e8fb 60                         rts
   849                          
   850                          .tmsBufferIn:
   851  e8fc a200                       ldx #0
   852                          -
   853  e8fe ad107f2079e5               +tmsGet
   854  e904 9d307b                     sta TMS9918_TMP_BUFFER, x
   855  e907 e8                         inx
   856  e908 ec2a7b                     cpx TMS9918_CONSOLE_SIZE_X
   857  e90b d0f1                       bne -
   858  e90d 60                         rts
   859                          
   860                          .tmsBufferOut:
   861  e90e a200                       ldx #0
   862                          
   863                          -
   864  e910 bd307b                     lda TMS9918_TMP_BUFFER, x
   865  e913 8d107f2079e5               +tmsPut
   866  e919 e8                         inx
   867  e91a ec2a7b                     cpx TMS9918_CONSOLE_SIZE_X
   868  e91d d0f1                       bne -
   869  e91f 60                         rts
   870                          
   871                          ; -----------------------------------------------------------------------------
   872                          ; tmsIncPosConsole: Increment console position
   873                          ; -----------------------------------------------------------------------------
   874                          tmsIncPosConsole:
   875  e920 ee287b                     inc TMS9918_CONSOLE_X
   876  e923 ad287b                     lda TMS9918_CONSOLE_X
   877  e926 cd2a7b                     cmp TMS9918_CONSOLE_SIZE_X
   878  e929 d008                       bne +
   879  e92b a900                       lda #0
   880  e92d 8d287b                     sta TMS9918_CONSOLE_X
   881  e930 ee297b                     inc TMS9918_CONSOLE_Y
   882                          +
   883  e933 ad297b                     lda TMS9918_CONSOLE_Y
   884  e936 c918                       cmp #24
   885  e938 9006                       bcc +
   886  e93a ce297b                     dec TMS9918_CONSOLE_Y
   887  e93d 4cace8                     jmp tmsConsoleScrollLine
   888                          +
   889  e940 60                         rts
   890                          
   891                          
   892                          ; -----------------------------------------------------------------------------
   893                          ; tmsDecPosConsole: Increment console position
   894                          ; -----------------------------------------------------------------------------
   895                          tmsDecPosConsole:
   896  e941 ce287b                     dec TMS9918_CONSOLE_X
   897  e944 1017                       bpl ++
   898  e946 ad2a7b                     lda TMS9918_CONSOLE_SIZE_X
   899  e949 8d287b                     sta TMS9918_CONSOLE_X
   900  e94c ce287b                     dec TMS9918_CONSOLE_X
   901  e94f a900                       lda #0
   902  e951 cd297b                     cmp TMS9918_CONSOLE_Y
   903  e954 d004                       bne +
   904  e956 8d287b                     sta TMS9918_CONSOLE_X
   905  e959 60                         rts        
   906                          +
   907  e95a ce297b                     dec TMS9918_CONSOLE_Y
   908                          ++
   909  e95d 60                         rts
   910                          
   911                          ; -----------------------------------------------------------------------------
   912                          ; tmsConsoleCls: Clear the screen and reset the console location
   913                          ; -----------------------------------------------------------------------------
   914                          tmsConsoleCls:
   915  e95e 20ade7                     jsr tmsInitTextTable
   916                          
   917                                  ; flow through
   918                          
   919                          ; -----------------------------------------------------------------------------
   920                          ; tmsConsoleHome: Set cursor position top left
   921                          ; -----------------------------------------------------------------------------
   922                          tmsConsoleHome:
   923  e961 9c287b                     stz TMS9918_CONSOLE_X
   924  e964 9c297b                     stz TMS9918_CONSOLE_Y
   925                          
   926                                  ; flow through
   927                          
   928                          ; -----------------------------------------------------------------------------
   929                          ; tmsSetPosConsole: Set cursor position to console position
   930                          ; -----------------------------------------------------------------------------
   931                          tmsSetPosConsole:
   932  e967 ae287b                     ldx TMS9918_CONSOLE_X
   933  e96a ac297b                     ldy TMS9918_CONSOLE_Y
   934                          
   935                                  ; flow through
   936                          
   937                          ; -----------------------------------------------------------------------------
   938                          ; tmsSetPosWrite: Set cursor position
   939                          ; -----------------------------------------------------------------------------
   940                          ; Inputs:
   941                          ;   X: X position (0 - 31)
   942                          ;   Y: Y position (0 - 23)
   943                          ; -----------------------------------------------------------------------------
   944                          tmsSetPosWrite:
   945  e96d a910                       lda #TMS_R1_MODE_TEXT
   946  e96f 2c277b                     bit .TMS9918_REG1_SHADOW_ADDR
   947  e972 d006                       bne tmsSetPosWriteText
   948  e974 206ae8                     jsr tmsSetPosTmpAddress
   949  e977 4c92e5                     jmp tmsSetAddressWrite
   950                          
   951                          ; -----------------------------------------------------------------------------
   952                          ; tmsSetPosWrite: Set cursor position (text mode)
   953                          ; -----------------------------------------------------------------------------
   954                          ; Inputs:
   955                          ;   X: X position (0 - 39)
   956                          ;   Y: Y position (0 - 23)
   957                          ; -----------------------------------------------------------------------------
   958                          tmsSetPosWriteText:
   959  e97a 2087e8                     jsr tmsSetPosTmpAddressText
   960  e97d 4c92e5                     jmp tmsSetAddressWrite
   961                          
   962                          ; -----------------------------------------------------------------------------
   963                          ; tmsSetPosRead: Set cursor position to read from
   964                          ; -----------------------------------------------------------------------------
   965                          ; Inputs:
   966                          ;   X: X position (0 - 31)
   967                          ;   Y: Y position (0 - 23)
   968                          ; -----------------------------------------------------------------------------
   969                          tmsSetPosRead:
   970  e980 206ae8                     jsr tmsSetPosTmpAddress
   971  e983 4ca8e5                     jmp tmsSetAddressRead
   972                          ; -----------------------------------------------------------------------------
   973                          ; tmsSetColorTmpAddressII: Set TMS_TMP_ADDRESS for a given mode II color definition
   974                          ; -----------------------------------------------------------------------------
   975                          ; Inputs:
   976                          ;   X: X position
   977                          ;   Y: Y position
   978                          ; -----------------------------------------------------------------------------
   979                          tmsSetColorTmpAddressII:
   980  e986 a900                       lda #>TMS_VRAM_COLOR_ADDRESS
   981  e988 8002                       bra .addXYToAddress
   982                          
   983                          ; -----------------------------------------------------------------------------
   984                          ; tmsSetPatternTmpAddress: Set TMS_TMP_ADDRESS for a given mode II pattern definition
   985                          ; -----------------------------------------------------------------------------
   986                          ; Inputs:
   987                          ;   X: X position
   988                          ;   Y: Y position
   989                          ; -----------------------------------------------------------------------------
   990                          tmsSetPatternTmpAddressII:
   991  e98a a920                       lda #>TMS_VRAM_PATT_ADDRESS
   992                          
   993                          .addXYToAddress:
   994  e98c 8525                       sta TMS_TMP_ADDRESS + 1
   995                          
   996  e98e 98                         tya
   997  e98f 4a4a4a                     +lsr3
   998  e992 0525                       ora TMS_TMP_ADDRESS + 1
   999  e994 8525                       sta TMS_TMP_ADDRESS + 1
  1000                          
  1001  e996 8a                         txa
  1002  e997 29f8                       and #$f8
  1003  e999 8524                       sta TMS_TMP_ADDRESS
  1004                          
  1005  e99b 98                         tya
  1006  e99c 2907                       and #$07
  1007  e99e 0524                       ora TMS_TMP_ADDRESS
  1008  e9a0 8524                       sta TMS_TMP_ADDRESS
  1009                          
  1010  e9a2 60                         rts
  1011                          
  1012                          ; -----------------------------------------------------------------------------
  1013                          ; tmsSetPatternTmpAddress: Set TMS_TMP_ADDRESS for a given pattern definition
  1014                          ; -----------------------------------------------------------------------------
  1015                          ; Inputs:
  1016                          ;   A: Pattern number
  1017                          ;   Y: Y offset (row) in the pattern
  1018                          ; -----------------------------------------------------------------------------
  1019                          tmsSetPatternTmpAddressBank0:
  1020                          tmsSetPatternTmpAddress:
  1021  e9a3 48                         pha
  1022  e9a4 a920                       lda #>TMS_VRAM_PATT_ADDRESS
  1023  e9a6 8525                       sta TMS_TMP_ADDRESS + 1
  1024                                  
  1025  e9a8 68                         pla
  1026  e9a9 48                         pha
  1027                          
  1028  e9aa 4a4a4a4a4a                 +div32
  1029  e9af 18                         clc
  1030  e9b0 6525                       adc TMS_TMP_ADDRESS + 1
  1031  e9b2 8525                       sta TMS_TMP_ADDRESS + 1
  1032  e9b4 68                         pla
  1033  e9b5 0a0a0a                     +mul8
  1034  e9b8 8524                       sta TMS_TMP_ADDRESS
  1035  e9ba 98                         tya
  1036  e9bb 0524                       ora TMS_TMP_ADDRESS
  1037  e9bd 8524                       sta TMS_TMP_ADDRESS
  1038  e9bf 60                         rts
  1039                          
  1040                          ; -----------------------------------------------------------------------------
  1041                          ; tmsSetPatternTmpAddressBank1: Set TMS_TMP_ADDRESS for a given pattern 
  1042                          ;                               definition in bank 1 (GFX II)
  1043                          ; -----------------------------------------------------------------------------
  1044                          ; Inputs:
  1045                          ;   A: Pattern number
  1046                          ;   Y: Y offset (row) in the pattern
  1047                          ; -----------------------------------------------------------------------------
  1048                          tmsSetPatternTmpAddressBank1:
  1049  e9c0 20a3e9                     jsr tmsSetPatternTmpAddress
  1050  e9c3 a525                       lda TMS_TMP_ADDRESS + 1
  1051  e9c5 18                         clc
  1052  e9c6 6908                       adc #8
  1053  e9c8 8525                       sta TMS_TMP_ADDRESS + 1
  1054  e9ca 60                         rts
  1055                          
  1056                          ; -----------------------------------------------------------------------------
  1057                          ; tmsSetPatternTmpAddressBank2: Set TMS_TMP_ADDRESS for a given pattern 
  1058                          ;                               definition in bank 2 (GFX II)
  1059                          ; -----------------------------------------------------------------------------
  1060                          ; Inputs:
  1061                          ;   A: Pattern number
  1062                          ;   Y: Y offset (row) in the pattern
  1063                          ; -----------------------------------------------------------------------------
  1064                          tmsSetPatternTmpAddressBank2:
  1065  e9cb 20a3e9                     jsr tmsSetPatternTmpAddress
  1066  e9ce a525                       lda TMS_TMP_ADDRESS + 1
  1067  e9d0 18                         clc
  1068  e9d1 6910                       adc #16
  1069  e9d3 8525                       sta TMS_TMP_ADDRESS + 1
  1070  e9d5 60                         rts        
  1071                          
  1072                          ; -----------------------------------------------------------------------------
  1073                          ; tmsSetPatternWrite: Set pattern definition to write to
  1074                          ; -----------------------------------------------------------------------------
  1075                          ; Inputs:
  1076                          ;   A: Pattern number
  1077                          ;   Y: Y offset (row) in the pattern
  1078                          ; -----------------------------------------------------------------------------
  1079                          tmsSetPatternWrite:
  1080  e9d6 20a3e9                     jsr tmsSetPatternTmpAddress
  1081  e9d9 4c92e5                     jmp tmsSetAddressWrite
  1082                          
  1083                          ; -----------------------------------------------------------------------------
  1084                          ; tmsSetPatternRead: Set pattern definition to read from
  1085                          ; -----------------------------------------------------------------------------
  1086                          ; Inputs:
  1087                          ;   A: Pattern number
  1088                          ;   Y: Y offset (row) in the pattern
  1089                          ; -----------------------------------------------------------------------------
  1090                          tmsSetPatternRead:
  1091  e9dc 20a3e9                     jsr tmsSetPatternTmpAddress
  1092  e9df 4ca8e5                     jmp tmsSetAddressRead
  1093                          
  1094                          
  1095                          ; -----------------------------------------------------------------------------
  1096                          ; tmsPrint: Print a null-terminated string
  1097                          ; -----------------------------------------------------------------------------
  1098                          ; Inputs:
  1099                          ;  STR_ADDR: Contains address of null-terminated string
  1100                          ; Prerequisites:
  1101                          ;  TMS address already set using +tmsSetAddressWrite
  1102                          ; -----------------------------------------------------------------------------
  1103                          tmsPrint:
  1104  e9e2 a000               	ldy #0
  1105                          -
  1106  e9e4 2079e5             	+tmsWaitData
  1107  e9e7 b132               	lda (STR_ADDR), y
  1108  e9e9 f009               	beq +
  1109  e9eb 8d107f2079e5               +tmsPut 
  1110  e9f1 c8                 	iny
  1111  e9f2 d0f0               	bne -
  1112                          +
  1113  e9f4 60                 	rts
  1114                          
  1115                          
  1116                          ; -----------------------------------------------------------------------------
  1117                          ; tmsConsoleOut: Print a null-terminated string
  1118                          ; -----------------------------------------------------------------------------
  1119                          ; Inputs:
  1120                          ;  'A': Character to output to console
  1121                          ; -----------------------------------------------------------------------------
  1122                          tmsConsoleOut:
  1123  e9f5 8e2c7b                     stx .TMS9918_REGX
  1124  e9f8 8c2d7b                     sty .TMS9918_REGY
  1125  e9fb 08                         php
  1126  e9fc 78                         sei
  1127  e9fd c90d                       cmp #$0d ; enter
  1128  e9ff f021                       beq .tmsConsoleNewline
  1129  ea01 c90a                       cmp #$0a ; enter
  1130  ea03 f01d                       beq .tmsConsoleNewline
  1131                          
  1132  ea05 c908                       cmp #$08 ; backspace
  1133  ea07 f01e                       beq .tmsConsoleBackspace
  1134                          
  1135  ea09 48                         pha
  1136  ea0a 2067e9                     jsr tmsSetPosConsole
  1137  ea0d 68                         pla
  1138  ea0e 8d107f2079e5               +tmsPut
  1139  ea14 2020e9                     jsr tmsIncPosConsole
  1140  ea17 ee2b7b                     inc TMS9918_CONSOLE_LINE_LEN
  1141                          
  1142                          .endConsoleOut
  1143  ea1a 28                         plp
  1144  ea1b ac2d7b                     ldy .TMS9918_REGY
  1145  ea1e ae2c7b                     ldx .TMS9918_REGX
  1146  ea21 60                         rts
  1147                          
  1148                          .tmsConsoleNewline
  1149  ea22 203cea                     jsr tmsConsoleNewline
  1150  ea25 80f3                       bra .endConsoleOut
  1151                          
  1152                          .tmsConsoleBackspace
  1153  ea27 2063ea                     jsr tmsConsoleBackspace
  1154  ea2a 80ee                       bra .endConsoleOut
  1155                          
  1156                          
  1157                          ; -----------------------------------------------------------------------------
  1158                          ; tmsConsolePrint: Print a null-terminated string (console mode)
  1159                          ; -----------------------------------------------------------------------------
  1160                          ; Inputs:
  1161                          ;  STR_ADDR: Contains address of null-terminated string
  1162                          ; Prerequisites:
  1163                          ;  TMS address already set using +tmsSetAddressWrite
  1164                          ; -----------------------------------------------------------------------------
  1165                          tmsConsolePrint:
  1166  ea2c a000               	ldy #0
  1167                          -
  1168  ea2e 2079e5             	+tmsWaitData
  1169  ea31 b132               	lda (STR_ADDR), y
  1170  ea33 f006               	beq +
  1171  ea35 20f5e9                     jsr tmsConsoleOut
  1172  ea38 c8                 	iny
  1173  ea39 d0f3               	bne -
  1174                          +
  1175  ea3b 60                 	rts
  1176                          
  1177                          ; -----------------------------------------------------------------------------
  1178                          ; tmsConsoleNewline: Output a newline to the console (scrolls if on last line)
  1179                          ; -----------------------------------------------------------------------------
  1180                          tmsConsoleNewline:
  1181  ea3c 2067e9                     jsr tmsSetPosConsole
  1182  ea3f a9208d107f2079e5           +tmsPut ' '
  1183  ea47 ad287b                     lda TMS9918_CONSOLE_X
  1184  ea4a d008                       bne +
  1185  ea4c ad2b7b                     lda TMS9918_CONSOLE_LINE_LEN
  1186  ea4f f003                       beq +
  1187  ea51 60                         rts
  1188  ea52 f000                       beq +
  1189                          +
  1190  ea54 ad2a7b                     lda TMS9918_CONSOLE_SIZE_X
  1191  ea57 8d287b                     sta TMS9918_CONSOLE_X
  1192  ea5a ce287b                     dec TMS9918_CONSOLE_X
  1193  ea5d 9c2b7b                     stz TMS9918_CONSOLE_LINE_LEN
  1194  ea60 4c20e9                     jmp tmsIncPosConsole
  1195                          
  1196                          
  1197                          ; -----------------------------------------------------------------------------
  1198                          ; tmsConsoleBackspace: Output a backspace to the console
  1199                          ; -----------------------------------------------------------------------------
  1200                          tmsConsoleBackspace:
  1201  ea63 2041e9                     jsr tmsDecPosConsole
  1202  ea66 a92020f5e9                 +tmsConsoleOut ' '
  1203  ea6b a9208d107f2079e5           +tmsPut ' '
  1204  ea73 ce2b7b                     dec TMS9918_CONSOLE_LINE_LEN
  1205  ea76 4c41e9                     jmp tmsDecPosConsole

; ******** Source: kernel.asm
   158                          
   159                          }
   160                          
   161                          !ifndef HBC56_DISABLE_SFXMAN {
   162                                  !src "sfx/sfxman.asm"
   163                          }
   164                          
   165                          !ifndef HBC56_DISABLE_LCD {
   166                                  !ifndef LCD_MODEL { LCD_MODEL = 12864 }
   167                                  !src "gfx/bitmap.asm"
   168                                  !src "lcd/lcd.asm"
   169                                  !src "gfx/tilemap.asm"
   170                          }
   171                          
   172                          !ifndef HBC56_DISABLE_UART {

; ******** Source: ../lib\ser\uart.asm
     1                          ; 6502 - MC68B50 UART
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          HAVE_UART = 1
    11                          
    12                          ; -------------------------
    13                          ; Constants
    14                          ; -------------------------
    15                          !ifndef UART_IO_PORT { UART_IO_PORT = $20
    16                                  !warn "UART_IO_PORT not provided. Defaulting to ", UART_IO_PORT
    17                          }
    18                          
    19                          !ifndef UART_ZP_START { UART_ZP_START = $40
    20                                  !warn "UART_ZP_START not provided. Defaulting to ", UART_ZP_START
    21                          }
    22                          
    23                          !ifndef UART_RAM_START { UART_RAM_START = $7c80
    24                                  !warn "UART_RAM_START not provided. Defaulting to ", UART_RAM_START
    25                          }
    26                          
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; Zero page
    30                          ; -----------------------------------------------------------------------------
    31                          UART_RX_BUFFER_HEAD  = UART_ZP_START            ; head of circular buffer
    32                          UART_RX_BUFFER_TAIL  = UART_ZP_START + 1        ; tail of circular buffer
    33                          UART_RX_BUFFER_BYTES = UART_ZP_START + 2        ; bytes in buffer
    34                          UART_RX_FLAGS        = UART_ZP_START + 3        ; flags
    35                          @UART_ZP_END         = UART_ZP_START + 4
    36                          
    37                          !if (.UART_ZP_SIZE < @UART_ZP_END - UART_ZP_START) {
    38                                  !error "UART ZP allocation insufficient. Allocated: ", .UART_ZP_SIZE, " Require: ", (@UART_ZP_END - UART_ZP_START)
    39                          }
    40                          
    41                          ; -----------------------------------------------------------------------------
    42                          ; High RAM
    43                          ; -----------------------------------------------------------------------------
    44                          UART_RX_BUFFER       = UART_RAM_START
    45                          UART_RX_BUFFER_SIZE  = $100
    46                          
    47                          @UART_RAM_END        = UART_RAM_START + UART_RX_BUFFER_SIZE
    48                          
    49                          !if (.UART_RAM_SIZE < @UART_RAM_END - UART_RAM_START) {
    50                                  !error "UART RAM allocation insufficient. Allocated: ", .UART_RAM_SIZE, " Require: ", (@UART_RAM_END - UART_RAM_START)
    51                          }
    52                          
    53                          
    54                          ; IO Ports
    55                          UART_REG      = IO_PORT_BASE_ADDRESS | UART_IO_PORT
    56                          UART_DATA     = IO_PORT_BASE_ADDRESS | UART_IO_PORT | $01
    57                          
    58                          ; -----------------------------------------------------------------------------
    59                          ; Constants
    60                          ; -----------------------------------------------------------------------------
    61                          UART_CTL_MASTER_RESET       = %00000011
    62                          UART_CTL_CLOCK_DIV_16       = %00000001
    63                          UART_CTL_CLOCK_DIV_64       = %00000010
    64                          UART_CTL_WORD_7BIT_EPB_2SB  = %00000000
    65                          UART_CTL_WORD_7BIT_OPB_2SB  = %00000100
    66                          UART_CTL_WORD_7BIT_EPB_1SB  = %00001000
    67                          UART_CTL_WORD_7BIT_OPB_1SB  = %00001100
    68                          UART_CTL_WORD_8BIT_2SB      = %00010000
    69                          UART_CTL_WORD_8BIT_1SB      = %00010100
    70                          UART_CTL_WORD_8BIT_EPAR_1SB = %00011000
    71                          UART_CTL_WORD_8BIT_OPAR_1SB = %00011100
    72                          UART_CTL_RX_INT_ENABLE      = %10000000
    73                          
    74                          UART_STATUS_RX_REG_FULL     = %00000001
    75                          UART_STATUS_TX_REG_EMPTY    = %00000010
    76                          UART_STATUS_CARRIER_DETECT  = %00000100
    77                          UART_STATUS_CLEAR_TO_SEND   = %00001000
    78                          UART_STATUS_FRAMING_ERROR   = %00010000
    79                          UART_STATUS_RCVR_OVERRUN    = %00100000
    80                          UART_STATUS_PARITY_ERROR    = %01000000
    81                          UART_STATUS_IRQ             = %10000000
    82                          
    83                          UART_FLOWCTRL_XON           = $11
    84                          UART_FLOWCTRL_XOFF          = $13
    85                          
    86                          UART_RX_BUFFER_XOFF_SIZE    = 192
    87                          UART_RX_BUFFER_XON_SIZE     = 4
    88                          
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; uartInit: Initialise the UART
    92                          ; -----------------------------------------------------------------------------
    93                          uartInit:
    94  ea79 a900                       lda #0
    95  ea7b 8528                       sta UART_RX_BUFFER_HEAD
    96  ea7d 8529                       sta UART_RX_BUFFER_TAIL
    97  ea7f 852a                       sta UART_RX_BUFFER_BYTES
    98  ea81 852b                       sta UART_RX_FLAGS
    99                          
   100  ea83 a903                       lda #UART_CTL_MASTER_RESET
   101  ea85 8d207f                     sta UART_REG
   102  ea88 ea                         nop
   103  ea89 ea                         nop
   104                          
   105  ea8a a992                       lda #(UART_CTL_CLOCK_DIV_64 | UART_CTL_WORD_8BIT_2SB | UART_CTL_RX_INT_ENABLE)
   106  ea8c 8d207f                     sta UART_REG
   107  ea8f ea                         nop
   108  ea90 ea                         nop
   109                          
   110  ea91 20b9ea                     jsr uartFlowCtrlXon
   111                          
   112  ea94 60                         rts
   113                          
   114                          ; -----------------------------------------------------------------------------
   115                          ; uartIrq: Standard UART IRQ handler
   116                          ; -----------------------------------------------------------------------------
   117                          uartIrq:
   118  ea95 a901                       lda #UART_STATUS_RX_REG_FULL
   119  ea97 2c207f                     bit UART_REG
   120  ea9a f01c                       beq @endFlowControlCheck
   121  ea9c ea                         nop
   122  ea9d ea                         nop
   123                          
   124  ea9e da                         phx
   125  ea9f a628                       ldx UART_RX_BUFFER_HEAD
   126  eaa1 ad217f                     lda UART_DATA
   127  eaa4 9d587b                     sta UART_RX_BUFFER, x
   128  eaa7 e628                       inc UART_RX_BUFFER_HEAD
   129  eaa9 e62a                       inc UART_RX_BUFFER_BYTES
   130  eaab fa                         plx
   131                          
   132                          @flowControlCheck
   133                                  ; check flow control
   134  eaac ff2b09                     bbs7 UART_RX_FLAGS, @endFlowControlCheck    ; if already xoff, just leave
   135  eaaf a9c0                       lda #UART_RX_BUFFER_XOFF_SIZE               ; otherwise, should we ask for xoff?
   136  eab1 c52a                       cmp UART_RX_BUFFER_BYTES
   137  eab3 b003                       bcs @endFlowControlCheck                    ; all good
   138  eab5 20c4ea                     jsr uartFlowCtrlXoff                        ; stop please.
   139                          
   140                          @endFlowControlCheck
   141  eab8 60                         rts
   142                          
   143                          ; -----------------------------------------------------------------------------
   144                          ; uartFlowCtrlXon: Allow client to send data
   145                          ; -----------------------------------------------------------------------------
   146                          uartFlowCtrlXon:
   147  eab9 772b                       rmb7 UART_RX_FLAGS        
   148  eabb a911                       lda #UART_FLOWCTRL_XON
   149  eabd ea                         nop
   150  eabe ea                         nop
   151  eabf ea                         nop
   152  eac0 ea                         nop
   153  eac1 4cfaea                     jmp uartOut
   154                          
   155                          ; -----------------------------------------------------------------------------
   156                          ; uartFlowCtrlXoff: Stop client to sending data
   157                          ; -----------------------------------------------------------------------------
   158                          uartFlowCtrlXoff
   159  eac4 f72b                       smb7 UART_RX_FLAGS
   160  eac6 a913                       lda #UART_FLOWCTRL_XOFF
   161  eac8 ea                         nop
   162  eac9 ea                         nop
   163  eaca 4c00eb                     jmp uartOutNoBsCheck
   164                          
   165                          ; -----------------------------------------------------------------------------
   166                          ; uartInWait: Input a byte from the UART (wait forever)
   167                          ; -----------------------------------------------------------------------------
   168                          ; Outputs:
   169                          ;   A: Value of the buffer
   170                          ; -----------------------------------------------------------------------------
   171                          uartInWait:
   172  eacd a528                       lda UART_RX_BUFFER_HEAD
   173  eacf c529                       cmp UART_RX_BUFFER_TAIL
   174  ead1 f0fa                       beq uartInWait
   175  ead3 08                         php
   176  ead4 78                         sei
   177  ead5 8008                       bra .uartIncheckFlowControl
   178                          
   179                          ; -----------------------------------------------------------------------------
   180                          ; uartInNoWait: Input a byte from the UART (don't wait)
   181                          ; -----------------------------------------------------------------------------
   182                          ; Outputs:
   183                          ;   A: Value of the buffer
   184                          ;   C: Set if a byte is read
   185                          ; -----------------------------------------------------------------------------
   186                          uartInNoWait:
   187  ead7 08                         php
   188  ead8 78                         sei
   189  ead9 a528                       lda UART_RX_BUFFER_HEAD
   190  eadb c529                       cmp UART_RX_BUFFER_TAIL
   191  eadd f018                       beq @noData
   192                          
   193                          .uartIncheckFlowControl
   194                                  ; check flow control
   195  eadf 7f2b09                     bbr7 UART_RX_FLAGS, @readUartValue  ; if already xon, just exit again
   196  eae2 a904                       lda #UART_RX_BUFFER_XON_SIZE        ; otherwise, should we ask for xon?
   197  eae4 c52a                       cmp UART_RX_BUFFER_BYTES
   198  eae6 9003                       bcc @readUartValue                  ; all good
   199  eae8 20b9ea                     jsr uartFlowCtrlXon                 ; continue sending please.
   200                          
   201                          @readUartValue
   202  eaeb a629                       ldx UART_RX_BUFFER_TAIL
   203  eaed bd587b                     lda UART_RX_BUFFER, x
   204  eaf0 e629                       inc UART_RX_BUFFER_TAIL
   205  eaf2 c62a                       dec UART_RX_BUFFER_BYTES
   206  eaf4 28                         plp
   207  eaf5 38                         sec
   208  eaf6 60                         rts
   209                          @noData
   210  eaf7 28                         plp
   211  eaf8 18                         clc
   212  eaf9 60                         rts
   213                          
   214                          
   215                          ; -----------------------------------------------------------------------------
   216                          ; uartOut: Output a byte to the UART
   217                          ; -----------------------------------------------------------------------------
   218                          ; Inputs:
   219                          ;   A: Value to output
   220                          ; -----------------------------------------------------------------------------
   221                          uartOut:
   222  eafa c908                       cmp #$08        ; bs
   223  eafc d002                       bne uartOutNoBsCheck
   224  eafe a97f                       lda #$7f        ; del
   225                          uartOutNoBsCheck:
   226  eb00 48                         pha
   227  eb01 a902                       lda #UART_STATUS_TX_REG_EMPTY
   228                          
   229                          @aciaTestSend
   230  eb03 2c207f                     bit UART_REG
   231  eb06 ea                         nop
   232  eb07 ea                         nop
   233  eb08 d002                       bne +
   234  eb0a 80f7                       bra @aciaTestSend
   235                          
   236                          +
   237  eb0c 68                         pla
   238  eb0d 8d217f                     sta UART_DATA
   239  eb10 60                         rts
   240                          
   241                          
   242                          ; -----------------------------------------------------------------------------
   243                          ; uartOutString: Output a string to the UART
   244                          ; -----------------------------------------------------------------------------
   245                          ; Inputs:
   246                          ;   A: Value to output
   247                          ; -----------------------------------------------------------------------------
   248                          uartOutString:
   249  eb11 a000               	ldy #0
   250                          -
   251  eb13 b132               	lda (STR_ADDR), y
   252  eb15 f006               	beq +
   253  eb17 2000eb                     jsr uartOutNoBsCheck
   254  eb1a c8                 	iny
   255  eb1b d0f6               	bne -
   256                          +
   257  eb1d 60                         rts

; ******** Source: kernel.asm
   173                          
   174                          }
   175                          
   176                          !ifndef HBC56_DISABLE_NES {

; ******** Source: ../lib\inp\nes.asm
     1                          ; 6502 NES Controllers - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          !ifndef NES_IO_PORT { NES_IO_PORT = $82
    12                                  !warn "NES_IO_PORT not provided. Defaulting to ", NES_IO_PORT
    13                          }
    14                          
    15                          !ifndef NES_RAM_START { NES_RAM_START = $7ea1
    16                                  !warn "NES_RAM_START not provided. Defaulting to ", NES_RAM_START
    17                          }
    18                          
    19                          ; -------------------------
    20                          ; High RAM
    21                          ; -------------------------
    22                          NES_TMP        = NES_RAM_START
    23                          NES_RAM_SIZE   = 1
    24                          
    25                          
    26                          !if NES_RAM_END < (NES_RAM_START + NES_RAM_SIZE) {
    27                          	!error "NES_RAM requires ",NES_RAM_SIZE," bytes. Allocated ",NES_RAM_END - NES_RAM_START
    28                          }
    29                          
    30                          
    31                          ; IO Ports
    32                          NES1_IO_ADDR     = IO_PORT_BASE_ADDRESS | NES_IO_PORT
    33                          NES2_IO_ADDR     = IO_PORT_BASE_ADDRESS | NES_IO_PORT | $01
    34                          
    35                          
    36                          NES_RIGHT       = %00000001
    37                          NES_LEFT        = %00000010
    38                          NES_DOWN        = %00000100
    39                          NES_UP          = %00001000
    40                          NES_START       = %00010000
    41                          NES_SELECT      = %00100000
    42                          NES_B           = %01000000
    43                          NES_A           = %10000000
    44                          
    45                          ; -----------------------------------------------------------------------------
    46                          ; nesWaitForPress: Wait for a NES button press (either port)
    47                          ; -----------------------------------------------------------------------------
    48                          nesWaitForPress:
    49  eb1e a9ff                       lda #$ff
    50                          @notPressed
    51  eb20 cd827f                     cmp NES1_IO_ADDR
    52  eb23 d005                       bne @pressed
    53  eb25 cd837f                     cmp NES2_IO_ADDR
    54  eb28 f0f6                       beq @notPressed
    55                          @pressed
    56  eb2a 60                         rts
    57                          
    58                          ; -----------------------------------------------------------------------------
    59                          ; nes1Pressed: Is a button pressed?
    60                          ; -----------------------------------------------------------------------------
    61                          ; Inputs:
    62                          ;   A: Button to test
    63                          ; Outputs:
    64                          ;   Carry set if pressed, Carry clear if not
    65                          nes1Pressed:
    66  eb2b 2c827f                     bit NES1_IO_ADDR
    67  eb2e 18                         clc
    68  eb2f d001                       bne +
    69  eb31 38                         sec
    70                          +
    71  eb32 60                         rts
    72                          
    73                          ; -----------------------------------------------------------------------------
    74                          ; nes2Pressed: Is a button pressed?
    75                          ; -----------------------------------------------------------------------------
    76                          ; Inputs:
    77                          ;   A: Button to test
    78                          ; Outputs:
    79                          ;   Carry set if pressed, Carry clear if not
    80                          nes2Pressed:
    81  eb33 2c837f                     bit NES2_IO_ADDR
    82  eb36 18                         clc
    83  eb37 d001                       bne +
    84  eb39 38                         sec
    85                          +
    86  eb3a 60                         rts
    87                          
    88                          
    89                          
    90                          

; ******** Source: kernel.asm
   177                          
   178                          }
   179                          
   180                          !ifndef HBC56_DISABLE_KEYBOARD {

; ******** Source: ../lib\inp\keyboard.asm
     1                          ; 6502 KB Controller - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github@com/visrealm/hbc-56
     8                          ;
     9                          
    10                          !ifndef HAVE_MATH_INC { !src "ut/math.inc" }
    11                          
    12                          HAVE_KEYBOARD = 1
    13                          
    14                          ; -------------------------
    15                          ; Constants
    16                          ; -------------------------
    17                          !ifndef KB_IO_PORT { KB_IO_PORT = $80
    18                                  !warn "KB_IO_PORT not provided@ Defaulting to ", KB_IO_PORT
    19                          }
    20                          
    21                          !ifndef KB_RAM_START { KB_RAM_START = $7ea1
    22                                  !warn "KB_RAM_START not provided@ Defaulting to ", KB_RAM_START
    23                          }
    24                          
    25                          ; -------------------------
    26                          ; High RAM
    27                          ; -------------------------
    28                          KB_FLAGS          = KB_RAM_START
    29                          KB_TMP_X          = KB_RAM_START + 1
    30                          KB_TMP_Y          = KB_RAM_START + 2
    31                          KB_CB_PRESSED     = KB_RAM_START + 3
    32                          KB_CB_RELEASED    = KB_RAM_START + 5
    33                          KB_CURRENT_STATE  = KB_RAM_START + 7
    34                          KB_BUFFER_HEAD    = KB_RAM_START + 8         ; head of circular buffer
    35                          KB_BUFFER_TAIL    = KB_RAM_START + 9         ; tail of circular buffer
    36                          KB_BUFFER         = KB_RAM_START + 10
    37                          KB_BUFFER_SIZE    = (1 << 4)
    38                          KB_BUFFER_MASK    = KB_BUFFER_SIZE - 1
    39                          KB_PRESSED_MAP    = KB_BUFFER + KB_BUFFER_SIZE
    40                          
    41                          KB_PRESSED_MAP_SIZE = $fd + 1
    42                          KB_PRESSED_MAP_BYTES = 32
    43                          
    44                          KB_RAM_SIZE     = (KB_PRESSED_MAP + KB_PRESSED_MAP_BYTES) - KB_RAM_START
    45                          
    46                          
    47                          !if KB_RAM_END < (KB_RAM_START + KB_RAM_SIZE) {
    48                          	!error "KB_RAM requires ",KB_RAM_SIZE," bytes@ Allocated ",KB_RAM_END - KB_RAM_START
    49                          }
    50                          
    51                          ; -------------------------
    52                          ; Contants
    53                          ; -------------------------
    54                          KB_SHIFT_DOWN   = %00000001
    55                          KB_CTRL_DOWN    = %00000010
    56                          KB_ALT_DOWN     = %00000100
    57                          KB_CAPS_LOCK    = %00001000
    58                          KB_NUM_LOCK     = %00010000
    59                          
    60                          KB_RELEASE      = $f0
    61                          KB_EXT_KEY      = $e0
    62                          KB_PAUSE_KEY    = $e1
    63                          
    64                          KB_SCANCODE_0 = $45
    65                          KB_SCANCODE_1 = $16
    66                          KB_SCANCODE_2 = $1E
    67                          KB_SCANCODE_3 = $26
    68                          KB_SCANCODE_4 = $25
    69                          KB_SCANCODE_5 = $2E
    70                          KB_SCANCODE_6 = $36
    71                          KB_SCANCODE_7 = $3D
    72                          KB_SCANCODE_8 = $3E
    73                          KB_SCANCODE_9 = $46
    74                          KB_SCANCODE_A = $1C
    75                          KB_SCANCODE_B = $32
    76                          KB_SCANCODE_C = $21
    77                          KB_SCANCODE_D = $23
    78                          KB_SCANCODE_E = $24
    79                          KB_SCANCODE_F = $2B
    80                          KB_SCANCODE_G = $34
    81                          KB_SCANCODE_H = $33
    82                          KB_SCANCODE_I = $43
    83                          KB_SCANCODE_J = $3B
    84                          KB_SCANCODE_K = $42
    85                          KB_SCANCODE_L = $4B
    86                          KB_SCANCODE_M = $3A
    87                          KB_SCANCODE_N = $31
    88                          KB_SCANCODE_O = $44
    89                          KB_SCANCODE_P = $4D
    90                          KB_SCANCODE_Q = $15
    91                          KB_SCANCODE_R = $2D
    92                          KB_SCANCODE_S = $1B
    93                          KB_SCANCODE_T = $2C
    94                          KB_SCANCODE_U = $3C
    95                          KB_SCANCODE_V = $2A
    96                          KB_SCANCODE_W = $1D
    97                          KB_SCANCODE_X = $22
    98                          KB_SCANCODE_Y = $35
    99                          KB_SCANCODE_Z = $1A
   100                          KB_SCANCODE_F1 = $05
   101                          KB_SCANCODE_F2 = $06
   102                          KB_SCANCODE_F3 = $04
   103                          KB_SCANCODE_F4 = $0C
   104                          KB_SCANCODE_F5 = $03
   105                          KB_SCANCODE_F6 = $0B
   106                          KB_SCANCODE_F7 = $83
   107                          KB_SCANCODE_F8 = $0A
   108                          KB_SCANCODE_F9 = $01
   109                          KB_SCANCODE_F10 = $09
   110                          KB_SCANCODE_F11 = $78
   111                          KB_SCANCODE_F12 = $07
   112                          KB_SCANCODE_NUMPAD_0 = $70
   113                          KB_SCANCODE_NUMPAD_1 = $69
   114                          KB_SCANCODE_NUMPAD_2 = $72
   115                          KB_SCANCODE_NUMPAD_3 = $7A
   116                          KB_SCANCODE_NUMPAD_4 = $6B
   117                          KB_SCANCODE_NUMPAD_5 = $73
   118                          KB_SCANCODE_NUMPAD_6 = $74
   119                          KB_SCANCODE_NUMPAD_7 = $6C
   120                          KB_SCANCODE_NUMPAD_8 = $75
   121                          KB_SCANCODE_NUMPAD_9 = $7D
   122                          KB_SCANCODE_NUMPAD_DIVIDE = $CA
   123                          KB_SCANCODE_NUMPAD_ENTER = $DA
   124                          KB_SCANCODE_NUMPAD_MINUS = $7B
   125                          KB_SCANCODE_NUMPAD_MULTIPLY = $7C
   126                          KB_SCANCODE_NUMPAD_PERIOD = $71
   127                          KB_SCANCODE_NUMPAD_PLUS = $79
   128                          KB_SCANCODE_NUM_LOCK = $77
   129                          KB_SCANCODE_ALT_LEFT = $11
   130                          KB_SCANCODE_ALT_RIGHT_ = $91
   131                          KB_SCANCODE_APOS = $52
   132                          KB_SCANCODE_ARROW_DOWN = $F2
   133                          KB_SCANCODE_ARROW_LEFT = $EB
   134                          KB_SCANCODE_ARROW_RIGHT = $F4
   135                          KB_SCANCODE_ARROW_UP = $F5
   136                          KB_SCANCODE_BACKSPACE = $66
   137                          KB_SCANCODE_CAPS_LOCK = $58
   138                          KB_SCANCODE_COMMA = $41
   139                          KB_SCANCODE_CTRL_LEFT = $14
   140                          KB_SCANCODE_CTRL_RIGHT = $94
   141                          KB_SCANCODE_DELETE = $F1
   142                          KB_SCANCODE_END = $E9
   143                          KB_SCANCODE_ENTER = $5A
   144                          KB_SCANCODE_EQUAL = $55
   145                          KB_SCANCODE_ESC = $76
   146                          KB_SCANCODE_HOME = $EC
   147                          KB_SCANCODE_INSERT = $F0
   148                          KB_SCANCODE_MENU = $AF
   149                          KB_SCANCODE_MINUS = $4E
   150                          KB_SCANCODE_PAGE_DOWN = $FA
   151                          KB_SCANCODE_PAGE_UP = $FD
   152                          KB_SCANCODE_PAUSE = $E1
   153                          KB_SCANCODE_PERIOD = $49
   154                          KB_SCANCODE_PRTSCR = $92
   155                          KB_SCANCODE_SCROLL_LOCK = $7E
   156                          KB_SCANCODE_SEMICOLON = $4C
   157                          KB_SCANCODE_SHIFT_LEFT = $12
   158                          KB_SCANCODE_SHIFT_RIGHT = $59
   159                          KB_SCANCODE_SLASH_BACK = $5D
   160                          KB_SCANCODE_SLASH_FORWARD = $4A
   161                          KB_SCANCODE_SPACEBAR = $29
   162                          KB_SCANCODE_SQUARE_LEFT = $54
   163                          KB_SCANCODE_SQUARE_RIGHT = $5B
   164                          KB_SCANCODE_TAB = $0D
   165                          KB_SCANCODE_TILDE = $0E
   166                          KB_SCANCODE_WINDOWS_LEFT = $9F
   167                          KB_SCANCODE_WINDOWS_RIGHT = $A7
   168                          
   169                          
   170                          KB_SHIFT_LEFT_MAP_BYTE = KB_SCANCODE_SHIFT_LEFT >> 3
   171                          KB_SHIFT_LEFT_MAP_BIT  = $80 >> (KB_SCANCODE_SHIFT_LEFT & $07)
   172                          
   173                          KB_SHIFT_RIGHT_MAP_BYTE = KB_SCANCODE_SHIFT_RIGHT >> 3
   174                          KB_SHIFT_RIGHT_MAP_BIT  = $80 >> (KB_SCANCODE_SHIFT_RIGHT & $07)
   175                          
   176                          
   177                          ; IO Ports
   178                          KB_IO_ADDR         = IO_PORT_BASE_ADDRESS | KB_IO_PORT
   179                          KB_STATUS_ADDR     = IO_PORT_BASE_ADDRESS | KB_IO_PORT | $01
   180                          
   181                          ; -----------------------------------------------------------------------------
   182                          ; kbInit: Initialise the keyboard
   183                          ; -----------------------------------------------------------------------------
   184                          kbInit:
   185  eb3b a900                       lda #$00
   186  eb3d 8d5c7c                     sta KB_FLAGS
   187                          
   188  eb40 a210                       ldx #16 ;buffer size
   189                                  
   190                                  ; ensure the hardware keyboard buffer is clear
   191                          -
   192  eb42 8e5d7c                     stx KB_TMP_X
   193  eb45 20f6eb                     jsr .kbReadByte
   194  eb48 ae5d7c                     ldx KB_TMP_X
   195  eb4b ca                         dex
   196  eb4c d0f4                       bne -
   197                          
   198  eb4e a220a900ca9d767c...        +memset KB_PRESSED_MAP, 0, KB_PRESSED_MAP_BYTES
   199                          
   200  eb5a 9c647c                     stz KB_BUFFER_HEAD
   201  eb5d 9c657c                     stz KB_BUFFER_TAIL
   202                          
   203  eb60 a900                       lda #.KB_STATE_DEFAULT
   204  eb62 8d637c                     sta KB_CURRENT_STATE
   205                          
   206                                  ; flow through
   207                          
   208                          kbResetCallbacks:
   209  eb65 a975                       lda #<.kbDummyCb
   210  eb67 8d5f7c                     sta KB_CB_PRESSED
   211  eb6a 8d617c                     sta KB_CB_RELEASED
   212                                  
   213  eb6d a9eb                       lda #>.kbDummyCb
   214  eb6f 8d607c                     sta KB_CB_PRESSED + 1
   215  eb72 8d627c                     sta KB_CB_RELEASED + 1
   216                          
   217                                  ; flow through
   218                          
   219                          .kbDummyCb:
   220  eb75 60                         rts
   221                          
   222                          ; -----------------------------------------------------------------------------
   223                          ; kbIntHandler: Standard keyboard interrupt handler
   224                          ; -----------------------------------------------------------------------------
   225                          kbIntHandler:
   226  eb76 20f6eb                     jsr .kbReadByte
   227  eb79 e000                       cpx #0
   228  eb7b f0f8                       beq .kbDummyCb
   229                          
   230  eb7d 8a                         txa     ; acc now holds scancode
   231                          
   232  eb7e ae637c                     ldx KB_CURRENT_STATE
   233                          
   234  eb81 7c84eb                     jmp (.kbStateHandlers, x)
   235                          
   236                          .KB_STATE_DEFAULT          = 0
   237                          .KB_STATE_RELEASE          = 2
   238                          .KB_STATE_EXTENDED         = 4
   239                          .KB_STATE_EXTENDED_RELEASE = 6
   240                          .KB_STATE_PAUSE_SEQ        = 8
   241                          
   242                          .kbStateHandlers:
   243  eb84 8eebb4ebc1ebb2eb...!word .stdKeyHandler, .relKeyHandler, .extKeyHandler, .extRelKeyHandler, .pauseKeyHandler
   244                          
   245                          ; default scancode handler
   246                          .stdKeyHandler
   247  eb8e c9f0                       cmp #KB_RELEASE
   248  eb90 d006                       bne +
   249  eb92 a902                       lda #.KB_STATE_RELEASE
   250  eb94 8d637c                     sta KB_CURRENT_STATE
   251  eb97 60                         rts
   252                          +
   253  eb98 c9e0                       cmp #KB_EXT_KEY
   254  eb9a d006                       bne +
   255  eb9c a904                       lda #.KB_STATE_EXTENDED
   256  eb9e 8d637c                     sta KB_CURRENT_STATE
   257  eba1 60                         rts
   258                          +
   259  eba2 c9e1                       cmp #KB_PAUSE_KEY
   260  eba4 d006                       bne +
   261  eba6 a908                       lda #.KB_STATE_PAUSE_SEQ
   262  eba8 8d637c                     sta KB_CURRENT_STATE
   263  ebab 60                         rts
   264                          +
   265                                  ; a regular key was pressed 
   266                                  ; TODO: bit field rather than a byte per key?
   267  ebac 2008ec                     jsr .kbSetKey
   268                          
   269  ebaf 6c5f7c                     jmp (KB_CB_PRESSED)
   270                                  ; subroutine returns above
   271                          
   272                          ; extended release scancode handler
   273                          .extRelKeyHandler:
   274  ebb2 0980                       ora #$80
   275                                  ; flow through
   276                          
   277                          ;  release scancode handler
   278                          .relKeyHandler:
   279  ebb4 aa                         tax
   280  ebb5 203dec                     jsr .kbClearKey
   281                          
   282  ebb8 a900                       lda #.KB_STATE_DEFAULT
   283  ebba 8d637c                     sta KB_CURRENT_STATE
   284  ebbd 8a                         txa
   285                          
   286  ebbe 6c617c                     jmp (KB_CB_RELEASED)
   287                          
   288                          ; extended scancode handler
   289                          .extKeyHandler:
   290  ebc1 c9f0                       cmp #KB_RELEASE
   291  ebc3 d006                       bne +
   292  ebc5 a906                       lda #.KB_STATE_EXTENDED_RELEASE
   293  ebc7 8d637c                     sta KB_CURRENT_STATE
   294  ebca 60                         rts
   295                          +
   296  ebcb 0980                       ora #$80
   297                                  
   298  ebcd 2008ec                     jsr .kbSetKey
   299                          
   300  ebd0 a900                       lda #.KB_STATE_DEFAULT
   301  ebd2 8d637c                     sta KB_CURRENT_STATE
   302  ebd5 8a                         txa
   303                          
   304  ebd6 6c5f7c                     jmp (KB_CB_PRESSED)
   305                          
   306                          ; pause/break sequence scancode handler
   307                          .pauseKeyHandler:
   308  ebd9 c977                       cmp #$77
   309  ebdb d018                       bne @notLastByte
   310  ebdd aa                         tax
   311  ebde ad577d                     lda KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   312  ebe1 d006                       bne +
   313  ebe3 8e577d                     stx KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   314  ebe6 6c5f7c                     jmp (KB_CB_PRESSED)
   315                          +
   316  ebe9 9c577d                     stz KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   317                          
   318  ebec a900                       lda #.KB_STATE_DEFAULT
   319  ebee 8d637c                     sta KB_CURRENT_STATE
   320  ebf1 8a                         txa
   321                          
   322  ebf2 6c617c                     jmp (KB_CB_RELEASED)
   323                          
   324                          @notLastByte
   325  ebf5 60                         rts
   326                          
   327                          ; -----------------------------------------------------------------------------
   328                          ; Outputs:
   329                          ;   A: Value of the KB Status (0 if no key)
   330                          ;   X: PS/2 Scancode byte
   331                          ; -----------------------------------------------------------------------------
   332                          .kbReadByte:        
   333  ebf6 a200                       ldx #0
   334  ebf8 a904                       lda #$04
   335  ebfa 2c817f                     bit KB_STATUS_ADDR
   336  ebfd f008                       beq @end
   337                          
   338  ebff a020                       ldy #32         ; TODO: this could probably be smaller
   339                          -
   340  ec01 88                 	dey
   341  ec02 d0fd               	bne -
   342                          
   343  ec04 ae807f                     ldx KB_IO_ADDR
   344                          @end
   345  ec07 60                         rts
   346                          
   347                          
   348                          ; -----------------------------------------------------------------------------
   349                          ; .kbSetKey: Set a key is pressed in KB_PRESSED_MAP
   350                          ; Inputs:
   351                          ;    A - scancode
   352                          ; -----------------------------------------------------------------------------
   353                          .kbSetKey:
   354  ec08 ae647c                     ldx KB_BUFFER_HEAD      ; store at head of buffer
   355  ec0b 9d667c                     sta KB_BUFFER, x
   356                          
   357  ec0e 8d5d7c                     sta KB_TMP_X            ; find byte in map
   358  ec11 4a4a4a                     +lsr3
   359  ec14 aa                         tax
   360  ec15 ad5d7c                     lda KB_TMP_X
   361  ec18 2907                       and #$07
   362  ec1a a8                         tay
   363  ec1b bd767c                     lda KB_PRESSED_MAP, x
   364  ec1e 1930e1                     ora tableBitFromLeft, y ; set bit in map byte
   365  ec21 9d767c                     sta KB_PRESSED_MAP, x   ; update map
   366                          
   367                                  ; check for toggle keys
   368  ec24 ae5d7c                     ldx KB_TMP_X
   369  ec27 e058                       cpx #KB_SCANCODE_CAPS_LOCK
   370  ec29 d008                       bne +
   371  ec2b a908                       lda #KB_CAPS_LOCK
   372  ec2d 4d5c7c                     eor KB_FLAGS
   373  ec30 8d5c7c                     sta KB_FLAGS
   374                          +
   375                          
   376  ec33 ad647c                     lda KB_BUFFER_HEAD      ; increment (and mask) buffer head
   377  ec36 1a                         inc
   378  ec37 290f                       and #KB_BUFFER_MASK
   379  ec39 8d647c                     sta KB_BUFFER_HEAD
   380  ec3c 60                         rts
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; .kbClearKey: Clear a key is pressed in KB_PRESSED_MAP
   384                          ; Inputs:
   385                          ;    A - scancode
   386                          ; -----------------------------------------------------------------------------
   387                          .kbClearKey:
   388  ec3d 8d5d7c                     sta KB_TMP_X
   389  ec40 4a4a4a                     +lsr3
   390  ec43 aa                         tax
   391  ec44 ad5d7c                     lda KB_TMP_X
   392  ec47 2907                       and #$07
   393  ec49 a8                         tay
   394  ec4a bd767c                     lda KB_PRESSED_MAP, x
   395  ec4d 3938e1                     and tableInvBitFromLeft, y
   396  ec50 9d767c                     sta KB_PRESSED_MAP, x
   397  ec53 60                         rts
   398                          
   399                          
   400                          ; -----------------------------------------------------------------------------
   401                          ; .kbPopTail: Pop a scancode from the tail of the buffer
   402                          ; Inputs:
   403                          ;    A - scancode
   404                          ; -----------------------------------------------------------------------------
   405                          .kbPopTail:
   406  ec54 ad657c                     lda KB_BUFFER_TAIL
   407  ec57 aa                         tax
   408  ec58 1a                         inc
   409  ec59 290f                       and #KB_BUFFER_MASK
   410  ec5b 8d657c                     sta KB_BUFFER_TAIL
   411  ec5e bd667c                     lda KB_BUFFER, x
   412  ec61 60                         rts
   413                          
   414                          ; -----------------------------------------------------------------------------
   415                          ; kbIsPressed: Is a key pressed right now?
   416                          ; Inputs:
   417                          ;    X - scancode
   418                          ; Returns:
   419                          ;    Z - clear if pressed, set if not pressed
   420                          ; -----------------------------------------------------------------------------
   421                          kbIsPressed:
   422  ec62 08                         php
   423  ec63 78                         sei
   424  ec64 8e5d7c                     stx KB_TMP_X
   425  ec67 8a                         txa
   426  ec68 4a4a4a                     +lsr3
   427  ec6b aa                         tax
   428  ec6c ad5d7c                     lda KB_TMP_X
   429  ec6f 2907                       and #$07
   430  ec71 a8                         tay
   431  ec72 b930e1                     lda tableBitFromLeft, y
   432  ec75 3d767c                     and KB_PRESSED_MAP, x
   433  ec78 ae5d7c                     ldx KB_TMP_X
   434  ec7b 28                         plp
   435  ec7c c900                       cmp #0
   436  ec7e 60                         rts
   437                          
   438                          
   439                          ; -----------------------------------------------------------------------------
   440                          ; kbWaitForScancode: Wait for a key press
   441                          ; Returns:
   442                          ;    A - scancode
   443                          ; -----------------------------------------------------------------------------
   444                          kbWaitForScancode:
   445  ec7f 08                         php
   446  ec80 78                         sei        
   447  ec81 38                         sec
   448  ec82 ad647c                     lda KB_BUFFER_HEAD
   449  ec85 ed657c                     sbc KB_BUFFER_TAIL
   450  ec88 28                         plp
   451  ec89 c900                       cmp #0
   452  ec8b f0f2                       beq kbWaitForScancode
   453  ec8d 08                         php
   454  ec8e 78                         sei
   455  ec8f 2054ec                     jsr .kbPopTail
   456  ec92 28                         plp
   457  ec93 60                         rts
   458                          
   459                          ; -----------------------------------------------------------------------------
   460                          ; kbNextScancode: Return the next scancode in the buffer or zero if empty
   461                          ; Returns:
   462                          ;    A - scancode (or zero)
   463                          ; -----------------------------------------------------------------------------
   464                          kbNextScancode:
   465  ec94 08                         php
   466  ec95 78                         sei
   467  ec96 ad647c                     lda KB_BUFFER_HEAD
   468  ec99 cd657c                     cmp KB_BUFFER_TAIL
   469  ec9c f007                       beq @noScancode
   470  ec9e 2054ec                     jsr .kbPopTail
   471  eca1 28                         plp
   472  eca2 c900                       cmp #0
   473  eca4 60                         rts
   474                          
   475                          @noScancode
   476  eca5 28                         plp
   477  eca6 a900                       lda #0
   478  eca8 60                         rts
   479                          
   480                          ; -----------------------------------------------------------------------------
   481                          ; kbScancodeToAscii: Convert a scancode to ascii. shift/caps lock is honoured
   482                          ; Inputs:
   483                          ;    A - scancode (or zero)
   484                          ; Returns:
   485                          ;    A - ascii character
   486                          ;    C - set if valid character in A
   487                          ; -----------------------------------------------------------------------------
   488                          kbScancodeToAscii:
   489  eca9 da                         phx
   490  ecaa 8d5d7c                     sta KB_TMP_X
   491  ecad 18                         clc
   492  ecae 1002                       bpl +
   493  ecb0 fa                         plx
   494  ecb1 60                         rts
   495                          +
   496  ecb2 08                         php
   497  ecb3 78                         sei
   498  ecb4 a202                       ldx #KB_SHIFT_LEFT_MAP_BYTE
   499  ecb6 a920                       lda #KB_SHIFT_LEFT_MAP_BIT
   500  ecb8 3c767c                     bit KB_PRESSED_MAP, x
   501  ecbb f003                       beq +
   502  ecbd 38                         sec
   503  ecbe 800a                       bra @doneShiftCheck
   504                          +
   505                          
   506  ecc0 a20b                       ldx #KB_SHIFT_RIGHT_MAP_BYTE
   507  ecc2 a940                       lda #KB_SHIFT_RIGHT_MAP_BIT
   508  ecc4 3c767c                     bit KB_PRESSED_MAP, x
   509  ecc7 f001                       beq +
   510  ecc9 38                         sec
   511                          +
   512                          
   513                          @doneShiftCheck:
   514  ecca b008                       bcs @shiftedKeys:
   515  eccc ae5d7c                     ldx KB_TMP_X
   516  eccf bd0ded                     lda KEY_MAP, x
   517  ecd2 8006                       bra @end
   518                          
   519                          @shiftedKeys:
   520  ecd4 ae5d7c                     ldx KB_TMP_X
   521  ecd7 bd8ded                     lda KEY_MAP_SHIFTED, x
   522                          
   523                          @end
   524  ecda 2018e0                     jsr isAlpha
   525  ecdd 9014                       bcc @afterAlphaCheck
   526  ecdf 8d5d7c                     sta KB_TMP_X
   527  ece2 a908                       lda #KB_CAPS_LOCK
   528  ece4 2d5c7c                     and KB_FLAGS
   529  ece7 f007                       beq +
   530  ece9 ad5d7c                     lda KB_TMP_X
   531  ecec 4920                       eor #$20
   532  ecee 8003                       bra @afterAlphaCheck
   533                          +
   534  ecf0 ad5d7c                     lda KB_TMP_X
   535                          @afterAlphaCheck
   536  ecf3 28                         plp
   537  ecf4 fa                         plx
   538  ecf5 c9ff                       cmp #$ff
   539  ecf7 38                         sec
   540  ecf8 d001                       bne +
   541  ecfa 18                         clc
   542                          +        
   543  ecfb 60                         rts
   544                          
   545                          ; -----------------------------------------------------------------------------
   546                          ; kbReadAscii: Read an ASCII caharacter from the keyboard queue
   547                          ; Returns:
   548                          ;    A - ascii character
   549                          ;    C - set if valid character in A
   550                          ; -----------------------------------------------------------------------------
   551                          kbReadAscii:
   552  ecfc 08                         php
   553  ecfd 78                         sei
   554  ecfe da                         phx
   555  ecff 2094ec                     jsr kbNextScancode
   556  ed02 f005                       beq @noKey
   557  ed04 fa                         plx
   558  ed05 28                         plp
   559  ed06 4ca9ec                     jmp kbScancodeToAscii
   560                          @noKey
   561  ed09 fa                         plx
   562  ed0a 28                         plp
   563  ed0b 18                         clc
   564  ed0c 60                         rts
   565                          
   566                          
   567                          KEY_MAP:
   568                          ;      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
   569  ed0d ffffffffffffffff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$09,$60,$ff; 0
   570  ed1d ffffffffff7131ff...!byte $ff,$ff,$ff,$ff,$ff,$71,$31,$ff,$ff,$ff,$7a,$73,$61,$77,$32,$ff; 1
   571  ed2d ff637864653433ff...!byte $ff,$63,$78,$64,$65,$34,$33,$ff,$ff,$20,$76,$66,$74,$72,$35,$ff; 2
   572  ed3d ff6e6268677936ff...!byte $ff,$6e,$62,$68,$67,$79,$36,$ff,$ff,$ff,$6d,$6a,$75,$37,$38,$ff; 3
   573  ed4d ff2c6b696f3039ff...!byte $ff,$2c,$6b,$69,$6f,$30,$39,$ff,$ff,$2e,$2f,$6c,$3b,$70,$2d,$ff; 4
   574  ed5d ffff27ff5b3dffff...!byte $ff,$ff,$27,$ff,$5b,$3d,$ff,$ff,$ff,$ff,$0d,$5d,$ff,$5c,$ff,$ff; 5
   575  ed6d ffffffffffff08ff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$08,$ff,$ff,$31,$ff,$34,$37,$ff,$ff,$ff; 6
   576  ed7d 30ff323536381bff...!byte $30,$ff,$32,$35,$36,$38,$1b,$ff,$ff,$ff,$33,$2d,$ff,$39,$ff,$ff; 7
   577                          
   578                          KEY_MAP_SHIFTED:
   579                          ;      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
   580  ed8d ffffffffffffffff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$09,$7e,$ff; 0
   581  ed9d ffffffffff5121ff...!byte $ff,$ff,$ff,$ff,$ff,$51,$21,$ff,$ff,$ff,$5a,$53,$41,$57,$40,$ff; 1
   582  edad ff435844452423ff...!byte $ff,$43,$58,$44,$45,$24,$23,$ff,$ff,$20,$56,$46,$54,$52,$25,$ff; 2
   583  edbd ff4e424847595eff...!byte $ff,$4e,$42,$48,$47,$59,$5e,$ff,$ff,$ff,$4d,$4a,$55,$26,$2a,$ff; 3
   584  edcd ff3c4b494f2928ff...!byte $ff,$3c,$4b,$49,$4f,$29,$28,$ff,$ff,$3e,$3f,$4c,$3a,$50,$5f,$ff; 4
   585  eddd ffff22ff7b2bffff...!byte $ff,$ff,$22,$ff,$7b,$2b,$ff,$ff,$ff,$ff,$0d,$7d,$ff,$7c,$ff,$ff; 5
   586  eded ffffffffffff08ff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$08,$ff,$ff,$31,$ff,$34,$37,$ff,$ff,$ff; 6
   587  edfd 30ff323536381bff...!byte $30,$ff,$32,$35,$36,$38,$1b,$ff,$ff,$ff,$33,$2d,$ff,$39,$ff,$ff; 7

; ******** Source: kernel.asm
   181                          
   182                          }
   183                          

; ******** Source: ../lib\io\via.asm
     1                          ; 65(C)22 VIA - HBC-56
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          !ifndef VIA_IO_PORT { VIA_IO_PORT = $f0
    12                                  !warn "VIA_IO_PORT not provided. Defaulting to ", VIA_IO_PORT
    13                          }
    14                          
    15                          !ifndef VIA_RAM_START { VIA_RAM_START = $7d80
    16                                  !warn "VIA_RAM_START not provided. Defaulting to ", VIA_RAM_START
    17                          }
    18                          
    19                          ; -------------------------
    20                          ; High RAM
    21                          ; -------------------------
    22                          VIA_TMP        = VIA_RAM_START
    23                          VIA_RAM_SIZE   = 1
    24                          
    25                          
    26                          !if VIA_RAM_END < (VIA_RAM_START + VIA_RAM_SIZE) {
    27                          	!error "VIA_RAM requires ",VIA_RAM_SIZE," bytes. Allocated ",VIA_RAM_END - VIA_RAM_START
    28                          }
    29                          
    30                          
    31                          VIA_REG_PORT_B  = $00
    32                          VIA_REG_PORT_A  = $01
    33                          VIA_REG_DDR_B   = $02
    34                          VIA_REG_DDR_A   = $03
    35                          VIA_REG_T1C_L   = $04
    36                          VIA_REG_T1C_H   = $05
    37                          VIA_REG_T1L_L   = $06
    38                          VIA_REG_T1L_H   = $07
    39                          VIA_REG_T2C_L   = $08
    40                          VIA_REG_T2C_H   = $09
    41                          VIA_REG_ACR     = $0b
    42                          VIA_REG_IFR     = $0d
    43                          VIA_REG_IER     = $0e
    44                          
    45                          ; IO Ports
    46                          VIA_IO_ADDR     = IO_PORT_BASE_ADDRESS | VIA_IO_PORT
    47                          
    48                          VIA_IO_ADDR_PORT_B      = VIA_IO_ADDR | VIA_REG_PORT_B
    49                          VIA_IO_ADDR_PORT_A      = VIA_IO_ADDR | VIA_REG_PORT_A
    50                          VIA_IO_ADDR_DDR_B       = VIA_IO_ADDR | VIA_REG_DDR_B
    51                          VIA_IO_ADDR_DDR_A       = VIA_IO_ADDR | VIA_REG_DDR_A
    52                          VIA_IO_ADDR_T1C_L       = VIA_IO_ADDR | VIA_REG_T1C_L
    53                          VIA_IO_ADDR_T1C_H       = VIA_IO_ADDR | VIA_REG_T1C_H
    54                          VIA_IO_ADDR_T1L_L       = VIA_IO_ADDR | VIA_REG_T1L_L
    55                          VIA_IO_ADDR_T1L_H       = VIA_IO_ADDR | VIA_REG_T1L_H
    56                          VIA_IO_ADDR_T2C_L       = VIA_IO_ADDR | VIA_REG_T2C_L
    57                          VIA_IO_ADDR_T2C_H       = VIA_IO_ADDR | VIA_REG_T2C_H
    58                          VIA_IO_ADDR_ACR         = VIA_IO_ADDR | VIA_REG_ACR
    59                          VIA_IO_ADDR_IFR         = VIA_IO_ADDR | VIA_REG_IFR
    60                          VIA_IO_ADDR_IER         = VIA_IO_ADDR | VIA_REG_IER
    61                          
    62                          ; Constants
    63                          VIA_DIR_INPUT   = $00
    64                          VIA_DIR_OUTPUT  = $ff
    65                          
    66                          
    67                          
    68                          viaIntHandler:
    69  ee0d 6cbb7c                     jmp (HBC56_VIA_CALLBACK)

; ******** Source: kernel.asm
   184                          
   185                          
   186  ee10 6769746875622e63...+hbc56Title "github.com/visrealm/hbc-56"
   187                          

; ******** Source: bootscreen.asm
     1                          ; 6502 - HBC-56 - Memory tests
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; can be anywhere. we own the place at this stage
    12                          LOGO_BUFFER = $3000     
    13                          
    14                          !ifdef HAVE_TMS9918 {
    15                                  HBC56_BORDER     = TMS_DK_BLUE 
    16                                  HBC56_BACKGROUND = TMS_WHITE
    17                                  HBC56_LOGO       = TMS_DK_BLUE 
    18                                  HBC56_TEXT       = TMS_DK_BLUE
    19                          }
    20                          
    21                          !ifdef HBC56_TITLE_TEXT {
    22                                  HBC56_TITLE     = HBC56_TITLE_TEXT
    23                                  HBC56_TITLE_LEN = HBC56_TITLE_TEXT_LEN
    24                          }
    25                          
    26                          .HBC56_PRESS_ANY_KEY_TEXT:
    27  ee2b 505245535320414e...        !text "PRESS ANY KEY...",0
    28                          .HBC56_PRESS_ANY_KEY_TEXT_LEN = *-.HBC56_PRESS_ANY_KEY_TEXT-1
    29                          
    30                          .HBC56_PRESS_ANY_NES_TEXT:
    31  ee3c 5052455353204120...        !text "PRESS A TO BEGIN...",0
    32                          .HBC56_PRESS_ANY_NES_TEXT_LEN = *-.HBC56_PRESS_ANY_NES_TEXT-1
    33                          
    34                          !ifdef HAVE_GRAPHICS_LCD {
    35                                  !align 255, 0
    36                          hbc56FontLcd:
    37                                  !bin "lcd/fonts/c64-alnum.bin"
    38                          hbc56LogoLcd:
    39                                  !bin "res/hbc56lcd.bin"
    40                          }
    41                          
    42                          !ifdef HAVE_TMS9918 {
    43                          hbc56LogoInd:
    44  ee50 c8c9cacbcccdcecf...        !bin "res/hbc56boot.ind"
    45                          hbc56LogoPatt:
    46  ee92 fefefefefefefefe...        !bin "res/hbc56boot.patt"
    47                          hbc56LogoPattEnd:        
    48                          }
    49                          
    50                          hbc56BootScreen:
    51                          
    52                          !ifdef HAVE_TMS9918 {
    53  f00a 0878a9108d117f20...        +tmsSetAddrColorTable 16
    54  f01d a94f                       +tmsColorFgBg HBC56_LOGO, HBC56_BACKGROUND
    55  f01f a202                       ldx #2
    56  f021 2026e7                     jsr _tmsSendX8
    57  f024 a94f                       +tmsColorFgBg HBC56_TEXT, HBC56_BACKGROUND
    58  f026 a210                       ldx #16
    59  f028 20d3e7                     jsr tmsInitColorTable
    60                          
    61  f02b 0878a9a58d117f20...        +tmsSetPosWrite 5,5
    62  f03e a9508524a9ee8525...        +tmsSendData hbc56LogoInd, 22
    63  f04b 0878a9c58d117f20...        +tmsSetPosWrite 5,6
    64  f05e a9668524a9ee8525...        +tmsSendData hbc56LogoInd + 22, 22
    65  f06b 0878a9e58d117f20...        +tmsSetPosWrite 5,7
    66  f07e a97c8524a9ee8525...        +tmsSendData hbc56LogoInd + 44, 22
    67                          
    68  f08b 0878a9408d117f20...        +tmsSetAddrPattTable 200
    69  f09e a9928524a9ee8525...        +tmsSendData hbc56LogoPatt, $178
    70                          
    71  f0b4 0878a9c88d117f20...        +tmsPrintZ HBC56_META_TITLE, 8, 14
    72                          
    73                          
    74                                  !ifdef HBC56_TITLE_TEXT {
    75  f0d2 0878a9c38d117f20...                +tmsPrintZ HBC56_TITLE, (32 - HBC56_TITLE_LEN) / 2, 22
    76                                  }
    77                          
    78  f0f0 a9e4                       +tmsColorFgBg TMS_GREY, HBC56_BORDER
    79  f0f2 20cfe5                     jsr tmsSetBackground
    80                          }
    81                          
    82                          !ifdef HAVE_LCD {
    83                                  jsr lcdDetect
    84                                  bcc @noLcd
    85                                  !ifdef HAVE_GRAPHICS_LCD {
    86                                          jsr lcdGraphicsMode
    87                                          +memset LOGO_BUFFER, $00, 1024
    88                                          +memcpy LOGO_BUFFER + 128, hbc56LogoLcd, 256
    89                                          lda #>LOGO_BUFFER
    90                                          sta BITMAP_ADDR_H
    91                                          jsr lcdImage
    92                          
    93                                          +memset LOGO_BUFFER, $0, 128
    94                                          +tilemapCreateDefault (TILEMAP_SIZE_X_16 | TILEMAP_SIZE_Y_8), hbc56FontLcd-(32*8)
    95                                          +memset TILEMAP_DEFAULT_BUFFER_ADDRESS, ' ', 128
    96                          
    97                                          +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*4, HBC56_META_TITLE, 16
    98                          
    99                                          ldy #4
   100                                          jsr tilemapRenderRowToLcd
   101                          
   102                                  } else {
   103                                          !if LCD_ROWS > 2 { +lcdPrint "\n" }
   104                                          !if LCD_COLUMNS > 16 { +lcdPrint "  " }
   105                                          +lcdPrint "     HBC-56\n"
   106                                          !if LCD_COLUMNS > 16 { +lcdPrint "  " }
   107                                          lda #<HBC56_META_TITLE
   108                                          sta STR_ADDR_L
   109                                          lda #>HBC56_META_TITLE
   110                                          sta STR_ADDR_H
   111                                          !if LCD_ROWS = 2 {
   112                                                  jsr lcdLineTwo
   113                                          }                
   114                                          jsr lcdPrint
   115                                          !if LCD_ROWS = 2 {
   116                                                  jsr lcdLineTwo
   117                                          } else {
   118                                                  jsr lcdLineThree
   119                                          }                
   120                                          !if LCD_COLUMNS > 16 { +lcdConsolePrint "  " }
   121                                  }
   122                          @noLcd:
   123                          }
   124  f0f5 60                         rts

; ******** Source: kernel.asm
   188                          

; ******** Source: kernel.inc
     1                          ; 6502 - HBC-56 Kernel Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !macro setIntHandler .address {
    12                                  lda #<.address
    13                                  sta HBC56_INT_VECTOR + 1
    14                                  lda #>.address
    15                                  sta HBC56_INT_VECTOR + 2
    16                                  lda #JMP_OPCODE
    17                                  sta HBC56_INT_VECTOR
    18                          }
    19                          
    20                          !macro setNmiHandler .address {
    21                                  lda #<.address
    22                                  sta HBC56_NMI_VECTOR + 1
    23                                  lda #>.address
    24                                  sta HBC56_NMI_VECTOR + 2
    25                                  lda #JMP_OPCODE
    26                                  sta HBC56_NMI_VECTOR
    27                          }
    28                          
    29                          !macro setHbcMetaNES {
    30                                  lda #HBC56_CONSOLE_FLAG_NES
    31                                  ora HBC56_CONSOLE_FLAGS
    32                                  sta HBC56_CONSOLE_FLAGS
    33                          }
    34                          
    35                          !macro setHbcMetaNoWait {
    36                                  lda #HBC56_CONSOLE_FLAG_NOWAIT
    37                                  ora HBC56_CONSOLE_FLAGS
    38                                  sta HBC56_CONSOLE_FLAGS
    39                          }
    40                          
    41                          
    42                          !macro hbc56SetVsyncCallback .vsync {
    43                                  lda #<.vsync
    44                                  sta HBC56_VSYNC_CALLBACK
    45                                  lda #>.vsync
    46                                  sta HBC56_VSYNC_CALLBACK + 1
    47                          }
    48                          
    49                          !macro hbc56SetViaCallback .cb {
    50                                  lda #<.cb
    51                                  sta HBC56_VIA_CALLBACK
    52                                  lda #>.cb
    53                                  sta HBC56_VIA_CALLBACK + 1
    54                          }
    55                          
    56                          
    57                          !macro setHbcMetaTitle .titleStr {
    58                                  jmp .hbcMetaTitleOut
    59                          .titleStrLabel:
    60                                  !text .titleStr
    61                          .titleStrLabelLen = * - .titleStrLabel
    62                                  !byte 0 ; nul terminator for game name
    63                          
    64                          !if .titleStrLabelLen > HBC56_META_TITLE_MAX_LEN {
    65                                  !error "setHbcMetaTitle: Title metadata limited to ",HBC56_META_TITLE_MAX_LEN,"bytes"
    66                          }
    67                          .hbcMetaTitleOut:
    68                                  +memcpy HBC56_META_TITLE + (HBC56_META_TITLE_MAX_LEN-.titleStrLabelLen)/2, .titleStrLabel, .titleStrLabelLen
    69                                  lda #.titleStrLabelLen
    70                                  sta HBC56_META_TITLE_LEN
    71                          }
    72                          
    73                          !macro consoleEnableCursor {
    74                                  lda HBC56_CONSOLE_FLAGS
    75                                  ora #HBC56_CONSOLE_FLAG_CURSOR
    76                                  sta HBC56_CONSOLE_FLAGS
    77                          }
    78                          
    79                          !macro consoleDisableCursor {
    80                                  lda HBC56_CONSOLE_FLAGS
    81                                  and #!HBC56_CONSOLE_FLAG_CURSOR & $ff
    82                                  sta HBC56_CONSOLE_FLAGS
    83                          }
    84                          
    85                          !macro consoleLCDMode {
    86                                  lda HBC56_CONSOLE_FLAGS
    87                                  ora #HBC56_CONSOLE_FLAG_LCD
    88                                  sta HBC56_CONSOLE_FLAGS
    89                          }
    90                          
    91                          !macro setBreakpoint {
    92                                 !byte $db 
    93                          }
    94                          
    95                          !macro hbc56CustomDelay .delay {
    96                                  ldy #.delay
    97                                  jsr hbc56CustomDelay
    98                          }
    99                          
   100                          !macro hbc56DelayUs .us {
   101                          !if .us = 1 {
   102                                  nop
   103                                  nop
   104                          }
   105                          }
   106                          !macro hbc56DelayMs .ms {
   107                                  lda #<.ms
   108                                  sta DELAY_L
   109                                  lda #>.ms
   110                                  sta DELAY_H
   111                          
   112                                  jsr hbc56CustomDelayMs

; ******** Source: kernel.asm
   189                          

; ******** Source: interrupts.asm
     1                          ; 6502 - HBC-56 Kernel Interrupt Handling
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; -------------------------
    12                          ; Interrupts
    13                          ; -------------------------
    14                          TMS9918_IRQ            = 1      ; /INT
    15                          KB_IRQ                 = 2      ; RES1
    16                          UART_IRQ               = 3      ; RES2
    17                          VIA_IRQ                = 5      ; Onboard
    18                          
    19                          TMS9918_IRQ_BIT = (1 << (TMS9918_IRQ - 1))
    20                          KB_IRQ_BIT      = (1 << (KB_IRQ - 1))
    21                          UART_IRQ_BIT    = (1 << (UART_IRQ - 1))
    22                          VIA_IRQ_BIT     = (1 << (VIA_IRQ - 1))
    23                          
    24                          INT_CTRL_ADDRESS    = IO_PORT_BASE_ADDRESS | INT_IO_PORT
    25                          
    26                          ; -----------------------------------------------------------------------------
    27                          ; HBC-56 Interrupt handler
    28                          ; -----------------------------------------------------------------------------
    29                          hbc56IntHandler:
    30  f0f6 48                         pha
    31  f0f7 da                         phx
    32  f0f8 5a                         phy
    33                          
    34  f0f9 addf7f                     lda INT_CTRL_ADDRESS
    35                          
    36                          !ifdef HAVE_UART {
    37  f0fc 8904                       bit #UART_IRQ_BIT
    38  f0fe f005                       beq +
    39  f100 2095ea                     jsr uartIrq        
    40  f103 801e                       bra @endIntHandler
    41                          +
    42                          }
    43                          
    44                          !ifdef HAVE_TMS9918 {
    45  f105 8901                       bit #TMS9918_IRQ_BIT
    46  f107 f008                       beq +
    47  f109 2027f1                     jsr hbc56Tms9918Int
    48  f10c 2c117f                     +tmsReadStatus
    49  f10f 8012                       bra @endIntHandler
    50                          +
    51                          }
    52                          
    53  f111 8910                       bit #VIA_IRQ_BIT
    54  f113 f005                       beq +
    55  f115 200dee                     jsr viaIntHandler
    56  f118 8009                       bra @endIntHandler
    57                          +
    58                          
    59                          !ifdef HAVE_KEYBOARD {
    60  f11a 8902                       bit #KB_IRQ_BIT
    61  f11c f005                       beq +
    62  f11e 2076eb                     jsr kbIntHandler
    63  f121 8000                       bra @endIntHandler
    64                          +
    65                          }
    66                                  
    67                          @endIntHandler:
    68  f123 7a                         ply
    69  f124 fa                         plx
    70  f125 68                         pla      
    71  f126 40                         rti
    72                          
    73                          
    74                          
    75                          ; -----------------------------------------------------------------------------
    76                          ; HBC-56 TMS9918 VSYNC Interrupt handler
    77                          ; -----------------------------------------------------------------------------
    78                          !ifdef HAVE_TMS9918 {
    79                          hbc56Tms9918Int:
    80                          
    81                                  ; update ticks and seconds
    82  f127 ee9f7c                     inc HBC56_TICKS
    83  f12a ad9f7c                     lda HBC56_TICKS
    84  f12d c93c                       cmp #TMS_FPS
    85  f12f d00d                       bne +
    86  f131 a900                       lda #0
    87  f133 8d9f7c                     sta HBC56_TICKS
    88  f136 eea07cd003eea17c           +inc16 HBC56_SECONDS_L
    89                          +
    90                                  ; "tick" for sfx manager
    91                                  !ifdef HAVE_SFX_MAN {
    92                                          jsr sfxManTick
    93                                  }
    94                          
    95                                  ; handle console if enabled
    96  f13e 2ca37c                     bit HBC56_CONSOLE_FLAGS
    97  f141 1003                       bpl +
    98  f143 2049f1                     jsr .consoleVsyncCallback
    99                          +
   100                          
   101                                  ; rely on callback rts to return
   102  f146 6cb97c                     jmp (HBC56_VSYNC_CALLBACK)
   103                          
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; HBC-56 TMS9918 Console update
   107                          ; -----------------------------------------------------------------------------
   108                          .consoleVsyncCallback:
   109                          
   110  f149 ad9f7c                     lda HBC56_TICKS
   111  f14c f007                       beq .doCursor
   112  f14e c91e                       cmp #30
   113  f150 f003                       beq .doCursor
   114  f152 4c76f1                     jmp @endConsoleCallback
   115                          
   116                          .doCursor:
   117  f155 8ea47c                     stx HBC56_TMP_X
   118  f158 8ca57c                     sty HBC56_TMP_Y
   119  f15b 2067e9                     jsr tmsSetPosConsole
   120  f15e ad9f7c                     lda HBC56_TICKS
   121  f161 f00b                       beq +
   122  f163 a920                       lda #' '
   123  f165 8d107f2079e5               +tmsPut
   124  f16b 4c76f1                     jmp @endConsoleCallback
   125                          + 
   126  f16e a97f                       lda #$7f
   127  f170 8d107f2079e5               +tmsPut
   128                          
   129                          @endConsoleCallback
   130                          
   131                          .nullCallbackFunction:
   132  f176 60                         rts
   133                          }

; ******** Source: kernel.asm
   190                          
   191                          
   192                          ; -----------------------------------------------------------------------------
   193                          ; HBC-56 Main entry point (reset vector)
   194                          ; -----------------------------------------------------------------------------
   195                          kernelMain:
   196  f177 78                         sei
   197  f178 d8                         cld     ; make sure we're not in decimal mode
   198  f179 a2ff                       ldx #$ff
   199  f17b 9a                         txs
   200                                  
   201  f17c a940                       lda #RTI_OPCODE
   202  f17e 8d007e                     sta HBC56_INT_VECTOR
   203  f181 8d047e                     sta HBC56_NMI_VECTOR
   204                          
   205  f184 a210a920ca9da67c...        +memset HBC56_META_TITLE, ' ', HBC56_META_TITLE_MAX_LEN
   206                          
   207  f190 a900                       lda #0
   208  f192 8d9f7c                     sta HBC56_TICKS
   209  f195 8da07c                     sta HBC56_SECONDS_L
   210  f198 8da17c                     sta HBC56_SECONDS_H
   211  f19b 8da37c                     sta HBC56_CONSOLE_FLAGS
   212                          
   213  f19e 8db67c                     sta HBC56_META_TITLE + HBC56_META_TITLE_MAX_LEN
   214                          
   215                          
   216  f1a1 20fcdf                     jsr HBC56_META_VECTOR   ; user program metadata
   217                          
   218                                  !ifdef HAVE_KEYBOARD {
   219  f1a4 203beb                             jsr kbInit
   220                                  }
   221                          
   222                                  !ifdef HAVE_AY3891X {
   223  f1a7 2058e1                             jsr ayInit
   224                                  }
   225                          
   226                                  !ifdef HAVE_SFXMAN {
   227                                          jsr sfxManInit  ; requires TMS interrupts
   228                                  }
   229                          
   230                                  !ifdef HAVE_TMS9918 {
   231  f1aa 20d9e6                             jsr tmsInit
   232                          
   233  f1ad a94020efe5                         +tmsDisableOutput
   234                          
   235                                          ; dummy callback
   236  f1b2 a9768db97ca9f18d...                +hbc56SetVsyncCallback .nullCallbackFunction
   237                                  }
   238                          
   239  f1bc a9768dbb7ca9f18d...        +hbc56SetViaCallback .nullCallbackFunction
   240                          
   241                                  !ifdef HAVE_LCD {
   242                                          jsr lcdDetect
   243                                          bcc @noLcd1                
   244                                          jsr lcdInit
   245                                          jsr hbc56Delay
   246                                          jsr lcdDisplayOn
   247                                          jsr hbc56Delay
   248                          @noLcd1:
   249                                  }
   250                          
   251  f1c6 200af0                     jsr hbc56BootScreen
   252                          
   253  f1c9 a9f68d017ea9f08d...        +setIntHandler hbc56IntHandler
   254                          
   255                                  !ifdef HAVE_TMS9918 {
   256  f1d8 a94020e5e5                         +tmsEnableOutput
   257  f1dd a92020efe5                         +tmsDisableInterrupts
   258                                  }
   259                          
   260  f1e2 a914                       lda #20
   261  f1e4 8da27c                     sta HBC56_TMP
   262                          -
   263  f1e7 20e1ff                     jsr hbc56Delay
   264  f1ea cea27c                     dec HBC56_TMP
   265  f1ed d0f8                       bne -
   266                                 
   267                                  !ifdef HAVE_TMS9918 {
   268  f1ef a92020e5e5                         +tmsEnableInterrupts
   269                                  }
   270  f1f4 58                         cli
   271                          
   272  f1f5 2060f2                     jsr hbc56HighBell
   273                          
   274  f1f8 a910                       lda #HBC56_CONSOLE_FLAG_NOWAIT
   275  f1fa 2ca37c                     bit HBC56_CONSOLE_FLAGS
   276  f1fd d050                       bne .afterInput
   277                          
   278  f1ff a940                       lda #HBC56_CONSOLE_FLAG_NES
   279  f201 2da37c                     and HBC56_CONSOLE_FLAGS
   280  f204 f026                       beq .keyboardInput
   281                          
   282                          
   283                                  ; NES input
   284  f206 78                         sei
   285                                  !ifdef HAVE_TMS9918 {
   286  f207 0878a9268d117f20...                +tmsPrintZ .HBC56_PRESS_ANY_NES_TEXT, (32 - .HBC56_PRESS_ANY_NES_TEXT_LEN) / 2, 17
   287                                  }
   288                          
   289                                  !ifdef HAVE_LCD {
   290                                          jsr lcdDetect
   291                                          bcc @noLcd2
   292                                          !ifdef HAVE_GRAPHICS_LCD {
   293                                                  +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*6, .HBC56_PRESS_ANY_NES_TEXT, 16
   294                                                  ldy #6
   295                                                  jsr tilemapRenderRowToLcd
   296                                          } else {
   297                                                  lda #<.HBC56_PRESS_ANY_NES_TEXT
   298                                                  sta STR_ADDR_L
   299                                                  lda #>.HBC56_PRESS_ANY_NES_TEXT
   300                                                  sta STR_ADDR_H
   301                                                  jsr lcdPrint
   302                                          }
   303                          @noLcd2:
   304                                  }
   305  f225 58                         cli
   306  f226 201eeb                     jsr nesWaitForPress
   307  f229 4c4ff2                     jmp .afterInput
   308                          
   309                          .keyboardInput
   310                          !ifdef HAVE_KEYBOARD {
   311                                  ; Keyboard  input
   312  f22c 78                         sei
   313                                  !ifdef HAVE_TMS9918 {
   314  f22d 0878a9288d117f20...                +tmsPrintZ .HBC56_PRESS_ANY_KEY_TEXT, (32 - .HBC56_PRESS_ANY_KEY_TEXT_LEN) / 2, 17
   315                                  }
   316                          
   317                                  !ifdef HAVE_LCD {
   318                                          jsr lcdDetect
   319                                          bcc @noLcd3
   320                                          !ifdef HAVE_GRAPHICS_LCD {
   321                                                  +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*6, .HBC56_PRESS_ANY_KEY_TEXT, 16
   322                                                  ldy #6
   323                                                  jsr tilemapRenderRowToLcd
   324                                          } else {
   325                                                  lda #<.HBC56_PRESS_ANY_KEY_TEXT
   326                                                  sta STR_ADDR_L
   327                                                  lda #>.HBC56_PRESS_ANY_KEY_TEXT
   328                                                  sta STR_ADDR_H
   329                                                  jsr lcdPrint        
   330                                          }
   331                          @noLcd3:
   332                                  }
   333  f24b 58                         cli
   334  f24c 207fec                     jsr kbWaitForScancode
   335                          }
   336                          
   337                          .afterInput
   338                          
   339                                  !ifdef HAVE_LCD {
   340                                          ;jsr lcdDetect
   341                                          ;bcc @noLcd4
   342                                          jsr lcdInit
   343                                          !ifdef HAVE_GRAPHICS_LCD {
   344                                                  jsr lcdTextMode
   345                                          }
   346                                          jsr lcdClear
   347                                          jsr lcdHome
   348                          @noLcd4:
   349                                  }
   350                          
   351                                  !ifdef HAVE_TMS9918 {
   352  f24f 20ade7                             jsr tmsInitTextTable ; clear output
   353  f252 a94020efe5                         +tmsDisableOutput
   354  f257 a92020efe5                         +tmsDisableInterrupts
   355                                  }
   356                                  ; no interrupts until the user code says so
   357  f25c 78                         sei
   358                          
   359  f25d 200080                     jsr DEFAULT_HBC56_RST_VECTOR
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; Beep (higher tone)
   363                          ; -----------------------------------------------------------------------------
   364                          hbc56HighBell:
   365                                  !ifdef HAVE_AY3891X {
   366  f260 a9078d407fad427f...                +ayToneEnable AY_PSG0, AY_CHC
   367  f272 a90a8d407fa90f8d...                +aySetVolume AY_PSG0, AY_CHC, $ff
   368  f27c a9048d407fa9598d...                +ayPlayNote AY_PSG0, AY_CHC, NOTE_FREQ_F5
   369                                  }
   370  f290 8032                       bra .noteTimeout
   371                          
   372                          ; -----------------------------------------------------------------------------
   373                          ; Beep (lower tone)
   374                          ; -----------------------------------------------------------------------------
   375                          hbc56Bell:
   376                                  !ifdef HAVE_AY3891X {
   377  f292 a9078d407fad427f...                +ayToneEnable AY_PSG0, AY_CHC
   378  f2a4 a90a8d407fa90f8d...                +aySetVolume AY_PSG0, AY_CHC, $ff
   379  f2ae a9048d407fa97b8d...                +ayPlayNote AY_PSG0, AY_CHC, NOTE_FREQ_E3
   380                                  }
   381  f2c2 8000                       bra .noteTimeout
   382                          
   383                          .noteTimeout
   384                                  !ifdef HAVE_SFXMAN {
   385                                          lda HBC56_CONSOLE_FLAGS
   386                                          and #HBC56_CONSOLE_FLAG_LCD
   387                                          bne @skipSfxMan
   388                                          +sfxManSetChannelTimeout  AY_PSG0, AY_CHC, 0.16
   389                                          rts
   390                                  }
   391                          @skipSfxMan
   392                                  !ifdef HAVE_AY3891X {
   393  f2c4 20e1ff                             jsr hbc56Delay
   394  f2c7 20e1ff                             jsr hbc56Delay
   395  f2ca a9048d407fa9008d...                +ayStop AY_PSG0, AY_CHC
   396                                  }
   397                          
   398  f2de 60                         rts
   399                          
   400                          ; -----------------------------------------------------------------------------
   401                          ; Software reset
   402                          ; -----------------------------------------------------------------------------
   403                          hbc56Reset:
   404  f2df 4c77f1                     jmp kernelMain
   405                          
   406                          ; -----------------------------------------------------------------------------
   407                          ; Stop (loop forever)
   408                          ; -----------------------------------------------------------------------------
   409                          hbc56Stop:
   410  f2e2 cb                         wai
   411  f2e3 4ce2f2                     jmp hbc56Stop
   412                          
   413                          ; -----------------------------------------------------------------------------
   414                          ; Delay function
   415                          ; -----------------------------------------------------------------------------
   416                          hbc56CustomDelayMs:
   417  f2e6 e635                       inc DELAY_H
   418                          -
   419  f2e8 a003                       ldy #3
   420  f2ea 20e3ff                     jsr hbc56CustomDelay
   421  f2ed c634               	dec DELAY_L
   422  f2ef d0f7               	bne -
   423  f2f1 a900               	lda #0
   424  f2f3 8534                       sta DELAY_L
   425  f2f5 c635               	dec DELAY_H
   426  f2f7 d0ef               	bne -
   427  f2f9 60                 	rts
   428                          
   429                          
   430                          ;!warn "Kernel size: ", *-$f000
